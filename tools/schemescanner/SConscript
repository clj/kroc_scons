import os, os.path
from string import Template

Import("env")

local = env.Clone()

# This variable will get used throughout 
# the rest of the script. Sets the compiler
# used for building Scheme executables.
mzcompiler = "mzc"

def CheckForExecutable(context, exe):
  # Using 0 and 1 for the result let SCons correctly
  # print "yes" and "no" in the output to the user.
  result = 0
  context.Message("Checking for %s... " % exe)
  for dir in local["ENV"]["PATH"].split(":"):
    if os.access(os.path.join(dir, exe), os.X_OK):
      result = 1
      break

  # We need to stuff this back into the context object.
  # So sayth the documentation.
  context.Result(result)
  return result

# Adding our custom checker for the mzc executable.
conf  = local.Configure(custom_tests = {"CheckForExecutable" : CheckForExecutable })

# This builder just does a syscall to invoke the 
# MzC compiler on a single Scheme file.
def build (target, source, env):
  cmd = Template("$MZC --exe $TGT $SRC")
  cmdstring = cmd.substitute(MZC = mzcompiler,
    TGT = target[0].rstr(), 
    SRC = source[0].rstr())
  os.system(cmdstring)

# If the compiler is found, build the Scheme executable.
# Otherwise, bail with an error for the user.
if conf.CheckForExecutable(mzcompiler):
  local.Command("schemescanner", "schemescanner.scm", build)
else:
  print "%s cannot be found!" % mzscompiler
  Exit(1)

local = conf.Finish()
