import os, os.path
from string import Template

Import("env")

local = env.Clone()

def CheckForMzScheme(context):
  # Using 0 and 1 for the result let SCons correctly
  # print "yes" and "no" in the output to the user.
  result = 0
  context.Message("Checking for MzScheme... ")
  for dir in local["ENV"]["PATH"].split(":"):
    if os.access(os.path.join(dir, "mzscheme"), os.X_OK):
      result = 1
      break

  # We need to stuff this back into the context object.
  # So sayth the documentation.
  context.Result(result)
  return result

# Adding our custom checker for the MzScheme executable.
conf  = local.Configure(custom_tests = {"CheckForMzScheme" : CheckForMzScheme })

if not conf.CheckForMzScheme():
  print "MzScheme cannot be found!"
  Exit(1)

# This builder just does a syscall to invoke the 
# MzC compiler on a single Scheme file.
def build (target, source, env):
  cmd = Template("mzc --exe $TGT $SRC")
  cmdstring = cmd.substitute(TGT = target[0].rstr(), SRC = source[0].rstr())
  os.system(cmdstring)

local.Command("schemescanner", "schemescanner.scm", build)

local = conf.Finish()
