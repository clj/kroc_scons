--** occam bindings for the Wiring API.
-- @module wiring

#IF NOT (DEFINED (WIRING.MODULE))
#DEFINE WIRING.MODULE

#INCLUDE "avr.module"

--{{{  constants
VAL INT LOW IS #0:
VAL INT HIGH IS #1:

VAL INT INPUT IS #0:
VAL INT OUTPUT IS #1:

VAL INT SERIAL  IS #0:
VAL INT DISPLAY IS #1:

VAL INT LSBFIRST IS 0:
VAL INT MSBFIRST IS 1:

VAL INT CHANGE IS 1:
VAL INT FALLING IS 2:
VAL INT RISING IS 3:

VAL INT INTERNAL IS 3:
VAL INT DEFAULT IS 1:
VAL INT EXTERNAL IS 0:
--}}}

--{{{  PROC delay
--* Wait for a period of time.
-- @param millis Time in wait, in milliseconds
PROC delay (VAL INT millis)
  TIMER tim:
  INT t:
  SEQ
    tim ? t
    tim ? AFTER t PLUS millis
:
--}}}

--{{{ PROC die
PROC die (VAL []BYTE error)
  CAUSEERROR ()
:
--}}}

--{{{  FUNCTION pin.location
--* Map an Arduino pin number to a DDR register, PORT register and bit number.
--* Digital pins 0-7 map to PORTD bits 0-7
--* Digital pins 8-13 map to PORTB 8-13
--* 
--* There are no official mappins for the analog pins. 
--* Analog pins 0-5 map to PORTC bits 0-5
--* 
--* A request for a pin out of range will result in an unrecoverable error.
-- @private

INT, INT, INT FUNCTION pin.location (VAL INT pin)
  INT ddr, port, bit:
  VALOF
    IF
      -- Digital pins 0 - 7 on the Aruino
      pin < 8
        ddr, port, bit := DDRD, PORTD, pin
      -- Digital pins 8 - 13 on the Arduino
      pin < 14
        ddr, port, bit := DDRB, PORTB, pin - 8
      -- Just keep counting up for the analog pins.
      -- Analog pins 0 - 5
      pin < 21
        ddr, port, bit := DDRC, PORTC, pin - 14
      TRUE
        die ("No mapping for requested pin.") 
    RESULT ddr, port, bit
:
--}}}

--{{{  PROC digitalWrite
PROC digitalWrite (VAL INT pin, state)
  INT ddr, port, bit:
  PLACED [MAX.PORT]BYTE ports 0:
  SEQ
    ddr, port, bit := pin.location (pin)
    ports[port] := (ports[port] /\ (~BV (bit))) \/ ((BYTE state) << bit)
:
--}}}
--{{{  PROC pinMode
PROC pinMode (VAL INT pin, mode)
  INT ddr, port, bit:
  PLACED [MAX.PORT]BYTE ports 0:
  SEQ
    ddr, port, bit := pin.location (pin)
    ports[ddr] := (ports[ddr] /\ (~BV (bit))) \/ ((BYTE mode) << bit)
:
--}}}

--{{{  PROC beginSerial
--* Initialise the serial port.
-- @param baud Baud rate
PROC beginSerial (VAL INT32 baud)
  VAL INT32 factor IS (((F.CPU / 16) + (baud / 2)) / baud) - 1:
  VAL [4]BYTE factor.bytes RETYPES factor:

  PLACED [MAX.PORT]BYTE ports 0:
  SEQ
    ports[UBRR0H] := factor.bytes[1]
    ports[UBRR0L] := factor.bytes[0]

    ports[UCSR0C] := 3 << UCSZ00
    ports[UCSR0B] := BV (TXEN0)
:
--}}}
--{{{  PROC serialWrite
--* Write a string to the serial port.
-- @param string Bytes to write
PROC serialWrite (VAL []BYTE string)
  SEQ i = 0 FOR SIZE string
    PLACED [MAX.PORT]BYTE ports 0:
    #PRAGMA DEFINED ports
    SEQ
      WHILE (ports[UCSR0A] /\ BV (UDRE0)) = 0
        SKIP
      ports[UDR0] := string[i]
:
--}}}
--{{{  PROC serialWriteInt
--* Write an [@code INT] to the serial port in hex.
PROC serialWriteInt (VAL INT n)
  VAL []BYTE digits IS "0123456789abcdef":
  SEQ i = 3 FOR 4 STEP -1
    serialWrite ([digits[(n >> (i * 4)) /\ #F]])
:
--}}}
--{{{  PROC serialWriteInt32
--* Write an [@code INT32] to the serial port in hex.
PROC serialWriteInt32 (VAL INT32 n)
  VAL []BYTE digits IS "0123456789abcdef":
  SEQ i = 7 FOR 8 STEP -1
    serialWrite ([digits[INT ((n >> (i * 4)) /\ #F)]])
:
--}}}

#ENDIF
