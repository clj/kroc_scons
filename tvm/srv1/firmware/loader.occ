#INCLUDE "srv1.inc"
#INCLUDE "memory_map.inc"

#INCLUDE "delay.inc"
#INCLUDE "tvm.inc"

#INCLUDE "lasers.occ"
#INCLUDE "leds.occ"
#INCLUDE "motors.occ"
#INCLUDE "out.occ"

PROC drain.uart (CHAN BYTE in?)
  INITIAL INT clear IS 0:
  WHILE clear < 10
    PRI ALT
      BYTE b:
      in ? b
        SKIP
      TRUE & SKIP
        SEQ
          delay.us (100000)
          clear := clear + 1
:

PROC download.header (SRV.HEADER header, CHAN BYTE in?, out!)
  SEQ
    INITIAL BOOL done IS FALSE:
    WHILE NOT done
      SEQ
        out.string ("Waiting for header (", 0, out!)
        out.int (BYTESIN(SRV.HEADER), 0, out!)
        out.string (" bytes)*n", 0, out!)

        []BYTE header RETYPES header:
        SEQ i = 0 FOR SIZE header
          in ? header[i >< 3] -- byteswap from 32bit big-endian

        IF
          header[tbc.version] = #74766D03 -- TVM\003
            done := TRUE
          TRUE
            SEQ
              out.string ("Bad TBC Header ID = ", 0, out!)
              out.hex (header[tbc.version], 0, out!)
              out ! '*n'
              drain.uart (in?)
    
    #PRAGMA DEFINED header
    out.string ("Got header, ws.size = ", 0, out!)
    out.int (header[ws.size], 0, out!)
    out.string (", vs.size = ", 0, out!)
    out.int (header[vs.size], 0, out!)
    out.string (", ms.size = ", 0, out!)
    out.int (header[ms.size], 0, out!)
    out.string (".*n", 0, out!)
:

PROC download.bytecode ([]BYTE bytecode, CHAN BYTE in?, out!)
  SEQ
    out.string ("Waiting for bytecode (", 0, out!)
    out.int (SIZE bytecode, 0, out!)
    out.string (" bytes).*n", 0, out!)

    SEQ i = 0 FOR SIZE bytecode
      SEQ
        in ? bytecode[i]
        out ! '#'

    out ! '*n'
:

PROC input.tap (CHAN BYTE in?, out!, BOOL killed, CHAN BOOL shutdown?)
  INITIAL BOOL done IS FALSE:
  WHILE NOT done
    PRI ALT
      shutdown ? done
        SKIP
      BYTE b:
      in ? b
        IF
          b = '!'
            BYTE c:
            SEQ
              in ? c
              IF
                c = '*n'
                  SEQ
                    killed := TRUE
                    firmware.kill.user ()
                TRUE
                  SEQ
                    out ! b
                    out ! c
          TRUE
            out ! b
:

PROC output.tap (CHAN BYTE in?, out!, CHAN BOOL shutdown?)
  INITIAL BOOL done IS FALSE:
  WHILE NOT done
    PRI ALT
      shutdown ? done
        SKIP
      BYTE b:
      in ? b
        out ! b
:

PROC run.bytecode (VAL SRV.HEADER header, VAL []BYTE bytecode, BOOL killed, CHAN BYTE in?, out!)
  SEQ
    out.string ("Running bytecode...*n", 0, out!)

    [5]CHAN BOOL  shutdown:
    CHAN P.LASER  laser:
    CHAN P.LED    led:
    CHAN P.MOTOR  motor:
    CHAN BYTE     data.in, data.out:
    PAR
      input.tap (in?, data.in!, killed, shutdown[0]?)
      output.tap (data.out?, out!, shutdown[1]?)
      lasers (laser?, shutdown[2]?)
      leds (led?, shutdown[3]?)
      motors (motor?, shutdown[4]?)
      
      SEQ
        VAL INT ws IS header[ws.size]:
        VAL INT vs IS header[vs.size]:
        VAL INT ms IS header[ms.size]:
        firmware.run.user (bytecode, ws, vs, ms, data.in?, data.out!, laser!, led!, motor!)
        PAR i = 0 FOR SIZE shutdown
          shutdown[i] ! TRUE
:

PROC report.termination (VAL []BYTE bytecode, VAL BOOL killed, CHAN BYTE out!)
  ECTX context:
  BOOL running:
  INT state:
  SEQ
    []BYTE context RETYPES context:
    firmware.query.user (running, state, context)

    IF
      killed
        out.string ("Program killed.*n", 0, out!)
      state = ECTX.SHUTDOWN
        out.string ("Program terminated normally.*n", 0, out!)
      state = ECTX.EMPTY
        out.string ("Program deadlocked.*n", 0, out!)
      TRUE
        SEQ
          out.string ("Program terminated with a ", 0, out!)

          IF
            context[eflags] = EFLAG.SETERR
              out.string ("assertion", 0, out!)
            context[eflags] = EFLAG.INTERR
              out.string ("range", 0, out!)
            context[eflags] = EFLAG.INTOV
              out.string ("arithmetic overflow", 0, out!)
            context[eflags] = EFLAG.ALT
              out.string ("ALT", 0, out!)
            context[eflags] = EFLAG.FFI
              out.string ("FFI", 0, out!)
            context[eflags] = EFLAG.CHAN
              out.string ("channel", 0, out!)
            context[eflags] = EFLAG.EXTCHAN
              out.string ("external channel", 0, out!)
            context[eflags] = EFLAG.BAR
              out.string ("barrier", 0, out!)
            context[eflags] = EFLAG.DMEM
              out.string ("dynamic memory", 0, out!)
            context[eflags] = EFLAG.MT
              out.string ("mobile type", 0, out!)
            context[eflags] = EFLAG.PROC
              out.string ("process", 0, out!)
            TRUE
              out.string ("unknown", 0, out!)

          out.string (" error. (state = ", 0, out!)
          out.byte (BYTE state, 0, out!)
          out.string (")*n", 0, out!)

          VAL INT iptr IS (context[iptr] - USER.BYTECODE):
          SEQ
            out.string ("WPTR = ", 0, out!)
            out.hex (context[wptr], 0, out!)
            out ! '*n'
            out.string ("IPTR = ", 0, out!)
            out.hex (iptr, 0, out!)
            out ! '*n'
            out.string ("Bytecodes before IPTR =", 0, out!)
            SEQ i = (iptr - 8) FOR 8
              IF 
                (i > 0) AND (i < (SIZE bytecode))
                  SEQ
                    out ! ' '
                    out.hex.byte (bytecode[i], out!)
                TRUE
                  SKIP
            out ! '*n'
:

PROC loader (CHAN BYTE in?, out!)
  PLACED [USER.MEMORY - USER.BYTECODE]BYTE bytecode USER.BYTECODE:
  #PRAGMA DEFINED bytecode

  INITIAL BOOL killed IS FALSE:

  SRV.HEADER header:

  SEQ
    -- Clear out UART
    drain.uart (in?)

    -- Download header
    download.header (header, in?, out!)
    #PRAGMA DEFINED header

    []BYTE bytecode IS [ bytecode FOR header[inst.size] ]:
    SEQ
      -- Download bytecode
      download.bytecode (bytecode, in?, out!)

      -- Run bytecode
      run.bytecode (header, bytecode, killed, in?, out!)
      
      -- Tell the user what happened to their program
      report.termination (bytecode, killed, out!)
:

