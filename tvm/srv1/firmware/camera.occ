#INCLUDE "srv1.inc"

VAL INT CAMERA.INIT       IS -1:
VAL INT CAMERA.OFF        IS 0:
VAL INT CAMERA.160.128    IS 1:
VAL INT CAMERA.320.256    IS 2:
VAL INT CAMERA.640.512    IS 3:
VAL INT CAMERA.1280.1024  IS 4:
VAL INT CAMERA.ONE.SHOT   IS #10:

DATA TYPE CAMERA.MODE
  RECORD
    INT w:
    INT h:
    INT mode:
:

PROC camera (CAMERA? svr)
  VAL INT           buffers IS 2:
  VAL []CAMERA.MODE modes   IS [[ 160,  128, CAMERA.160.128  ],
                                [ 320,  256, CAMERA.320.256  ],
                                [ 640,  512, CAMERA.640.512  ],
                                [1280, 1024, CAMERA.1280.1024]]:
  
  BOOL, INT FUNCTION find.mode (VAL INT w, h)
    BOOL found:
    INT mode:
    VALOF
      IF
        IF i = 0 FOR SIZE modes
          VAL CAMERA.MODE m IS modes[i]:
          (m[w] = w) AND (m[h] = h)
            found, mode := TRUE, m[mode]
        TRUE
          found, mode := FALSE, CAMERA.OFF
      RESULT found, mode
  :

  CHAN INT camera.mode:
  PLACE camera.mode AT #2:

  CHAN INT camera.error:
  PLACE camera.error AT #2:

  CHAN MOBILE []BYTE camera.data:
  PLACE camera.data AT #2:

  INITIAL INT mode        IS CAMERA.OFF:
  INITIAL BOOL stream     IS FALSE:
  SEQ
    INITIAL BOOL done IS FALSE:
    WHILE NOT done
      svr[req] ? CASE
        disconnected
          done := TRUE

        get.frame
          IF
            mode <> CAMERA.OFF
              MOBILE []BYTE data:
              SEQ
                camera.data ? data
                IF
                  DEFINED data
                    -- No error; pass frame
                    svr[rsp] ! frame; data
                  TRUE
                    -- Frame empty; error
                    INT error:
                    SEQ
                      camera.error ? error
                      IF
                        error = 0
                          svr[rsp] ! error; ERROR.NO.MEMORY
                        TRUE
                          SEQ
                            svr[rsp] ! error; ERROR.HARDWARE
                      
                      mode := CAMERA.OFF
                      camera.mode ! mode
            TRUE
              svr[rsp] ! error; ERROR.INV.STATE

        get.mode
          IF
            IF i = 0 FOR SIZE modes
              VAL CAMERA.MODE m IS modes[i]:
              m[mode] = mode
                IF
                  stream
                    svr[rsp] ! stream.mode; m[w]; m[h]
                  TRUE
                    svr[rsp] ! capture.mode; m[w]; m[h]
            TRUE
              svr[rsp] ! error; ERROR.INV.STATE

        init
          SEQ
            mode := CAMERA.INIT
            camera.mode ! mode
            mode := CAMERA.OFF

        INT w, h:
        set.capture.mode; w; h
          BOOL found:
          INT new.mode:
          SEQ
            found, new.mode := find.mode (w, h)
            IF
              found
                SEQ
                  mode, stream := new.mode, FALSE
                  camera.mode ! mode \/ CAMERA.ONE.SHOT
                  svr[rsp] ! ok
              TRUE
                svr[rsp] ! error; ERROR.INV.PARAM

        INT w, h:
        set.stream.mode; w; h
          BOOL found:
          INT new.mode:
          SEQ
            found, new.mode := find.mode (w, h)
            IF
              found
                SEQ
                  mode, stream := new.mode, TRUE
                  camera.mode ! mode
                  svr[rsp] ! ok
              TRUE
                svr[rsp] ! error; ERROR.INV.PARAM

        stop
          SEQ
            mode := CAMERA.OFF
            camera.mode ! mode
      
    IF
      mode <> CAMERA.OFF
        SEQ
          mode := CAMERA.OFF
          camera.mode ! mode
      TRUE
        SKIP
:

