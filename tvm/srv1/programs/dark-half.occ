#INCLUDE "srv1.inc"
#INCLUDE "delay.inc"
#INCLUDE "out.occ"

VAL INT width IS 320:
VAL INT height IS 256:

DATA TYPE UYVY
  PACKED RECORD
    BYTE u:
    BYTE y.0:
    BYTE v:
    BYTE y.1:
:

DATA TYPE LEFT.RIGHT
  PACKED RECORD
    INT left:
    INT right:
:

DATA TYPE PICK IS INT:

VAL PICK PICK.NONE  IS 0:
VAL PICK PICK.LEFT  IS 1:
VAL PICK PICK.RIGHT IS 2:

INT FUNCTION calc.avg.luma (VAL INT x, y, width, height, VAL []BYTE frame)
  INT avg.luma:
  VALOF
    VAL []UYVY image RETYPES frame:
    -- Set the start position at 1/16 offset of both width and height.
    VAL INT start.pos IS (((SIZE image) >> 4) + (scan.width >> 3)) + scan.x:
    SEQ
      avg.luma := 0
      -- Step 1/8's across the height of the image.
      SEQ y = start.pos FOR 8 STEP ((SIZE image) >> 3)
        -- Step 1/8's across the scanned width of the image.
        SEQ pos = y FOR 8 STEP (scan.width >> 2)
          VAL pixel IS image[pos]:
          SEQ
            avg.luma := avg.luma + (INT pixel[y.0])
      -- Divide by 64, the number of sampled pixels.
      avg.luma := avg.luma >> 6
    RESULT avg.luma
:

PROC get.image (CAMERA! camera, CHAN MOBILE []BYTE frames!)
  MOBILE []BYTE frame:
  SEQ
    -- Start camera
    camera[req] ! set.stream.mode; width; height
    camera[rsp] ? CASE ok
    
    -- Let it adjust to light level then freeze settings
    --camera[req] ! set.auto.adjust; TRUE
    --camera[rsp] ? CASE ok
    --delay.s (3)
    --camera[req] ! set.auto.adjust; FALSE
    --camera[rsp] ? CASE ok

    -- Sample frames
    WHILE TRUE
      SEQ
        camera[req] ! get.frame
        camera[rsp] ? CASE frame; frame
        frames ! frame
:

PROC avg.luma.halves (CHAN MOBILE []BYTE frames?, CHAN LEFT.RIGHT luma!)
  MOBILE []BYTE frame:
  WHILE TRUE
    LEFT.RIGHT avg.luma:
    SEQ
      frames ? frame
      avg.luma[left]  := calc.avg.luma (0, width / 2, frame)
      avg.luma[right] := calc.avg.luma (width / 2, width / 2, frame)
      luma ! avg.luma
:

PROC pick.darker.half (CHAN LEFT.RIGHT luma?, CHAN PICK pick!)
  WHILE TRUE
    LEFT.RIGHT avg.luma:
    INT diff:
    SEQ
      luma ? avg.luma
      diff := avg.luma[left] - avg.luma[right]
      IF
        diff = 0
          pick ! PICK.NONE
        diff < 0
          pick ! PICK.LEFT
        TRUE
          pick ! PICK.RIGHT
:

PROC change.delta (CHAN PICK in?, out.0!, out.1!)
  PICK this:
  SEQ
    in ? this

    WHILE TRUE
      PICK new:
      SEQ
        PAR
          out.0 ! this
          out.1 ! this

        in ? new
        WHILE new = this
          in ? new

        this := new
:

PROC control.lasers (CHAN PICK pick?, LASER! lasers)
  WHILE TRUE
    PICK picked:
    SEQ
      pick ? picked
      lasers[req] ! left; (picked = PICK.LEFT)
      lasers[req] ! right; (picked = PICK.RIGHT)
:

PROC control.leds (CHAN PICK pick?, SYSTEM! system)
  WHILE TRUE
    PICK picked:
    SEQ
      pick ? picked
      system[req] ! set.led; 1; (picked = PICK.LEFT)
      system[req] ! set.led; 2; (picked = PICK.RIGHT)
:

PROC dark.half (CAMERA! camera, CONSOLE! console, LASER! lasers, MOTOR! motors, SYSTEM! system)
  CHAN MOBILE []BYTE frames:
  CHAN LEFT.RIGHT luma:
  CHAN PICK pick, pick.0, pick.1:
  PAR
    get.image (camera, frames!)
    avg.luma.halves (frames?, luma!)
    pick.darker.half (luma?, pick!)
    change.delta (pick?, pick.0!, pick.1!)
    control.lasers (pick.0?, lasers)
    control.leds (pick.1?, system)
:

