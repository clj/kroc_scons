
#INCLUDE "../introspect.inc"

PROC out.repeat (VAL BYTE ch, VAL INT n, CHAN BYTE out!)
  --{{{  
  IF
    n > 0
      SEQ i = 0 FOR n
        out ! ch
    TRUE
      SKIP
  --}}}
:

PROC out.ch (VAL BYTE ch, VAL INT field, CHAN BYTE out!)
  --{{{  
  SEQ
    out.repeat (' ', field - 1, out!)
    out ! ch
  --}}}
:

PROC out.string (VAL []BYTE s, VAL INT field, CHAN BYTE out!)
  --{{{  
  VAL INT length IS SIZE s:
  SEQ
    out.repeat (' ', field - length, out!)
    SEQ i = 0 FOR length
      out ! s[i]
  --}}}
:

PROC out.int (VAL INT n, VAL INT field, CHAN BYTE out!)
  --{{{  
  IF
    n = (MOSTNEG INT)
      --{{{  minint
      out.string ("-2147483648", field, out!)
      --}}}
    n = 0
      --{{{  zero
      SEQ
        IF
          1 < field
            out.repeat (' ', field - 1, out!)
          TRUE
            SKIP
        out ! '0'
      --}}}
    TRUE
      --{{{  anything else
      VAL INT max.digits IS 20:
      [max.digits]INT D:
      INT x, i:
      SEQ
        --{{{  check negative
        IF
          n < 0
            x := -n
          TRUE         -- (n > 0)
            x := n
        --}}}
        --{{{  decompose
        SEQ
          i := 0
          WHILE x > 0
            SEQ
              D[i] := x\10
              x := x/10
              i := i + 1
        --}}}
        --{{{  pad
        IF
          n > 0
            out.repeat (' ', field - i, out!)
          TRUE
            SEQ
              out.repeat (' ', (field - 1) - i, out!)
              out ! '-'
        --}}}
        --{{{  output
        #PRAGMA DEFINED D
        WHILE i > 0
          SEQ
            i := i - 1
            out ! BYTE (D[i] + (INT '0'))
        --}}}
      --}}}
  --}}}
:

PROC out.hex (VAL INT n, VAL INT field, CHAN BYTE out!)
  IF
    n = (MOSTNEG INT)
      out.string ("#80000000", field, out!)
    n = 0
      out.string ("#00000000", field, out!)
    TRUE
      --{{{  anything else
      VAL []BYTE cmap IS "0123456789ABCDEF":
      INT x, i:
      SEQ
        x := n
        IF
          field = 0
            i := 8
          TRUE
            i := (field - 1)
        IF
          i > 0
            SEQ
              out ! '#'
              WHILE i > 0
                SEQ
                  out ! cmap[((x >> ((i - 1) << 2)) /\ #0000000F)]
                  i := i - 1
          TRUE
            SKIP
      --}}}  
:


PROC test3 (CHAN BYTE kyb?, scr!, err!)
  CHAN CT.VM! vc0:
  PLACE vc0 AT #0:
  CT.VM! vm:
  INT n:
  SEQ
    vc0 ? vm
    vm[request] ! load.bytecode; "commstime.tbc"
    vm[response] ? CASE
      CT.BYTECODE! bc:
      bytecode; bc
        CT.VM.CTL! vm.ctl:
        SEQ
          err ! '1'
          bc[request] ! create.vm
          bc[response] ? CASE 
            vm; vm.ctl
              ADDR wptr:
              IPTR iptr:
              INT op, arg:
              SEQ
                err ! '2'
                INITIAL BOOL done IS FALSE:
                INITIAL INT i IS 0:
                WHILE (NOT done) AND (i < 20000)
                  SEQ
                    out.hex (INT iptr, 0, scr!)
                    i := i + 1
                    vm.ctl[request] ! step
                    vm.ctl[response] ? CASE decoded; iptr; op; arg
                    scr ! ' '
                    out.hex (op, 0, scr!)
                    scr ! ' '
                    out.hex (arg, 0, scr!)
                    scr ! '*n'
                    vm.ctl[request] ! dispatch; op; arg
                    vm.ctl[response] ? CASE 
                      dispatched; iptr; wptr
                        INT file, line:
                        SEQ
                          scr ! '*n'
                          bc[request] ! get.line.info; iptr
                          bc[response] ? CASE
                            line.info; file; line
                              MOBILE []BYTE fn:
                              SEQ
                                bc[request] ! get.file; file
                                bc[response] ? CASE file; fn
                                out.string (fn, 0, scr!)
                                scr ! ':'
                                out.int (line, 0, scr!)
                                scr ! '*n'
                            error; n
                              out.string ("unknown position*n", 0, scr!)
                      error; n
                        SEQ
                          err ! 'e'
                          done := TRUE
                err ! '3'
            error; n
              err ! 'e'
          err ! '8'
      error; n
        SKIP
    err ! '9'
:

