
--* Copy input to output.
PROC id (CHAN INT in?, out!)
  --{{{
  WHILE TRUE
    INT x:
    SEQ
      in ? x
      out ! x
  --}}}
:

--* Add one to input numbers.
PROC succ (CHAN INT in?, out!)
  --{{{
  WHILE TRUE
    INT x:
    SEQ
      in ? x
      out ! x PLUS 1  -- let's ignore overflow
  --}}}
:

--* Duplicate a stream of numbers.
PROC delta (CHAN INT in?, out.1!, out.2!)
  --{{{
  WHILE TRUE
    INT x:
    SEQ
      in ? x
      PAR
        out.1 ! x
        out.2 ! x
  --}}}
:

--* Output a fixed number, then copy input to output.
PROC prefix (VAL INT n, CHAN INT in?, out!)
  --{{{
  SEQ
    out ! n
    id (in?, out!)
  --}}}
:

--* Drop the first input number, then copy input to output.
PROC tail (CHAN INT in?, out!)
  --{{{
  SEQ
    INT any:
    in ? any
    id (in?, out!)
  --}}}
:
--{{{  PROC seq.delta (CHAN INT in?, out.0!, out.1!)
PROC seq.delta (CHAN INT in?, out.0!, out.1!)
  WHILE TRUE
    INT n:
    SEQ
      in ? n
      out.0 ! n
      out.1 ! n
:
--}}}

--{{{  PROC consume (VAL INT n.loops, CHAN INT in?, CHAN BYTE out!)
PROC consume (VAL INT n.loops, CHAN INT in?, CHAN BYTE out!)
  TIMER tim:
  INT t0, t1:
  INT value:
  SEQ
    --{{{  warm-up loop
    VAL INT warm.up IS 16:
    SEQ i = 0 FOR warm.up
      in ? value
    --}}}
    WHILE TRUE
      SEQ
        tim ? t0
        --{{{  bench-mark loop
        SEQ i = 0 FOR n.loops
          in ? value
        --}}}
        tim ? t1
        #IF FALSE
        --{{{  report
        VAL INT microsecs IS t1 MINUS t0:
        VAL INT64 nanosecs IS 1000 * (INT64 microsecs):
        SEQ
          out.string ("Last value received = ", 0, out!)
          out.int (value, 0, out!)
          out.string ("*c*n", 0, out!)
          out.string ("Time = ", 0, out!)
          out.int (microsecs, 0, out!)
          out.string (" microsecs*c*n", 0, out!)
          out.string ("Time per loop = ", 0, out!)
          out.int (INT (nanosecs/(INT64 n.loops)), 0, out!)
          out.string (" nanosecs*c*n", 0, out!)
          out.string ("Context switch = ", 0, out!)
          out.int (INT ((nanosecs/(INT64 n.loops))/4), 0, out!)
          out.string (" nanosecs*c*n*n", 0, out!)
        --}}}
        #ENDIF
:
--}}}

--{{{  PROC comms.time (CHAN BYTE keyboard?, screen!, error!)
PROC comms.time (CHAN BYTE keyboard?, screen!, error!)
  VAL BOOL use.seq.delta IS FALSE:
  SEQ
    CHAN INT a, b, c, d:
    PAR
      prefix (0, b?, a!)
      IF
        use.seq.delta
          seq.delta (a?, c!, d!)    -- the one defined above
        TRUE
          delta (a?, c!, d!)        -- the one that does a parallel output
      succ (c?, b!)
      consume (1000000, d?, screen!)

:
--}}}

