-- version control marker $Id: cgtest19.occ,v 1.9 1997/01/22 10:29:54 dcw Exp $

#OPTION "W"   --   this line goes to krtest.occ

#INCLUDE "config.inc"

PROC cgtest19 (CHAN OF BYTE keyb, scr, err)

  #INCLUDE "cgmain.occ"
  #INCLUDE "cgreal.occ"

  --{{{  set up bits.per.word
  INT any :
  VAL []BYTE b RETYPES any :
  VAL bits.per.word IS (SIZE b) * 8 :
  --}}}  
  SEQ
    init ("CG test 19", "Predefines")

    --{{{  test predefines             (F500 - F699)
    PROC predefines()
      SEQ
        --{{{  output message
        title ("Testing predefined functions")
        --}}}  
        --{{{  LONGADD                     (F500 - F509)
        --{{{  constants
        VAL n1 IS 10 :
        VAL n2 IS 15 :
        VAL n3 IS 25 :
        VAL n4 IS 26 :

        VAL c0 IS 0 :
        VAL c1 IS 1 :
        --}}}  
        INT a, b, c :
        SEQ
          check (LONGADD (n1, n2, c0), n3, "F500")
          check (LONGADD (n1, n2, c1), n4, "F501")
          b , c := id(n1), id(n2)
          a := LONGADD (b, c, 7)
          check (a, n4, "F502")
          a := LONGADD (b, c, 8)
          check (a, n3, "F503")
          a := LONGADD (10, LONGADD (b, c, 0), c1)
          check (a, 36, "F504")
          a := LONGADD (LONGADD (b, c, c0), LONGADD (b, c, c1), LONGADD (b, c, 0))
          check (a, 52, "F505")
          b , c := -1, -1
          check (LONGADD (b, c, 0), -2, "F506")
          check (LONGADD (b, c, 1), -1, "F507")
        --}}}  
        --{{{  LONGSUM                     (F510 - F519)
        --{{{  constants
        VAL n1 IS 10 :
        VAL n2 IS 15 :
        VAL n3 IS 25 :
        VAL n4 IS 26 :

        VAL c0 IS 0 :
        VAL c1 IS 1 :
        --}}}  
        INT sum, b, c, carry :
        SEQ
          b , c := id(n1), id(n2)
          carry , sum := LONGSUM (b, c, 7)
          check (sum,  n4, "F510")
          check (carry, 0, "F511")
          carry , sum := LONGSUM (b, c, 8)
          check (sum,  n3, "F512")
          check (carry, 0, "F513")
          carry , sum := LONGSUM (b, c, c1)
          check (sum,  26, "F514")
          check (carry, 0, "F515")
          b , c := -1, 1     -- b is all 1s
          carry , sum := LONGSUM (b, c, 0)
          check (sum,   0, "F516")
          check (carry, 1, "F517")
          carry , sum := LONGSUM (b, c, 1)
          check (sum,   1, "F518")
          check (carry, 1, "F519")

          b , c := -1, -1     -- b & c are all 1s
          carry , sum := LONGSUM (b, c, 0)
          check (sum,   -2, "F519a")
          check (carry,  1, "F519b")
          carry , sum := LONGSUM (b, c, 1)
          check (sum,   -1, "F519c")
          check (carry,  1, "F519d")
          b, c := 1, 2
          carry , sum := LONGSUM (LONGADD(b, c, 0), LONGADD(0, -b, 0), LONGADD(b, c, 0))
          check (sum,   3, "F519e")
          check (carry, 1, "F519f")
        --}}}  
        --{{{  LONGSUB                     (F520 - F529)
        INT diff, x, y, b :
        SEQ
          check (LONGSUB (10, 5, 0), 5, "F520")
          check (LONGSUB (10, 5, 1), 4, "F521")
          x, y, b := 10, 5, 0
          check (LONGSUB (x, y, b), 5, "F522")
          check (LONGSUB (x, y, b + 1), 4, "F523")
          diff := LONGSUB (x, y, b + 1)
          check (diff, 4, "F524")
          diff := LONGSUB (LONGSUB (x * 2, y, 0), LONGSUB (x, y, 1), LONGSUB (x, x, b))
          check (diff, 11, "F525")
          x, y, b := MOSTPOS INT, 0, 1
          check (LONGSUB (x, y, b), (MOSTPOS INT) - 1, "F526")
          check (LONGSUB (x, y, 0), MOSTPOS INT      , "F527")
          x, y, b := (MOSTNEG INT) + 1, 1, 0
          check (LONGSUB (x, y, b), MOSTNEG INT, "F528")

          -- Check negative values
          check (LONGSUB (1, -1, 0), 2, "F529")
        --}}}  
        --{{{  LONGDIFF                    (F530 - F539)
        INT diff, borrow, x, y, b :
        SEQ
          borrow, diff := LONGDIFF (10, 5, 0)
          check (diff,   5, "F530")
          check (borrow, 0, "F531")
          borrow, diff := LONGDIFF (10, 5, 1)
          check (diff,   4, "F532")
          check (borrow, 0, "F533")
          x, y, b := 10, 5, 0
          borrow, diff := LONGDIFF (x, y, b)
          check (diff,   5, "F534")
          check (borrow, 0, "F535")
          borrow, diff := LONGDIFF (0, 1, 0)
          check (diff,  -1, "F536")
          check (borrow, 1, "F537")
          borrow, diff := LONGDIFF (MOSTNEG INT, MOSTPOS INT, 0)
          check (diff,   1, "F538")
          check (borrow, 0, "F539")

          -- Complex exp and negative
          borrow, diff := LONGDIFF (-1, -1, 0)
          check (diff,   0, "F539a")
          check (borrow, 0, "F539b")
          borrow, diff := LONGDIFF (-1, -1, 0)
          check (diff,   0, "F539c")
          check (borrow, 0, "F539d")
          x, y, b := 42, 15, 0
          borrow, diff := LONGDIFF(LONGSUB(x, y, b),
                                   LONGSUB(x, y, b+1), LONGSUB(x, y, 1))
          check(diff,    1, "F539e")
          check(borrow,  0, "F539f")

        --}}}  
        --{{{  LONGPROD                    (F540 - F549)
        INT hi, lo, x, y, c :
        SEQ
          hi, lo := LONGPROD (150, 3, 5)
          check (hi, 0, "F540")
          check (lo, 455, "F541")
          hi, lo := LONGPROD (MOSTNEG INT, 2, 57)
          check (hi, 1, "F542")
          check (lo, 57, "F543")

          -- Complex parameters
          x, y, c := 1, 2, 3
          hi, lo := LONGPROD (c / (x+y), x+(y+c), (x*y) + c)
          check(hi,  0, "F544")
          check(lo, 11, "F545")

        --}}}  
        --{{{  LONGDIV                     (F550 - F559)
        INT q, r, hi, lo, d :
        SEQ
          q, r := LONGDIV (0, 10, 3)
          check (q, 3, "F550")
          check (r, 1, "F551")
          hi, lo, d := 1, 1, 2
          q, r := LONGDIV (hi, lo, d)
          check (q, MOSTNEG INT, "F552")
          check (r, 1, "F553")
          q, r := LONGDIV (256, 42, 512)
          check (q, MOSTNEG INT, "F554")
          check (r, 42, "F555")

          -- Complex parameters
          hi, lo, d := id(#100), id(42), id(#1000)
          q, r := LONGDIV(hi + (hi >> 16), lo + (lo >> 16), d /\ (d \/ lo))
          check (q, (MOSTNEG INT) >> 3, "F556")
          check (r, lo, "F557")

        --}}}  
        --{{{  SHIFTRIGHT                  (F560 - F569)
        INT hi, lo, hi.in, lo.in, p :
        SEQ
          hi, lo := SHIFTRIGHT (5, 0, 1)
          check (hi, 2, "F560")
          check (lo, MOSTNEG INT, "F561")
          hi.in, lo.in, p := 21, 3, 3
          hi, lo := SHIFTRIGHT (hi.in, lo.in, p)
          check (hi, 2, "F562")
          check (lo, (MOSTNEG INT) \/ ((MOSTNEG INT) >> 2), "F563")
          hi.in, lo.in, p := 0, 127, 8
          hi, lo := SHIFTRIGHT (hi.in, lo.in, p)
          check (hi, 0, "F564")
          check (lo, 0, "F565")
          hi.in, lo.in, p := 3, 3, 1
          hi, lo := SHIFTRIGHT (hi.in, lo.in, p)
          check (hi, 1, "F566")
          check (lo, (MOSTNEG INT) \/ 1, "F567")
          hi.in, lo.in, p := 5643, 5434, 0
          hi, lo := SHIFTRIGHT (hi.in, lo.in, p)
          check (hi, 5643, "F568")
          check (lo, 5434, "F569")

          -- Complex args
          hi.in, lo.in, p := id(-1), id(42), id(4)
          hi, lo := SHIFTRIGHT(hi.in + (p - (lo.in / 10)), (hi.in + lo.in) + (p/4),
                               (hi.in \/ 2) /\ p)
          check(hi, (MOSTPOS INT) >< (7 << (bits.per.word - 4)), "F569a")
          check(lo, (15 << (bits.per.word - 4)) \/ 2, "F569b")


        --}}}  
        --{{{  SHIFTLEFT                   (F570 - F579)
        INT hi, lo, hi.in, lo.in, p :
        SEQ
          hi, lo := SHIFTLEFT (1, (MOSTNEG INT) + 1, 1)
          check (hi, 3, "F570")
          check (lo, 2, "F571")
          hi.in, lo.in, p := 7, (MOSTNEG INT) + 5, 2
          hi, lo := SHIFTLEFT (hi.in, lo.in, p)
          check (hi, 30, "F572")
          check (lo, 20, "F573")
          hi.in, lo.in, p := MOSTNEG INT, MOSTNEG INT, 1
          hi, lo := SHIFTLEFT (hi.in, lo.in, p)
          check (hi, 1, "F574")
          check (lo, 0, "F575")
          hi.in, lo.in, p := 1, 1, 8
          hi, lo := SHIFTLEFT (hi.in, lo.in, p)
          check (hi, 256, "F576")
          check (lo, 256, "F577")
          hi.in, lo.in, p := 5643, 5434, 0
          hi, lo := SHIFTLEFT (hi.in, lo.in, p)
          check (hi, 5643, "F578")
          check (lo, 5434, "F579")

          -- Complex args
          hi.in, lo.in, p := -1, 42, 4
          hi, lo := SHIFTLEFT(hi.in + (p - (lo.in / 10)), (hi.in + lo.in) + (p/4),
                              (hi.in \/ 2) /\ p)
          check(hi, (MOSTPOS INT) << 4, "F579a")
          check(lo, 42 * 16, "F579b")


        --}}}  
        --{{{  NORMALISE                   (F580 - F589)
        INT p, hi, lo, hi.in, lo.in :
        SEQ
          p, hi, lo := NORMALISE (MOSTPOS INT, MOSTNEG INT)
          check (p, 1, "F580")
          check (hi, -1, "F581")
          check (lo, 0, "F582")
          hi.in, lo.in := (MOSTPOS INT) >> 2, 3
          p, hi, lo := NORMALISE (hi.in, lo.in)
          check (p, 3, "F583")
          check (hi, -8, "F584")
          check (lo, 24, "F585")
          hi.in, lo.in := 0, 0
          p, hi, lo := NORMALISE (hi.in, lo.in)
          check (p, bits.per.word * 2, "F586")
          check (hi \/ lo, 0, "F587")     -- check they're both zero
        --}}}  
        --{{{  ASHIFTRIGHT                 (F590 - F599)
        INT n, x, p :
        SEQ
          check (ASHIFTRIGHT (-1, 1), -1, "F590")
          n := ASHIFTRIGHT (-2, 1)
          check (n, -1, "F591")
          x, p := -4, 2
          check (ASHIFTRIGHT (x, p), -1, "F592")
          n := ASHIFTRIGHT (x, p)
          check (n, -1, "F593")
          x, p := -20, 2
          n := ASHIFTRIGHT (x, p)
          check (n, -5, "F594")
          x, p := 10, 3
          check (ASHIFTRIGHT (x, p), 1, "F595")
          x, p := MOSTPOS INT, 1
          check (ASHIFTRIGHT (x, p), (MOSTPOS INT) >> 1, "F596")
          x, p := MOSTNEG INT, 1
          check (ASHIFTRIGHT (x, p), ((MOSTNEG INT) >> 1) \/ (MOSTNEG INT), "F597")
          x, p := 12345, 0
          check (ASHIFTRIGHT (x, p), 12345, "F598")
        --}}}  
        --{{{  ASHIFTLEFT                  (F600 - F609)
        INT n, x, p :
        SEQ
          check (ASHIFTLEFT (-7, 2), -28, "F600")
          check (ASHIFTLEFT ( 7, 2),  28, "F601")
          n := ASHIFTLEFT (256, 3)
          check (n, 2048, "F602")
          x, p := (MOSTPOS INT) >> 1, 1
          check (ASHIFTLEFT (x, p), (MOSTPOS INT) - 1, "F603")
          x, p := (MOSTNEG INT) >> 6, 5
          check (ASHIFTLEFT (x, p), (MOSTNEG INT) >> 1, "F604")
          SEQ i = -15 FOR 30
            IF
              ASHIFTLEFT (i, 2) = (i * 4)
                SKIP
              TRUE
                check (i, 10000, "F605")
          x, p := 12345, 0
          check (ASHIFTLEFT (x, p), 12345, "F606")
        --}}}  
        --{{{  ROTATERIGHT                 (F610 - F619)
        INT n, x, p :
        SEQ
          check (ROTATERIGHT (15, 1), (MOSTNEG INT) \/ 7, "F610")
          x, p := 15, 1
          check (ROTATERIGHT (x, p), (MOSTNEG INT) \/ 7, "F611")
          x, p := 12345, 0
          check (ROTATERIGHT (x, p), 12345, "F612")
          x, p := 1, 2
          check (ROTATERIGHT (x, p), (MOSTNEG INT) >> 1, "F613")
          x, p := (MOSTNEG INT) + 5, 1
          check (ROTATERIGHT (x, p), ((MOSTNEG INT) >> 1) \/ ((MOSTNEG INT) \/ 2),
                 "F614")
          x, p := MOSTNEG INT, bits.per.word
          check (ROTATERIGHT (x, p), MOSTNEG INT, "F615")
          x, p := MOSTPOS INT, bits.per.word - 1
          check (ROTATERIGHT (x, p), -2, "F616")
        --}}}  
        --{{{  ROTATELEFT                  (F620 - F629)
        INT n, x, p :
        SEQ
          check (ROTATELEFT (15, 1), 30, "F620")
          x, p := 15, 1
          check (ROTATELEFT (x, p), 30, "F621")
          x, p := 12345, 0
          check (ROTATELEFT (x, p), 12345, "F622")
          x, p := (MOSTNEG INT) >> 1, 2
          check (ROTATELEFT (x, p), 1, "F623")
          x, p := (MOSTNEG INT) + 5, 1
          check (ROTATELEFT (x, p), 11, "F624")
          x, p := MOSTNEG INT, bits.per.word
          check (ROTATELEFT (x, p), MOSTNEG INT, "F625")
          x, p := -2, bits.per.word - 1
          check (ROTATELEFT (x, p), MOSTPOS INT, "F626")
        --}}}  
        --{{{  nested calls                (F640 - F649)
        INT a, b, c, d, e, f, x :
        SEQ
          a, b, c, d, e, f := 1, 2, 3, 4, 5, 6
          x := LONGADD (LONGADD (a, b, c), LONGADD (d, e, f), LONGADD (a, b, c))
          check (x, 13, "F640")
          x := LONGADD (LONGADD (a, a+a, b+a),
                        LONGADD (d*a, (a*c)+(a+a), f),
                        LONGADD (a, b, (c+a)+e))
          check (x, 13, "F641")
          x := 13
          SEQ i = 0 FOR 10
            x := ASHIFTRIGHT (ASHIFTLEFT (ASHIFTRIGHT (ASHIFTLEFT (x, i), i), i), i)
          check (x, 13, "F642")
          x := 42
          SEQ i = 0 FOR bits.per.word
            x := ROTATELEFT (ROTATERIGHT (ROTATELEFT (ROTATERIGHT (x, i), i), i), i)
          check (x, 42, "F643")
          x := 0
          SEQ i = 0 FOR 10
            x := LONGADD (x, i, i)
          check (x, 50, "F644")
        --}}}  
        --{{{  REAL32OP and REAL64OP       (F650 - F669)
        --{{{  REAL32OP                    (F650 - F659)
        REAL32 x, y :
        INT z :
        SEQ
          -- NOTE - 0=ADD, 1=SUB, 2=MUL, 3=DIV
          x, y := 42.0(REAL32), 13.0(REAL32)
          check (INT TRUNC REAL32OP (13.0(REAL32), 0, 57.0(REAL32)), 70,"F650")
          check (INT TRUNC REAL32OP (x, 0, y), 55, "F651")
          check (INT TRUNC REAL32OP (x, 1, y), 29, "F652")
          check (INT TRUNC REAL32OP (x, 2, y), 546, "F653")
          check (INT TRUNC REAL32OP (x, 3, y), 3, "F654")
          z := INT TRUNC REAL32OP (x, 0, y)
          check (z, 55, "F655")
          z := INT TRUNC REAL32OP (x, 1, y)
          check (z, 29, "F656")
          z := INT TRUNC REAL32OP (x, 2, y)
          check (z, 546, "F657")
          z := INT TRUNC REAL32OP (x, 3, y)
          check (z, 3, "F658")
        --}}}  
        --{{{  REAL64OP                    (F660 - F669)
        REAL64 x, y :
        INT z :
        SEQ
          -- NOTE - 0=ADD, 1=SUB, 2=MUL, 3=DIV
          x, y := 42.0(REAL64), 13.0(REAL64)
          check (INT TRUNC REAL64OP (13.0(REAL64), 0, 57.0(REAL64)), 70,"F660")
          check (INT TRUNC REAL64OP (x, 0, y), 55, "F661")
          check (INT TRUNC REAL64OP (x, 1, y), 29, "F662")
          check (INT TRUNC REAL64OP (x, 2, y), 546, "F663")
          check (INT TRUNC REAL64OP (x, 3, y), 3, "F664")
          z := INT TRUNC REAL64OP (x, 0, y)
          check (z, 55, "F665")
          z := INT TRUNC REAL64OP (x, 1, y)
          check (z, 29, "F666")
          z := INT TRUNC REAL64OP (x, 2, y)
          check (z, 546, "F667")
          z := INT TRUNC REAL64OP (x, 3, y)
          check (z, 3, "F668")
        --}}}  
        --}}}  
        --{{{  ASSERT                      (F700 - F799)
        PROC test.ASSERTions()
          SEQ
            --{{{  test.ASSERT       (F700 - F719)
            PROC test.ASSERT(VAL BOOL true, false, true1, true2, false1, false2)
              SEQ
                ASSERT(true)
                check.BOOL(true, TRUE, "F700")
                ASSERT(NOT false)
                check.BOOL(false, FALSE, "F701")
                ASSERT(true AND true1)
                check.BOOL(true, TRUE, "F702")
                ASSERT(true AND true1 AND true2)
                check.BOOL(true, TRUE, "F703")
                ASSERT(false OR true)
                check.BOOL(true, TRUE, "F704")
                ASSERT(true OR false)
                check.BOOL(true, TRUE, "F705")
                ASSERT(true OR false OR false1 OR false2)
                check.BOOL(true, TRUE, "F706")
                ASSERT(false OR false1 OR false2 OR true)
                check.BOOL(true, TRUE, "F707")
                ASSERT(NOT (NOT true))
                check.BOOL((true OR false), TRUE, "F708")
                ASSERT(NOT (NOT (NOT false)))
                check.BOOL((true OR false), TRUE, "F709")
                ASSERT(true AND (NOT false))
                check.BOOL(true, TRUE, "F710")
                ASSERT((NOT false) AND true)
                check.BOOL((NOT false), TRUE, "F711")
            :
            test.ASSERT(TRUE, FALSE, TRUE, TRUE, FALSE, FALSE)

            --}}}  
            --{{{  test.IF.STOP      (F720 - F739)
            PROC test.IF.STOP (VAL BOOL true, false, true1, true2, false1, false2)
              SEQ
                IF
                  NOT true
                    STOP
                  TRUE
                    SKIP
                check.BOOL(true, TRUE, "F720")
                IF
                  false
                    STOP
                  TRUE
                    SKIP
                check.BOOL(false, FALSE, "F721")
                IF
                  NOT (true AND true1)
                    STOP
                  TRUE
                    SKIP
                check.BOOL(true, TRUE, "F722")
                IF
                  NOT (true AND true1 AND true2)
                    STOP
                  TRUE
                    SKIP
                check.BOOL(true, TRUE, "F723")
                IF
                  NOT (false OR true)
                    STOP
                  TRUE
                    SKIP
                check.BOOL(true, TRUE, "F724")
                IF
                  NOT (true OR false)
                    STOP
                  TRUE
                    SKIP
                check.BOOL(true, TRUE, "F725")
                IF
                  NOT (true OR false OR false1 OR false2)
                    STOP
                  TRUE
                    SKIP
                check.BOOL(true, TRUE, "F726")
                IF
                  NOT (false OR false1 OR false2 OR true)
                    STOP
                  TRUE
                    SKIP
                check.BOOL(true, TRUE, "F727")
                IF
                  NOT (NOT (NOT true))
                    STOP
                  TRUE
                    SKIP
                check.BOOL((true OR false), TRUE, "F728")
                IF
                  (NOT (NOT false))
                    STOP
                  TRUE
                    SKIP
                check.BOOL((true OR false), TRUE, "F729")
                IF
                  NOT (true AND (NOT false))
                    STOP
                  TRUE
                    SKIP
                check.BOOL(true, TRUE, "F730")
                IF
                  NOT ((NOT false) AND true)
                    STOP
                  TRUE
                    SKIP
                check.BOOL((NOT false), TRUE, "F731")
            :
            test.IF.STOP(TRUE, FALSE, TRUE, TRUE, FALSE, FALSE)

            --}}}  
            --{{{  test.IF.SKIP      (F740 - F759)
            PROC test.IF.SKIP(VAL BOOL true, false, true1, true2, false1, false2)
              SEQ
                IF
                  (true)
                    SKIP
                  TRUE
                    STOP
                check.BOOL(true, TRUE, "F740")
                IF
                  (NOT false)
                    SKIP
                  TRUE
                    STOP
                check.BOOL(false, FALSE, "F741")
                IF
                  (true AND true1)
                    SKIP
                  TRUE
                    STOP
                check.BOOL(true, TRUE, "F742")
                IF
                  (true AND true1 AND true2)
                    SKIP
                  TRUE
                    STOP
                check.BOOL(true, TRUE, "F743")
                IF
                  (false OR true)
                    SKIP
                  TRUE
                    STOP
                check.BOOL(true, TRUE, "F744")
                IF
                  (true OR false)
                    SKIP
                  TRUE
                    STOP
                check.BOOL(true, TRUE, "F745")
                IF
                  (true OR false OR false1 OR false2)
                    SKIP
                  TRUE
                    STOP
                check.BOOL(true, TRUE, "F746")
                IF
                  (false OR false1 OR false2 OR true)
                    SKIP
                  TRUE
                    STOP
                check.BOOL(true, TRUE, "F747")
                IF
                  (NOT (NOT true))
                    SKIP
                  TRUE
                    STOP
                check.BOOL((true OR false), TRUE, "F748")
                IF
                  (NOT (NOT (NOT false)))
                    SKIP
                  TRUE
                    STOP
                check.BOOL((true OR false), TRUE, "F749")
                IF
                  (true AND (NOT false))
                    SKIP
                  TRUE
                    STOP
                check.BOOL(true, TRUE, "F750")
                IF
                  ((NOT false) AND true)
                    SKIP
                  TRUE
                    STOP
                check.BOOL((NOT false), TRUE, "F751")
            :
            test.IF.SKIP(TRUE, FALSE, TRUE, TRUE, FALSE, FALSE)

            --}}}  
            --{{{  test.local.ASSERT (F760 - F779)
            PROC test.local.ASSERT(VAL BOOL true, false, true1, true2, false1, false2)
              PROC ASSERT(VAL BOOL test)
                check.BOOL(test, TRUE, "F779")
              :
              SEQ
                ASSERT(true)
                check.BOOL(true, TRUE, "F760")
                ASSERT(NOT false)
                check.BOOL(false, FALSE, "F761")
                ASSERT(true AND true1)
                check.BOOL(true, TRUE, "F762")
                ASSERT(true AND true1 AND true2)
                check.BOOL(true, TRUE, "F763")
                ASSERT(false OR true)
                check.BOOL(true, TRUE, "F764")
                ASSERT(true OR false)
                check.BOOL(true, TRUE, "F765")
                ASSERT(true OR false OR false1 OR false2)
                check.BOOL(true, TRUE, "F766")
                ASSERT(false OR false1 OR false2 OR true)
                check.BOOL(true, TRUE, "F767")
                ASSERT(NOT (NOT true))
                check.BOOL((true OR false), TRUE, "F768")
                ASSERT(NOT (NOT (NOT false)))
                check.BOOL((true OR false), TRUE, "F769")
                ASSERT(true AND (NOT false))
                check.BOOL(true, TRUE, "F770")
                ASSERT((NOT false) AND true)
                check.BOOL((NOT false), TRUE, "F771")
            :
            test.local.ASSERT(TRUE, FALSE, TRUE, TRUE, FALSE, FALSE)

            --}}}  
        :
        test.ASSERTions()
        --}}}  
    :
    predefines()
    --}}}  
    --{{{  floating point 32
    PROC floating.point32()
      REAL32 i32, j32, r32 :
      INT i :
      BOOL b :
      INT32 int32 :
      SEQ
        i32 := 1.1(REAL32)
        j32 := -1.1(REAL32)
        check.REAL32(ABS(i32), 1.1(REAL32), "F1001")
        check.REAL32(ABS(j32), 1.1(REAL32), "F1002")
        check.REAL32(SQRT(i32), 1.048808848(REAL32), "F1003")
        check.BOOL(ISNAN(i32), FALSE, "F1004")
        check.BOOL(NOTFINITE(i32), FALSE, "F1005")
        check.REAL32(SCALEB(i32, 2),  4.4(REAL32), "F1006")
        check.REAL32(SCALEB(j32, 2), -4.4(REAL32), "F1007")
        check.REAL32(LOGB(i32), 0.0(REAL32), "F1008")
        i, r32 := FLOATING.UNPACK(i32)
        check(i, 0, "F1009")
        check.REAL32(r32, 1.1(REAL32), "F1010")
        check.REAL32(MINUSX(i32), -1.1(REAL32), "F1011")
        check.REAL32(MINUSX(j32),  1.1(REAL32), "F1012")
        check.REAL32(MINUSX( 1.1(REAL32)), -1.1(REAL32), "F1011a")
        check.REAL32(MINUSX(-1.1(REAL32)),  1.1(REAL32), "F1012a")
        check.REAL32(COPYSIGN(i32, j32), -1.1(REAL32), "F1013")
        check.REAL32(COPYSIGN(j32, i32),  1.1(REAL32), "F1014")
        VAL REAL32 ans RETYPES #3F8CCCCC(INT32) :
        check.REAL32(NEXTAFTER(i32, j32), ans, "F1015")
        VAL REAL32 ans RETYPES #BF8CCCCC(INT32) :
        check.REAL32(NEXTAFTER(j32, i32), ans, "F1016")
        check.BOOL(ORDERED(i32, j32), TRUE, "F1017")
        b, int32, r32 := ARGUMENT.REDUCE(i32, 3.1415927(REAL32), 1.0E-8(REAL32))
        check.BOOL(b, TRUE, "F1018")
        check.INT32(int32, 0(INT32), "F1019")
        check.REAL32(r32, 1.1(REAL32), "F1020")
        check.REAL32(MULBY2(i32), 2.2(REAL32), "F1021")
        check.REAL32(DIVBY2(i32), 0.55(REAL32), "F1022")
        check.REAL32(FPINT(i32), 1.0(REAL32), "F1023")

        -- REAL32OP is checked above
        b, r32 := IEEE32OP(i32, 0, 0, j32)
        check.BOOL(b, FALSE, "F1050")
        check.REAL32(r32, 0.0(REAL32), "F1051")
        check.REAL32(REAL32REM(i32, j32), 0.0(REAL32), "F1052")
        b, r32 := IEEE32REM(i32, j32)
        check.BOOL(b, FALSE, "F1053")
        check.REAL32(r32, 0.0(REAL32), "F1054")
        check.BOOL(REAL32EQ(i32, j32), FALSE, "F1055")
        check.BOOL(REAL32GT(i32, j32), TRUE, "F1056")
        check(IEEECOMPARE(i32, j32), 1, "F1057")
    :
    floating.point32()
    --}}}  
    --{{{  floating point 64
    PROC floating.point64()
      REAL64 i64, j64, r64 :
      INT i :
      BOOL b :
      INT32 int32 :
      SEQ
        i64 := 1.1(REAL64)
        j64 := -1.1(REAL64)
        check.REAL64(DABS(i64), 1.1(REAL64), "F1101")
        check.REAL64(DABS(j64), 1.1(REAL64), "F1102")
        VAL REAL64 ans RETYPES #3FF0C7EBC96A56F6(INT64) :
        check.REAL64(DSQRT(i64), ans, "F1103")
        check.BOOL(DISNAN(i64), FALSE, "F1104")
        check.BOOL(DNOTFINITE(i64), FALSE, "F1105")
        check.REAL64(DSCALEB(i64, 2),  4.4(REAL64), "F1106")
        check.REAL64(DSCALEB(j64, 2), -4.4(REAL64), "F1107")
        check.REAL64(DLOGB(i64), 0.0(REAL64), "F1108")
        i, r64 := DFLOATING.UNPACK(i64)
        check(i, 0, "F1109")
        check.REAL64(r64, 1.1(REAL64), "F1110")
        check.REAL64(DMINUSX(i64), -1.1(REAL64), "F1111")
        check.REAL64(DMINUSX(j64),  1.1(REAL64), "F1112")
        check.REAL64(DMINUSX( 1.1(REAL64)), -1.1(REAL64), "F1111a")
        check.REAL64(DMINUSX(-1.1(REAL64)),  1.1(REAL64), "F1112a")
        check.REAL64(DCOPYSIGN(i64, j64), -1.1(REAL64), "F1113")
        check.REAL64(DCOPYSIGN(j64, i64),  1.1(REAL64), "F1114")
        VAL REAL64 ans RETYPES #3FF1999999999999(INT64) :
        check.REAL64(DNEXTAFTER(i64, j64), ans, "F1115")
        VAL REAL64 ans RETYPES #BFF1999999999999(INT64) :
        check.REAL64(DNEXTAFTER(j64, i64), ans, "F1116")
        check.BOOL(DORDERED(i64, j64), TRUE, "F1117")
        b, int32, r64 := DARGUMENT.REDUCE(i64, 3.1415927(REAL64), 1.0E-8(REAL64))
        check.BOOL(b, TRUE, "F1118")
        check.INT32(int32, 0(INT32), "F1119")
        check.REAL64(r64, 1.1(REAL64), "F1120")
        check.REAL64(DMULBY2(i64), 2.2(REAL64), "F1121")
        check.REAL64(DDIVBY2(i64), 0.55(REAL64), "F1122")
        check.REAL64(DFPINT(i64), 1.0(REAL64), "F1123")

        -- REAL64OP is checked above
        b, r64 := IEEE64OP(i64, 0, 0, j64)
        check.BOOL(b, FALSE, "F1050")
        check.REAL64(r64, 0.0(REAL64), "F1051")
        check.REAL64(REAL64REM(i64, j64), 0.0(REAL64), "F1052")
        b, r64 := IEEE64REM(i64, j64)
        check.BOOL(b, FALSE, "F1053")
        check.REAL64(r64, 0.0(REAL64), "F1054")
        check.BOOL(REAL64EQ(i64, j64), FALSE, "F1055")
        check.BOOL(REAL64GT(i64, j64), TRUE, "F1056")
        check(DIEEECOMPARE(i64, j64), 1, "F1057")
    :
    floating.point64()
    --}}}  
    --{{{  PROC f ()    - check fmul
    PROC f ()
      --{{{  PROC fmul
      PROC fmul (INT a, VAL INT b, c)
        INT rlo, rhi :
        SEQ
          rhi,  rlo := LONGPROD ( b,  c,  0)
          IF
            b < 0
              rhi := rhi MINUS c
            TRUE
              SKIP
          IF
            c < 0
              rhi := rhi MINUS b
            TRUE
              SKIP
          rhi,  rlo := SHIFTLEFT ( rhi,  rlo,  1)
          IF
            rlo >= 0
              a := rhi
            --rlo <> #80000000
            rlo <> (MOSTNEG INT)
              a := rhi PLUS 1
            (rhi /\ 1) = 1
              a := rhi PLUS 1
            TRUE
              a := rhi
      :
      --}}}  
      --{{{  PROC check.fmul
      PROC check.fmul (VAL INT x, y, VAL []BYTE where)
        INT v1, v2 :
        SEQ
          #IF NOT DEFINED (COMPILER.TOCK)
          fmul (v1, x, y)
          v2 := FRACMUL (x, y)
          check (v2, v1, where)
          #ENDIF
      :
      --}}}  
      SEQ
        check.fmul (0, 0, "F01")
        check.fmul (1, 1, "F02")
        check.fmul (-1, 1, "F03")
        check.fmul (1, -1, "F04")
        check.fmul (-1, -1, "F05")
        -- These all overflow on a T212:
        -- Commented in again (DCW)
        check.fmul (65536, 65536, "F06")
        check.fmul (-65536, 65536, "F07")
        check.fmul (65536, -65536, "F08")
        check.fmul (-65536, -65536, "F09")
        check.fmul (#12345678, #12345678, "F10")
        check.fmul (#12345678, #87654321, "F11")
        check.fmul (#87654321, #87654321, "F12")
        check.fmul (#87654321, #12345678, "F13")
    :
    f ()
    --}}}  
    --{{{  bugs
    PROC bugs()
      SEQ
        --{{{  bug 186
        -- test for bug 186 in buglist
        VAL bpw IS ((INT ((MOSTNEG INT) =  #8000)) * 2) +
                   ((INT ((MOSTNEG INT) <> #8000)) * 4) :
        SEQ
          #IF NOT DEFINED (COMPILER.TOCK)
          check (BITREVNBITS(#1234, 16), #2C48, "B186a")
          VAL x IS MOSTPOS INT :
          check (BITREVNBITS(BITREVNBITS(x, bpw * 8), bpw * 8), x, "B186b")
          VAL x IS MOSTNEG INT :
          check (BITREVNBITS(BITREVNBITS(x, bpw * 8), bpw * 8), x, "B186c")
          VAL x IS 27 :
          check (BITREVNBITS(BITREVNBITS(x, bpw * 8), bpw * 8), x, "B186d")
          VAL x IS -1 :
          check (BITREVNBITS(BITREVNBITS(x, 8), 8), x /\ #FF, "B186e")
          VAL x IS -1 :
          check (BITREVNBITS(BITREVNBITS(x, 16), 16), x /\ #FFFF, "B186f")
          #ENDIF
        --}}}  
        --{{{  bug 129
        -- test for bug 129 in buglist
        REAL32 r :
        REAL64 d :
        SEQ
          r, d := 1234.0(REAL32), 4321.0(REAL64)
          r := MINUSX(r)
          d := DMINUSX(d)
          check (INT ROUND r, -1234, "B129a")
          check (INT ROUND d, -4321, "B129b")
        --}}}  
        --{{{  bug 249
        -- test for bug 249 in buglist
        BOOL b :
        SEQ
          b := ORDERED(27.0(REAL32), 27.0(REAL32))
          check (INT b, INT TRUE, "B249a")
          b := DORDERED(42.6(REAL64), 42.6(REAL64))
          check (INT b, INT TRUE, "B249b")
        --}}}  
        --{{{  bug 274
        -- test for bug 274 in buglist
        REAL32 x32, y32, z32 :
        REAL64 x64, y64, z64 :
        BOOL b :
        SEQ
          x32, y32 := 10.0(REAL32), 6.0(REAL32)
          x64, y64 := 10.0(REAL64), 6.0(REAL64)
          b, z32 := IEEE32REM(x32, y32)
          b, z64 := IEEE64REM(x64, y64)
          check(INT ROUND z32, -2, "B274a")
          check(INT ROUND z64, -2, "B274b")
        --}}}  
    :
    bugs()
    --}}}  
    --{{{  UNPACKSN and ROUNDSN
    PROC SNstuff()
      -- Here the 32 bit constants are masked by an integer at run time. This
      -- prevents the compiler doing the conversion at compile time and complaining
      -- that they won't fit into an INT(16).
      INT frac, exp, type :
      VAL INT32 Nan IS #7FC00000(INT32) :
      VAL INT32 Inf IS #7F800000(INT32) :
      INT32 mask :
      INT a.int :
      IF
        bits.per.word = 32
          SEQ
            #IF NOT DEFINED (COMPILER.TOCK)
            mask := 0(INT32)
            frac, exp, type := UNPACKSN(0)
            check(type, 0, "SN0")
            frac, exp, type := UNPACKSN(5)
            check(5 << 8, frac, "TEST") -- Need to shift as result biased
            check(1,  exp, "TEST")
            check(type, 1, "SN1")
            frac, exp, type := UNPACKSN(INT (Inf \/ mask))
            check(type, 2, "SN2")
            frac, exp, type := UNPACKSN(INT (Nan \/ mask))
            check(type, 3, "SN3")

            -- Sample values given in the Inmos documentation
            frac, exp, type := UNPACKSN (#40490FDB)
            check (frac, #C90FDB00, "SNI0frac")
            check (exp, #00000080, "SNI0exp")
            check (type, 1, "SNI0exp")
            frac, exp, type := UNPACKSN (#00000001)
            check (frac, #00000100, "SNI1frac")
            check (exp, #00000001, "SNI1exp")
            check (type, 1, "SNI1exp")
            frac, exp, type := UNPACKSN (#7FC00001)
            check (frac, #40000100, "SNI2frac")
            check (exp, #000000FF, "SNI2exp")
            check (type, 3, "SNI2exp")

            -- Sample values given in the Inmos documentation
            a.int := ROUNDSN (#00000080, #C90FDB00, #00000000)
            check (a.int, #40490FDB, "SNI3")
            a.int := ROUNDSN (#00000080, #C90FDB80, #00000000)
            check (a.int, #40490FDC, "SNI4")
            a.int := ROUNDSN (#00000080, #C90FDA80, #00000000)
            check (a.int, #40490FDA, "SNI5")
            a.int := ROUNDSN (#00000080, #C90FDA80, #00003000)
            check (a.int, #40490FDB, "SNI6")
            a.int := ROUNDSN (#00000001, #00000100, #00000000)
            check (a.int, #00000001, "SNI7")
            #ENDIF
        TRUE
          SKIP
    :
    SNstuff()
    --}}}  
    --{{{  RESCHEDULE
    -- This should do nothing!
    PROC reschedule()
      SEQ
        RESCHEDULE()
    :
    reschedule()
    --}}}
    #IF FALSE
    --{{{  LOAD.xxx
    PROC load.xxx()
      [5]BYTE string:
      PROTOCOL any IS ANY:
      CHAN OF any chan :
      [2]CHAN OF any chan.vector :
      CHAN OF any chan.any :
      [2]CHAN OF any chan.any.vector :
      CHAN OF INT chan.int :
      [2]CHAN OF INT chan.int.vector :
      INT address, check.address :
      SEQ
        LOAD.BYTE.VECTOR(address, string)
        ASM
          LD ADDRESSOF string
          ST check.address
        check(address, check.address, "L0")

        -- This relies on the implementation of channels as pointers to the
        -- channel word itself.
        LOAD.INPUT.CHANNEL(address, chan)
        ASM
          LD chan
          ST check.address
        check(address, check.address, "L1")
        LOAD.OUTPUT.CHANNEL(address, chan)
        check(address, check.address, "L2")

        LOAD.INPUT.CHANNEL.VECTOR(address, chan.vector)
        ASM
          LD ADDRESSOF chan.vector
          ST check.address
        check(address, check.address, "L3")
        LOAD.OUTPUT.CHANNEL.VECTOR(address, chan.vector)
        check(address, check.address, "L4")

        -- This relies on the implementation of channels as pointers to the
        -- channel word itself.
        LOAD.INPUT.CHANNEL(address, chan.any)
        ASM
          LD chan.any
          ST check.address
        check(address, check.address, "L11")
        LOAD.OUTPUT.CHANNEL(address, chan.any)
        check(address, check.address, "L12")

        LOAD.INPUT.CHANNEL.VECTOR(address, chan.any.vector)
        ASM
          LD ADDRESSOF chan.any.vector
          ST check.address
        check(address, check.address, "L13")
        LOAD.OUTPUT.CHANNEL.VECTOR(address, chan.any.vector)
        check(address, check.address, "L14")

        -- This relies on the implementation of channels as pointers to the
        -- channel word itself.
        LOAD.INPUT.CHANNEL(address, chan.int)
        ASM
          LD chan.int
          ST check.address
        check(address, check.address, "L21")
        LOAD.OUTPUT.CHANNEL(address, chan.int)
        check(address, check.address, "L22")

        LOAD.INPUT.CHANNEL.VECTOR(address, chan.int.vector)
        ASM
          LD ADDRESSOF chan.int.vector
          ST check.address
        check(address, check.address, "L23")

        LOAD.OUTPUT.CHANNEL.VECTOR(address, chan.int.vector)
        check(address, check.address, "L24")
    :
    load.xxx()
    --}}}  
    #ENDIF
    --{{{  CRC stuff
    PROC CRCtest()
      INT dataIn, dataOut :
      INT FUNCTION test(VAL INT data, CRCIn, generator, length)
        INT MyData, CRCOut, OldCRC :
        VALOF
          SEQ
            MyData, CRCOut := data, CRCIn
            SEQ i = 0 FOR length
              SEQ
                OldCRC := CRCOut
                CRCOut, MyData := SHIFTLEFT (CRCOut, MyData, 1)
                IF
                  OldCRC < 0 -- MSB of CRC = 1
                    CRCOut := CRCOut >< generator
                  TRUE
                    SKIP
          RESULT CRCOut
      :
      SEQ
        #IF NOT DEFINED (COMPILER.TOCK)
        check(CRCWORD(1234, 0, 654),    test(1234, 0, 654, bits.per.word), "CRC0")
        check(CRCWORD(1234, 0,  54),    test(1234, 0,  54, bits.per.word), "CRC1")
        check(CRCWORD(1234, 4321, 654), test(1234, 4321, 654, bits.per.word), "CRC2")

        dataIn := 56 << (bits.per.word - 8)
        check(CRCBYTE(dataIn, 0, 654),  test(dataIn, 0, 654, 8), "CRC3")
        check(CRCBYTE(dataIn, 0,  54),  test(dataIn, 0,  54, 8), "CRC4")
        check(CRCBYTE(dataIn, 4321, 654),  test(dataIn, 4321, 654, 8), "CRC5")
        #ENDIF
    :
    CRCtest()
    --}}}  
    --{{{  Bit manipulation
    PROC bitManipulation()
      SEQ
        #IF NOT DEFINED (COMPILER.TOCK)
        check(BITCOUNT(0,0), 0, "BM0")
        check(BITCOUNT(1,0), 1, "BM1")
        check(BITCOUNT(#100, 0), 1, "BM2")
        check(BITCOUNT(MOSTNEG INT, 0), 1, "BM3")
        check(BITCOUNT(0,42), 42, "BM4")
        check(BITCOUNT(#555, 4), 10, "BM5")
        check(BITCOUNT(MOSTNEG INT, 42), 43, "BM6")

        check(BITREVWORD(1), MOSTNEG INT, "BM7")
        check(BITREVWORD((MOSTNEG INT) \/ 1), (MOSTNEG INT) \/ 1, "BM8")
        check(BITREVWORD(1234), 19232 << (bits.per.word - 16), "BM9")

        check(BITREVNBITS(1, 0), 0, "BM10")
        check(BITREVNBITS(1, 1), 1, "BM11")
        check(BITREVNBITS(1, 4), 8, "BM12")
        check(BITREVNBITS(1, bits.per.word), MOSTNEG INT, "BM13")
        check(BITREVNBITS(#555, 8), #AA, "BM14")
        #ENDIF
    :
    bitManipulation()
    --}}}  
    --{{{  ROTATES
    PROC bug.INSdi02249()
      INT x, y, n, zero :
      SEQ
        zero := id(0)

        --{{{  ROTATERIGHT
        VAL start  IS 10 :
        VAL places IS  1 :
        VAL finish IS (start >> places) \/ (start << (bits.per.word - places)) :
        SEQ
          x := id(start)
          n := id(places)
          y := ROTATERIGHT(start, n)
          check(y, 5, "di02249aa")
          y := ROTATERIGHT(x, n)
          check(y, 5, "di02249ab")
          y := ROTATERIGHT(x+x, n)
          check(y, start, "di02249ac")
          y := ROTATERIGHT(x, 2)
          check(y, 2 + (MOSTNEG INT), "di02249ad")
          y := ROTATERIGHT(x, n+n)
          check(y, 2 + (MOSTNEG INT), "di02249ae")
          y := ROTATERIGHT(x+x, 2)
          check(y, 5, "di02249af")
          y := ROTATERIGHT(x+x, n+n)
          check(y, 5, "di02249ag")
          y := ROTATERIGHT(id(x+x), id(n+n))
          check(y, 5, "di02249ah")
        --}}}  

        --{{{  ROTATERIGHT
        VAL start  IS ((MOSTPOS INT) - #FF) + #AA :  -- #7FFF...AA
        VAL places IS 8 :
        VAL finish IS (start >> places) \/ (start << (bits.per.word - places)) :
        SEQ
          x := id(start)
          n := id(places)
          y := ROTATERIGHT(start, n)
          check(y, finish, "di02249ba")
          y := ROTATERIGHT(x, n)
          check(y, finish, "di02249bb")
          y := ROTATERIGHT(x + zero, n)
          check(y, finish, "di02249bc")
          y := ROTATERIGHT(x, places)
          check(y, finish, "di02249bd")
          y := ROTATERIGHT(x, n+zero)
          check(y, finish, "di02249be")
          y := ROTATERIGHT(x+zero, places)
          check(y, finish, "di02249bf")
          y := ROTATERIGHT(x+zero, n+zero)
          check(y, finish, "di02249bg")
          y := ROTATERIGHT(id(x+zero), id(n+zero))
          check(y, finish, "di02249bh")
        --}}}  

        --{{{  ROTATELEFT
        VAL start  IS 10 :
        VAL places IS 3 :
        VAL finish IS (start << places) \/ (start >> (bits.per.word - places)) :
        SEQ
          x := id(start)
          n := id(places)
          y := ROTATELEFT(start, n)
          check(y, finish, "di02249ca")
          y := ROTATELEFT(x, n)
          check(y, finish, "di02249cb")
          y := ROTATELEFT(x + zero, n)
          check(y, finish, "di02249cc")
          y := ROTATELEFT(x, places)
          check(y, finish, "di02249cd")
          y := ROTATELEFT(x, n+zero)
          check(y, finish, "di02249ce")
          y := ROTATELEFT(x+zero, places)
          check(y, finish, "di02249cf")
          y := ROTATELEFT(x+zero, n+zero)
          check(y, finish, "di02249cg")
          y := ROTATELEFT(id(x+zero), id(n+zero))
          check(y, finish, "di02249ch")
        --}}}  

        --{{{  ROTATELEFT
        VAL start  IS ((MOSTPOS INT) - #FF) + #AA :  -- #7FFF...AA
        VAL places IS 8 :
        VAL finish IS (start << places) \/ (start >> (bits.per.word - places)) :
        SEQ
          x := id(start)
          n := id(places)
          y := ROTATELEFT(start, n)
          check(y, finish, "di02249da")
          y := ROTATELEFT(x, n)
          check(y, finish, "di02249db")
          y := ROTATELEFT(x + zero, n)
          check(y, finish, "di02249dc")
          y := ROTATELEFT(x, places)
          check(y, finish, "di02249dd")
          y := ROTATELEFT(x, n+zero)
          check(y, finish, "di02249de")
          y := ROTATELEFT(x+zero, places)
          check(y, finish, "di02249df")
          y := ROTATELEFT(x+zero, n+zero)
          check(y, finish, "di02249dg")
          y := ROTATELEFT(id(x+zero), id(n+zero))
          check(y, finish, "di02249dh")
        --}}}  

    :
    bug.INSdi02249()
    --}}}  
    --{{{  Bug 297
    PROC bug.297()
      [2][5][7]BYTE patterns, screens :
      PROC init.stuff ()
        SEQ i = 0 FOR SIZE screens
          SEQ j = 0 FOR SIZE screens [0]
            SEQ k = 0 FOR SIZE screens [0][0]
              SEQ
                screens [i][j][k] := BYTE 99
                patterns[i][j][k] := BYTE (i + (j + k))
      :
      PROC check.stuff (VAL BOOL clipping, VAL []BYTE str)
        SEQ
          -- first check that the move was done OK
          IF
            IF j = 0 FOR SIZE screens[1]
              IF k = 0 FOR SIZE screens [1][0]
                IF
                  clipping AND (screens[1][j][k] <> (BYTE 99))
                    check (INT screens [1][j][k], 99, str)
                  (NOT clipping) AND (screens[0][j][k] <> (BYTE (1 + (j + k))))
                    check (INT screens [1][j][k], 1 + (j + k), str)
            TRUE
              check(1, 1, str)
          -- now check that it didn't move anything it shouldn't have
          IF
            IF j = 0 FOR SIZE screens[0]
              IF k = 0 FOR SIZE screens [0][0]
                IF
                  screens[0][j][k] <> (BYTE 99)
                    check (INT screens [0][j][k], 99, str)
                  IF i = 0 FOR SIZE patterns
                    patterns[i][j][k] <> (BYTE (i + (j + k)))
                      check(INT patterns[i][j][k], i + (j + k), str)
            TRUE
              check(3, 3, str)
      :
      INT sx, sy, dx, dy, l, w, zero, one :
      SEQ
        sx, sy, dx, dy, l, w, zero, one := 0, 0, 0, 0, 5, 7, 0, 1
        -- init.stuff ()
        -- MOVE2D (patterns[one], sx, sy, screens[one], dx, dy, w, l)
        -- check.stuff (FALSE, "B297a")
        -- MOVE2D (patterns[zero], sx, sy, screens[one], dx, dy, zero, zero) -- nothing moved
        -- check.stuff (FALSE, "B300a")
        -- init.stuff ()
        -- MOVE2D (patterns[1], 0, 0, screens[1], 0, 0, 7, 5)
        -- check.stuff (FALSE, "B297b")
        -- MOVE2D (patterns[0], 0, 0, screens[1], 0, 0, 0, 0) -- nothing moved
        -- check.stuff (FALSE, "B300b")
        -- init.stuff ()
        -- DRAW2D (patterns[one], sx, sy, screens[one], dx, dy, w, l)
        -- check.stuff (FALSE, "B297c") -- none of the source was zero, so all is moved
        -- DRAW2D (patterns[zero], sx, sy, screens[one], dx, dy, zero, zero) -- nothing moved
        -- check.stuff (FALSE, "B300c")
        -- init.stuff ()
        -- DRAW2D (patterns[1], 0, 0, screens[1], 0, 0, 7, 5)
        -- check.stuff (FALSE, "B297d") -- none of the source was zero, so all is moved
        -- DRAW2D (patterns[0], 0, 0, screens[1], 0, 0, 0, 0) -- nothing moved
        -- check.stuff (FALSE, "B300d")
        -- init.stuff ()
        -- CLIP2D (patterns[one], sx, sy, screens[one], dx, dy, w, l)
        -- check.stuff (TRUE, "B297e") -- none of the source was zero, so none is moved
        -- CLIP2D (patterns[zero], sx, sy, screens[one], dx, dy, zero, zero) -- nothing moved
        -- check.stuff (TRUE, "B300e")
        -- init.stuff ()
        -- CLIP2D (patterns[1], 0, 0, screens[1], 0, 0, 7, 5)
        -- check.stuff (TRUE, "B297f") -- none of the source was zero, so none is moved
        -- CLIP2D (patterns[0], 0, 0, screens[1], 0, 0, 0, 0) -- nothing moved
        -- check.stuff (TRUE, "B300f")
    :
    bug.297()
    --}}}  
    #IF FALSE
    --{{{  Bug 581
    PROC bug.581()
      -- Transputer code
      VAL transputer.code IS "*#72*#71*#E0*#22*#F0" :
      -- replaced by appropriate code:
      -- SPARC code (DCW):
      VAL []BYTE sparc.code IS [#08, #E0, #04, #E0,     -- ld   [%l3+8],%l0
                                #04, #E0, #04, #E2,     -- ld   [%l3+4],%l1
                                #00, #40, #24, #E0,     -- st   %l0,[%l1]
                                #00, #C0, #04, #DE,     -- ld   [%l3],%o7
                                #08, #E0, #C3, #81,     -- retl
                                #10, #E0, #04, #A6] :   -- inc  16,%l3
      -- ALPHA code (MDP):
      VAL  alpha.code0 IS
               [#B34D0000,       -- stl ra,0(s4)
                #A02D0008,       -- ldl t0,8(s4)
                #A04D0004,       -- ldl t1,4(s4)
                #B0220000,       -- stl t0,0(t1)
                #A34D0000,       -- ldl ra,0(s4)
                #41A2100D,       -- addl s4,0x10,s4
                #6BFA0000]:      -- jmp zero,(ra),0
      VAL []BYTE alpha.code RETYPES alpha.code0:
      -- i386 code (frmb2):
      VAL []BYTE i386.code IS [#8B, #45, #08,		-- movl 8(%ebp), %eax
                               #8B, #5D, #04,		-- movl 4(%ebp), %ebx
                               #89, #43, #00,		-- movl %eax, 0(%ebx)
                               #83, #C5, #10,		-- addl $16, %ebp
                               #FF, #65, #F0,		-- jmp *-16(%ebp)
                               #90]:			-- nop
      -- This is equivalent to:
      -- PROC p (INT x, VAL INT y)
      --   x := y
      -- :
      [100]BYTE code :
      INT code.len :
      [100]BYTE code.buffer :
      INT entry.point :
      [100]BYTE b.workspace :
      INT ws.size :
      INT x, y :
      BOOL fail:
      SEQ
        y := 99

        entry.point := 0

        fail := FALSE
        IF
          HOST.CPU = HOST.CPU.SPARC
            SEQ
              code.len := SIZE sparc.code
              [code FROM 0 FOR code.len] := sparc.code
          HOST.CPU = HOST.CPU.ALPHA
            SEQ
              code.len := SIZE alpha.code
              [code FROM 0 FOR code.len] := alpha.code
          HOST.CPU = HOST.CPU.I386
            SEQ
              code.len := SIZE i386.code
              [code FROM 0 FOR code.len] := i386.code
          HOST.CPU = HOST.CPU.TRANSPUTER
            SEQ
              code.len := SIZE transputer.code
              [code FROM 0 FOR code.len] := transputer.code
          TRUE
            fail := TRUE

        IF
          fail
            SEQ
              failed.test("B581b")
              writes("No KERNEL.RUN object code defined*c*n")
              error.count := error.count + 1
          TRUE
            SEQ
              [code.buffer FROM 0 FOR code.len] := [code FROM 0 FOR code.len]
              ws.size := SIZE b.workspace

              []INT workspace RETYPES [b.workspace FROM 0 FOR ws.size] :
              -- VAL ret.ptr IS (SIZE workspace) - 5 :
              VAL ret.ptr IS (SIZE workspace) - 6 :	-- even for -zer64
              SEQ
                []BYTE b.x RETYPES x :
                LOAD.BYTE.VECTOR(workspace[ret.ptr + 1], b.x)
                workspace[ret.ptr + 2] := y

                x := 100
                -- KERNEL.RUN(code.buffer, entry.point, workspace, 3)
                KERNEL.RUN(code.buffer, entry.point, workspace, 4)	-- even for -zer64
                check (x, 99, "B581a")

                []BYTE b.x RETYPES x :
                LOAD.BYTE.VECTOR(workspace[ret.ptr + 1], b.x)
                workspace[ret.ptr + 2] := y

                x := 101
                -- KERNEL.RUN(code, 0, workspace, 3)
                KERNEL.RUN(code, 0, workspace, 4)	-- even for -zer64
                check (x, 99, "B581b")
    :
    bug.581()
    #ENDIF
    --}}}  
    --{{{  bug 1308
    PROC bug.1308()
      [10]INT data :
      [10][10]BYTE dest :
      [10][SIZE dest][SIZE dest[0]]BYTE source :
      INT c :
      SEQ
        SEQ i = 0 FOR SIZE data
          data [i] := i
        SEQ i = 0 FOR SIZE source[0][0]
          source[0][0][i] := BYTE i
        SEQ j = 1 FOR (SIZE source[0]) - 1
          source[0][j] := source[0][0]
        SEQ k = 1 FOR (SIZE source) - 1
          source[k] := source[0]
        c := 5
        -- MOVE2D(source[data[c]], 0, 0, dest, 0, 0, SIZE dest, SIZE dest[0])
        -- IF
        --   IF i = 0 FOR SIZE dest
        --     IF j = 0 FOR SIZE dest[0]
        --       (INT dest[i][j]) <> j
        --         check(INT dest[i][j], j, "B1308a")
        --   TRUE
        --     SKIP
    :
    bug.1308()
    --}}}  
    --{{{  bug 1378
    PROC bug.1378()
      INT A, B:
      SEQ
        #IF NOT DEFINED (COMPILER.TOCK)
        --{{{  modified by frmb.  can't test like this, need flow-control info
        --ASM
        --  LDAB 1, 2
        --  CJ   :L1
        --  :L1
        --  ST   A
        --  LDAB 0, 1
        --  CJ   :L2
        --  :L2
        --  ST   B
        ASM
          LDAB	1, 2
          POP
          ST	A
          LDAB	0, 1
          ST	B
          POP
        --}}}  
        check(A, 2, "B1378a")
        check(B, 0, "B1378b")
        #ENDIF
    :
    bug.1378()
    --}}}  
    --{{{  bug 1797 (WSSIZEOF and VSSIZEOF)
    PROC bug.1797()
      PROC test()
        SKIP
      :
      VAL slots IS 10 :
      PROC testv(VAL [slots]INT s)
        [slots]INT b :
        PLACE b IN VECSPACE :
        SEQ
          b := s
      :
      PROC testw(VAL [slots]INT s)
        [slots]INT b :
        PLACE b IN WORKSPACE :
        SEQ
          b := s
      :
      INT FUNCTION f() IS 99 :
      INT x :
      SEQ
        #IF NOT DEFINED (COMPILER.TOCK)
        x := WSSIZEOF(check)
        x := WSSIZEOF(finish) + x
        --x := WSSIZEOF(cg.exit) + x
        x := WSSIZEOF(f) + x
        check(INT (x > 0), INT TRUE, "B1797a")
        x := WSSIZEOF(test)
        check(INT (x < 5), INT TRUE, "B1797b")
        x := VSSIZEOF(test)
        check(x, 0, "B1797c")
        x := VSSIZEOF(testv)
        check(INT (x >= slots), INT TRUE, "B1797d")
        x := VSSIZEOF(testw)
        check(x, 0, "B1797e")
        x := WSSIZEOF(testw)
        check(INT (x >= slots), INT TRUE, "B1797f")
        #ENDIF
    :
    bug.1797()
    --}}}  
    finish ()
:
