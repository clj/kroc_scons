<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
	<head>
		<title>occ21 extensions</title>
		<meta name="author" content="Fred Barnes" />
		<meta name="description" content="slice of fred's home page [occ21 extensions], plain version" />
		<meta name="keywords" content="fred's home page, into the wibble, F.R.M. Barnes, Fred Barnes, page occ21 extensions" />
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
	</head>
	<body>


<h1>Various Extensions to the occam Compiler</h1>

<p>
	<em><a href="http://www.cs.kent.ac.uk/~frmb/">Fred Barnes</a>, <a href="http://www.cs.kent.ac.uk/">Department of Computer Science</a>,
		<a href="http://www.kent.ac.uk/">University of Kent</a>.</em>
</p>
<p>
	<em>Last modified 20th March 2005</em>
</p>
<!--{{{  contents-->
<hr />
<p />
<ul>
	<li>20/03/2005 <a href="#mobchanvar">Variables of any channel type</a></li>
	<li>13/03/2005 <a href="#mobilebarrier">Mobile BARRIER support</a></li>
	<li>26/02/2005 <a href="#barrier">Native BARRIER support</a></li>
	<li>19/01/2005 <a href="#anychantype">Channels of any channel type</a></li>
	<li>21/12/2004 <a href="#spectagvals">Tag-value specification for tagged protocols</a></li>
	<li>05/05/2004 <a href="#mobproctype">MOBILE process types</a></li>
	<li>04/01/2004 <a href="#protinherit">Protocol inheritance</a></li>
	<li>30/12/2003 <a href="#ctforwdecl">Forward declarations for channel-types</a></li>
	<li>09/08/2003 <a href="#nmobiles1">Basic nested MOBILEs support</a></li>
	<li>20/03/2003 <a href="#defined">DEFINED dynamic mobile operator support</a></li>
	<li>16/03/2003 <a href="#preproc">Pre-processing support</a></li>
	<li>13/02/2003 <a href="#earray">Empty array specifications</a></li>
	<li>03/09/2002 <a href="#recct">Recursive channel types</a></li>
	<li>03/09/2002 <a href="#anonct">Anonymous channel types</a></li>
	<li>01/09/2002 <a href="#forking">FORKed parallel processes</a></li>
	<li>30/06/2002 <a href="#chantypes">MOBILE structured channel types</a></li>
	<li>04/02/2002 <a href="#priority">Process priority support</a></li>
	<li>14/01/2002 <a href="#placed">PLACED channels and arrays</a></li>
	<li>10/01/2002 <a href="#revalt">Modified ALT disabling sequence</a></li>
	<li>19/12/2001 <a href="#extin">Extended rendezvous</a></li>
	<li>18/12/2001 <a href="#result">RESULT parameters and abbreviations</a></li>
	<li>12/12/2001 <a href="#nproto">Nested PROTOCOL definitions</a></li>
	<li>10/12/2001 <a href="#altskips">Modified parsing of SKIP in ALTs</a></li>
	<li>30/11/2001 <a href="#recursion">Recursion in occam</a></li>
	<li>14/11/2001 <a href="#step">STEP in replicators</a></li>
	<li>23/10/2001 <a href="#chandir">Channel direction specifiers</a></li>
	<li>23/10/2001 <a href="#optof">Optional OF</a></li>
	<li>08/10/2001 <a href="#arrayc">Array constructors</a></li>
	<li>01/10/2001 <a href="#npar">Variable replicated PARs</a></li>
	<li>08/09/2001 <a href="#mobiles">MOBILE data types</a></li>
</ul>
<p>
	As of 1.3.3 (final), the majority of these extensions are enabled by default.  Future/ongoing extensions may
	require the use of the ``<tt>-X7</tt>'' flag to kroc.
	This document is compatible with versions 1.3.4 (pre7) and above of <a href="http://www.cs.kent.ac.uk/projects/ofa/kroc/">KRoC/Linux</a>.
</p>
<p>
	A <a href="occ21-extensions-plain.html">plain version</a> of this document is available, as is a <a href="occ21-extensions-clean.html">clean version</a> (keeping syntax highlighting).
</p>
<!--}}}-->
<!--{{{  Variables of any channel type-->
<hr />
<p />
<h2 class="tsel1 midheader"><a id="mobchanvar">Variables of any channel type</a></h2>
<p>
	<em>added 20/03/2005</em>
</p>
<p>
	The support for <a href="anychantype">channels of any channel type</a> has now been extended to support variables and parameters of the "<tt>MOBILE.CHAN</tt>" type.  Variables
	of this type (that can be specialised in the usual way with "<tt>SHARED</tt>" and/or a direction-specifier) may be communicated on matching channels, or assigned to each other.
	Furthermore, a regular mobile-channel-end may be assigned to a "<tt>MOBILE.CHAN</tt>" and visa-versa (with an additional run-time check in the latter case to ensure the correct type
	is present).  For example:
</p>
<pre class="source">

    <span class="keyword">CHAN TYPE</span> FOO
      <span class="keyword">MOBILE RECORD</span>
        <span class="keyword">CHAN INT</span> <span class="chan">c?</span>:
    :

    <span class="keyword">MOBILE.CHAN</span> <span class="var">x</span>, <span class="var">y</span>:
    FOO! <span class="var">f.c</span>:
    <span class="keyword">SEQ</span>
      <span class="comment">...  acquire f.c</span>
      <span class="var">x</span> := <span class="var">f.c</span>
      <span class="var">y</span> := <span class="var">x</span>
      <span class="var">f.c</span> := <span class="var">y</span>

</pre>
<!--}}}-->
<!--{{{  Mobile BARRIER support-->
<hr />
<p />
<h2 class="tsel1 midheader"><a id="mobilebarrier">Mobile BARRIER support</a></h2>
<p>
	<em>added 13/03/2005</em>
</p>
<p>
	Mobile barriers are mobile equivalent of <a href="#barrier">static barriers</a>.  These barriers must be explicitly allocated through the use of a special
	mobile assignment (that follows the style of other dynamic mobile allocation):
</p>
<pre class="source">

    <span class="keyword">MOBILE BARRIER</span> <span class="var">b</span>:
    <span class="keyword">SEQ</span>
      <span class="var">b</span> := <span class="keyword">MOBILE BARRIER</span>
      <span class="comment">...  use "b"</span>

</pre>
<p>
	Unlike static barriers, mobile barriers may be freely communicated and assigned <em>except</em> when extended by a "<tt>PAR BARRIER</tt>".  Extended barriers
	may not be over-written, but may still be used as the source in assignment or communication.  For example:
</p>
<pre class="source">

    <span class="keyword">PROC</span> recv (<span class="keyword">CHAN MOBILE BARRIER</span> <span class="chan">in?</span>)
      <span class="keyword">MOBILE BARRIER</span> <span class="var">x</span>:
      <span class="keyword">SEQ</span>
        <span class="chan">in</span> ? <span class="var">x</span>
        <span class="keyword">SYNC</span> <span class="var">x</span>
    :

    <span class="keyword">PROC</span> send (<span class="keyword">CHAN MOBILE BARRIER</span> <span class="chan">out!</span>)
      <span class="keyword">MOBILE BARRIER</span> <span class="var">v</span>:
      <span class="keyword">SEQ</span>
        <span class="var">v</span> := <span class="keyword">MOBILE BARRIER</span>
        <span class="chan">out</span> ! <span class="var">v</span>
        <span class="keyword">SYNC</span> <span class="var">v</span>
    :

    <span class="keyword">CHAN MOBILE BARRIER</span> <span class="chan">c</span>:
    <span class="keyword">PAR</span>
      send (<span class="chan">c!</span>)
      recv (<span class="chan">c?</span>)

</pre>
<p>
	Following the semantics of communication, mobile barriers may be passed to "<tt>FORK</tt>"ed processes, that can overwrite
	their mobile barrier parameters even when extended.  Mobile barriers may also be "<tt>RESIGN</tt>"ed in the normal way.  For example:
</p>
<pre class="source">

    <span class="keyword">PROC</span> foo (<span class="keyword">MOBILE BARRIER</span> <span class="var">x</span>)
      <span class="keyword">SEQ</span>
        <span class="keyword">SYNC</span> <span class="var">x</span>
        <span class="var">x</span> := <span class="keyword">MOBILE BARRIER</span>
        <span class="keyword">SYNC</span> <span class="var">x</span>
    :

    <span class="keyword">MOBILE BARRIER</span> <span class="var">b</span>:
    <span class="keyword">SEQ</span>
      <span class="var">b</span> := <span class="keyword">MOBILE BARRIER</span>
      <span class="keyword">PAR BARRIER</span> <span class="var">b</span>
        <span class="keyword">FORK</span> foo (<span class="var">b</span>)
	<span class="keyword">SYNC</span> <span class="var">b</span>
	<span class="keyword">RESIGN</span> <span class="var">b</span>
	  <span class="comment">...  do stuff without "b"</span>

</pre>
<!--}}}-->
<!--{{{  Native BARRIER support-->
<hr />
<p />
<h2 class="tsel1 midheader"><a id="barrier">Native BARRIER support</a></h2>
<p>
	<em>added 26/02/2005</em>
</p>
<p>
	This extension provides a "<tt>BARRIER</tt>" type, used to synchronise multiple parallel processes (channels synchronise two processes only).  Barriers may be
	declared and renamed (passed as parameters and abbreviated) like ordinary variables, but may not be communicated or assigned.  Normal parallel-usage rules apply
	to barriers, <em>except</em> when a "<tt>PAR</tt>" construct <em>extends</em> a barrier (specified using "<tt>PAR BARRIER</tt>").  For example:
</p>
<pre class="source">

    <span class="keyword">PROC</span> foo (<span class="keyword">BARRIER</span> <span class="var">x</span>)
      <span class="keyword">SEQ</span>
        <span class="keyword">SYNC</span> <span class="var">x</span>
        <span class="keyword">SYNC</span> <span class="var">x</span>
    :

    <span class="keyword">BARRIER</span> <span class="var">b</span>:
    <span class="keyword">PAR BARRIER</span> <span class="var">b</span>
      foo (<span class="var">b</span>)
      foo (<span class="var">b</span>)

</pre>
<p>
	Processes may resign themselves from a barrier, but this introduces non-determinism.  For example:
</p>
<pre class="source">

    <span class="keyword">BARRIER</span> <span class="var">b</span>:
    <span class="keyword">PAR BARRIER</span> <span class="var">b</span>
      <span class="keyword">SYNC</span> <span class="var">b</span>
      <span class="keyword">SEQ</span>
        <span class="keyword">RESIGN</span> <span class="var">b</span>
	  <span class="comment">...  do stuff without the barrier</span>
        <span class="keyword">SYNC</span> <span class="var">b</span>

</pre>
<p>
	The default behaviour of the compiler is to resign parallel processes from the barrier as soon as they terminate -- without waiting for the whole "<tt>PAR</tt>"
	to terminate before resigning the processes.
</p>
<!--}}}-->
<!--{{{  Channels of any channel type-->
<hr />
<p />
<h2 class="tsel1 midheader"><a id="anychantype">Channels of any channel type</a></h2>
<p>
	<em>added 19/01/2005</em>
</p>
<p>
	This addition allows a channel to carry a special "any channel-type" protocol.  This is essentially the same as variant (tagged) communication, except that the tag
	is implied by the channel-type.  For example:
</p>
<pre class="source">

    <span class="keyword">CHAN TYPE</span> LINK
      <span class="keyword">MOBILE RECORD</span>
        <span class="keyword">CHAN INT</span> <span class="chan">c?</span>:
    :

    <span class="keyword">PROC</span> recv (<span class="keyword">CHAN MOBILE.CHAN</span> <span class="chan">in?</span>)
      LINK! <span class="var">l.cli</span>:
      <span class="keyword">SHARED</span> LINK! <span class="var">l.scli</span>:
      <span class="chan">in</span> ? <span class="keyword">CASE</span>
        <span class="var">l.cli</span>
          <span class="comment">...  process using l.cli</span>
        <span class="var">l.scli</span>
          <span class="comment">...  process using l.scli</span>
    :

    <span class="keyword">PROC</span> send (<span class="keyword">CHAN MOBILE.CHAN</span> <span class="chan">out!</span>)
      LINK! <span class="var">l.cli</span>:
      LINK? <span class="var">l.svr</span>:
      <span class="keyword">SEQ</span>
        <span class="var">l.cli</span>, <span class="var">l.svr</span> := <span class="keyword">MOBILE</span> LINK
        <span class="chan">out</span> ! <span class="var">l.cli</span>
    :

</pre>
<p>
	These could be connected with just:
</p>
<pre class="source">

    <span class="keyword">CHAN MOBILE.CHAN</span> <span class="chan">c</span>:
    <span class="keyword">PAR</span>
      send (<span class="chan">c!</span>)
      recv (<span class="chan">c?</span>)

</pre>
<p>
	Or something more elaborate..  As far as parameters and abbreviations are concerned (renaming), channels of the any channel-type are only type-compatible with
	themselves.  More specialised declarations can also be made, e.g. to only carry shared channel-ends or client/server channel-ends.  For example:
</p>
<pre class="source">

    <span class="keyword">CHAN SHARED MOBILE.CHAN?</span> <span class="var">c</span>:
    <span class="keyword">CHAN MOBILE.CHAN!</span> <span class="var">d</span>:
    <span class="comment">...  process using c and d</span>

</pre>
<p>
	The "<tt>MOBILE.CHAN</tt>" type may also be used to declare any-channel-type variables and parameters.  These may be directly inputted or outputted to a correspondingly
	typed channel, including use in sequential/variant protocols.  For example:
</p>
<pre class="source">

    <span class="keyword">PROTOCOL</span> ILINK
      <span class="keyword">CASE</span>
        get.status
        route; <span class="keyword">INT</span>; <span class="keyword">MOBILE.CHAN</span>
    :

    <span class="keyword">PROC</span> linkify (<span class="keyword">CHAN MOBILE.CHAN</span> <span class="chan">in?</span>, <span class="keyword">CHAN</span> ILINK <span class="chan">out!</span>)
      <span class="keyword">WHILE TRUE</span>
        <span class="keyword">MOBILE.CHAN</span> <span class="var">x</span>:
        <span class="keyword">SEQ</span>
          <span class="chan">in</span> ? <span class="var">x</span>
          <span class="chan">out</span> ! route; <span class="const">0</span>; <span class="var">x</span>
    :

</pre>
<p>
	Ordinary channel-types may also be output as a "<tt>MOBILE.CHAN</tt>" protocol component, but not input (since there is no clear way to define this in the language syntax).
	<a href="#mobchanvar">"<tt>MOBILE.CHAN</tt>" variables</a> are covered in detail above.
</p>
<!--}}}-->
<!--{{{  Tag-value specification for tagged protocols-->
<hr />
<p />
<h2 class="tsel1 midheader"><a id="spectagvals">Tag-value specification for tagged protocols</a></h2>
<p>
	<em>added 21/12/2004</em>
</p>
<p>
	This addition allows the programmer to specify specific values for the tags in tagged (variant) protocols.  This allows external C code (using the CIF framework) to
	communicate on variant protocol channels with occam processes, without relying on (occam-pi) compiler-generated constants.  Tag values are specified in a natural way,
	for example:
</p>
<pre class="source">

    <span class="keyword">PROTOCOL</span> EXTERNAL.LINK
      <span class="keyword">CASE</span>
        mouse.x.y = <span class="const">0</span>; <span class="keyword">INT</span>; <span class="keyword">INT</span>
        mouse.down = <span class="const">2</span>; <span class="keyword">INT</span>
        mouse.up = <span class="const">3</span>; <span class="keyword">INT</span>
    :

</pre>
<p>
	The compiler will check that specified tag-values do not conflict when dealing with <a href="#nproto">nested protocols</a> and/or <a href="#protinherit">inherited protocols</a>.
	Additionally the compiler will disallow any tagged protocol with a mixture of value-specified and non-value-specified tags.
</p>
<!--}}}-->
<!--{{{  MOBILE process types-->
<hr />
<p />
<h2 class="tsel1 midheader"><a id="mobproctype">MOBILE process types</a></h2>
<p>
	<em>added 05/05/2004</em>
</p>
<p>
	This extension adds support for <tt>MOBILE</tt> processes in `occam-pi' (the new name for the evolving occam-originating language).  Mobile processes
	have an associated <em>process-type</em> that characterises the interface to the process.  Mobile processes encapsulate code and data, like any other occam process,
	but may be <em>moved</em> around a process network.  The main restriction is that a mobile process may not be moved whilst it is <em>active</em>.  Activations of a
	mobile process are implemented using an `instance-style' syntax.  A mobile process ceases to be active when it terminates or `<tt>SUSPEND</tt>'s.  Once it has terminated,
	a mobile process may not be reactivated.
</p>
<p>
	The following code defines a fairly simple mobile process (and associated process-type):
</p>
<pre class="source">

    <span class="keyword">PROC TYPE</span> PT <span class="keyword">IS</span> (<span class="keyword">CHAN INT</span> <span class="chan">in?</span>, <span class="chan">out!</span>):

    <span class="keyword">MOBILE PROC</span> integrate (<span class="keyword">CHAN INT</span> <span class="chan">in?</span>, <span class="chan">out!</span>) <span class="keyword">IMPLEMENTS</span> PT
      <span class="chan">INT</span> <span class="var">total</span>:
      <span class="keyword">SEQ</span>
        <span class="var">total</span> := <span class="const">0</span>
        <span class="keyword">WHILE</span> <span class="const">TRUE</span>
          <span class="keyword">INT</span> <span class="var">v</span>:
          <span class="keyword">SEQ</span>
            <span class="chan">in</span> ? <span class="var">v</span>
            <span class="var">total</span> := <span class="var">total</span> + <span class="var">v</span>
            <span class="chan">out</span> ! <span class="var">total</span>
            <span class="keyword">SUSPEND</span>
    :

</pre>
<p>
	This implements the familiar `integrate' component.  When activated, the process will complete one cycle of input and output then suspend.  Allocation of a mobile process
	is done in a similar way as it is for other dynamic mobile types -- with a slightly special form of assignment.  For example:
</p>
<pre class="source">

    <span class="keyword">MOBILE</span> PT <span class="var">x</span>:
    <span class="keyword">INT</span> <span class="var">v</span>:
    <span class="keyword">SEQ</span>
      <span class="var">x</span> := <span class="keyword">MOBILE</span> integrate

      <span class="keyword">CHAN INT</span> <span class="chan">to.int</span>, <span class="chan">from.int</span>:
      <span class="keyword">PAR</span>
        <span class="var">x</span> (<span class="chan">to.int?</span>, <span class="chan">from.int!</span>)
        <span class="chan">to.int</span> ! <span class="const">42</span>
        <span class="chan">from.int</span> ? <span class="const">v</span>

</pre>
<p>
	After the activation has finished (because `<tt>integrate</tt>' <tt>SUSPEND</tt>ed), the mobile process in `<tt>x</tt>' may be assigned or communicated.  When it is next
	activated, the process may have a completely different environment.
</p>
<p>
	Due to the somewhat special nature of a mobile process activation, there are several restrictions on what parameters may appear in a `<tt>PROC TYPE</tt>' definition -- only
	synchronisation `objects' may be used as parameters.  This currently includes channels, fixed-size arrays of channels and mobile channel-bundle ends.
</p>
<p>
	If a mobile process goes parallel internally, all parallel processes must <tt>SUSPEND</tt> in order to suspend the mobile process as a whole.
	<a href="http://frmb.org/download/mobprocex1.occ">This example program</a> demonstrates this using a parallel version of the `integrate' process.  Rather than suspending
	once per cycle, the process interprets `<tt>MOSTNEG INT</tt>' on its input channel as `suspend'.  This is one way of handling the suspend -- it could just as easily be
	supported using dedicated channels (that may be more desirable for clarity).
</p>
<!--}}}-->
<!--{{{  Protocol inheritance-->
<hr />
<p />
<h2 class="tsel1 midheader"><a id="protinherit">Protocol inheritance</a></h2>
<p>
	<em>added 04/01/2004</em>
</p>
<p>
	Support for protocol inheritance has now been added to the occam compiler.  This allows tagged (variant) protocols
	to <em>inherit</em> tags from others, creating a type-compatibility between them.
</p>
<p>
	For example:
</p>
<pre class="source">

    <span class="keyword">PROTOCOL</span> MOUSE.EVENTS
      <span class="keyword">CASE</span>
        mouse.x.y; <span class="keyword">INT</span>; <span class="keyword">INT</span>
        mouse.down; <span class="keyword">INT</span>
        mouse.up; <span class="keyword">INT</span>
    :

    <span class="keyword">PROTOCOL</span> KEY.EVENTS
      <span class="keyword">CASE</span>
        key.down; <span class="keyword">INT</span>; <span class="keyword">INT</span>
        key.up; <span class="keyword">INT</span>; <span class="keyword">INT</span>
    :

    <span class="keyword">PROTOCOL</span> GFX.EVENTS <span class="keyword">EXTENDS</span> MOUSE.EVENTS, KEY.EVENTS
      <span class="keyword">CASE</span>
        gen.error; <span class="keyword">INT</span>
    :

</pre>
<p>
	This can be used in the expected way.  Given the set of <tt>PROC</tt>s:
</p>
<pre class="source">

    <span class="keyword">PROC</span> graphics.server (<span class="keyword">CHAN</span> GFX.EVENTS <span class="chan">in?</span>)
    <span class="keyword">PROC</span> mouse.driver (<span class="keyword">CHAN</span> MOUSE.EVENTS <span class="chan">out!</span>)
    <span class="keyword">PROC</span> keyboard.driver (<span class="keyword">CHAN</span> KEY.EVENTS <span class="chan">out!</span>)

</pre>
<p>
	We can wire them up this way:
</p>
<pre class="source">

    <span class="keyword">CHAN</span> GFX.EVENTS <span class="chan">c</span>:
    <span class="keyword">PAR</span>
      mouse.driver (<span class="chan">c!</span>)
      graphics.server (<span class="chan">c?</span>)

</pre>
<p>
	or this way:
</p>
<pre class="source">

    <span class="keyword">CHAN</span> KEY.EVENTS <span class="chan">c</span>:
    <span class="keyword">PAR</span>
      keyboard.driver (<span class="chan">c!</span>)
      graphics.server (<span class="chan">c?</span>)

</pre>
<p>
	These show the two allowed ways of using protocol inheritance.  There are two others which are not legal, however, and are banned by the compiler.
</p>
<p>
	In the first example, there would normally be a type incompatability in the instance of `<tt>mouse.driver</tt>', since a channel of a different type
	is passed as a parameter.  However, since `<tt>GFX.EVENTS</tt>' (actual type) includes all the tags of `<tt>MOUSE.EVENTS</tt>' (formal type), anything
	that `<tt>mouse.driver</tt>' outputs is potentially handled (by a process that inputs `<tt>GFX.EVENTS</tt>').
</p>
<p>
	In the second example, the incompatability is the instance of `<tt>graphics.server</tt>'.  A similar logic as before applies, however.  The
	`<tt>graphics.server</tt>' process accepts (potentially) any of the `<tt>GFX.EVENTS</tt>', of which `<tt>KEY.EVENTS</tt>' are a subset.
</p>
<p>
	The two invalid cases are substantially less natural.  Assuming there was:
</p>
<pre class="source">

    <span class="keyword">PROC</span> mouse.handler (<span class="keyword">CHAN</span> MOUSE.EVENTS <span class="chan">in?</span>)
    <span class="keyword">PROC</span> graphics.plex ([]<span class="keyword">CHAN</span> GFX.EVENTS <span class="chan">in?</span>, <span class="keyword">CHAN</span> GFX.EVENTS <span class="chan">out!</span>)

</pre>
<p>
	Then:
</p>
<pre class="source">

    <span class="keyword">CHAN</span> MOUSE.EVENTS <span class="chan">c</span>:
    <span class="keyword">PAR</span>
      graphics.plex (..., <span class="chan">c!</span>)
      mouse.handler (<span class="chan">c?</span>)

</pre>
<p>
	and
</p>
<pre class="source">

    <span class="keyword">CHAN</span> GFX.EVENTS <span class="chan">c</span>:
    <span class="keyword">PAR</span>
      graphics.plex (..., <span class="chan">c!</span>)
      mouse.handler (<span class="chan">c?</span>)

</pre>
<p>
	are illegal.  In the first, for example, an attempt is made to connect a channel of `<tt>MOUSE.EVENTS</tt>' to a process that outputs
	any `<tt>GFX.EVENTS</tt>', of which `<tt>MOUSE.EVENTS</tt>' are possibly only a subset -- i.e. `<tt>graphics.plex</tt>' could output
	something that <em>couldn't</em> be handled by `<tt>mouse.handler</tt>'.  And that makes good sense.  The second example is similar,
	but with the error being at the other end of the channel (an attempt to connect an input channel carrying potentially any `<tt>GFX.EVENTS</tt>'
	to a process that can only handle `<tt>MOUSE.EVENTS</tt>').
</p>
<p>
	There are several restrictions associated with protocol inheritance, that are largely technical.  The compiler will abort when it finds
	cases that it can't handle.
</p>
<!--}}}-->
<!--{{{  Forward declarations for channel-types-->
<hr />
<p />
<h2 class="tsel1 midheader"><a id="ctforwdecl">Forward declarations for channel-types</a></h2>
<p>
	<em>added 30/12/2003 </em>
</p>
<p>
	Support for forward declarations of channel-types has now been added to the occam compiler.  This allows
	the use of a channel-type <em>name</em> before its actual definition.  Unlike forward declarations for
	procedure (names), forward declarations of channel-types do not add any recursion-related problems (an
	equivalent would be outputting an output, and so on, which isn't legal occam).
</p>
<p>
	The practical up-shot is that channel-types may carry <em>ends</em> of each other recursively; or that
	a channel-type may carry itself (essentially a <a href="#recct">recursive channel-type</a>).
</p>
<p>
	For example:
</p>
<pre class="source">

    <span class="keyword">CHAN</span> <span class="keyword">TYPE</span> BAR:                <span class="comment">-- forward declaration</span>

    <span class="keyword">PROTOCOL</span> FOO.IN
      <span class="keyword">CASE</span>
        a.bar.client; BAR!
    :

    <span class="keyword">CHAN TYPE</span> FOO
      <span class="keyword">MOBILE RECORD</span>
        <span class="keyword">CHAN</span> FOO.IN <span class="chan">in?</span>:
    :

    <span class="keyword">PROTOCOL</span> BAR.IN
      <span class="keyword">CASE</span>
        a.foo.client; FOO!
    :

    <span class="keyword">CHAN TYPE</span> BAR
      <span class="keyword">MOBILE RECORD</span>
        <span class="keyword">CHAN</span> BAR.IN <span class="chan">in?</span>:
    :

</pre>
<p>
	Or more simply:
</p>
<pre class="source">

    <span class="keyword">CHAN TYPE</span> BLIP:               <span class="comment">-- forward declaration</span>

    <span class="keyword">CHAN TYPE</span> BLIP
      <span class="keyword">MOBILE RECORD</span>
        <span class="keyword">CHAN</span> BLIP! <span class="chan">blip.in?</span>:
    :

</pre>
<p>
	which is equivalent to a `<tt>RECURSIVE</tt>' declaration:
</p>
<pre class="source">

    <span class="keyword">RECURSIVE CHAN TYPE</span> BLIP
      <span class="keyword">MOBILE RECORD</span>
        <span class="keyword">CHAN</span> BLIP! <span class="chan">blip.in?</span>:
    :

</pre>
<!--}}}-->
<!--{{{  Basic nested MOBILEs support-->
<hr />
<p />
<h2 class="tsel1 midheader"><a id="nmobiles1">Basic nested MOBILEs support</a></h2>
<p>
	<em>added 09/08/2003</em>
</p>
<p>
	Support for some basic nested <tt>MOBILE</tt> types has now been added to the occam compiler.  These represent only a fraction of the
	possible nested mobile type-system, but are a start.  The two types currently supported are limited to single-level nesting and were
	implemented first because of a need for them.
</p>
<p>
	They are:
</p>
<ul>
	<li>dynamic mobile arrays of dynamic mobile arrays</li>
	<li>dynamic mobile arrays of mobile channel-ends</li>
</ul>
<p>
	Examples of these:
</p>
<pre class="source">

    <span class="keyword">MOBILE</span> []<span class="keyword">MOBILE</span> []<span class="keyword">BYTE</span> <span class="var">messages</span>:      <span class="comment">-- array of arrays</span>
    <span class="keyword">MOBILE</span> []<span class="keyword">SHARED</span> FOO! <span class="var">s.foo.clients</span>:   <span class="comment">-- array of channel ends</span>

</pre>
<p>
	Note that the first example and the type `<tt>MOBILE [][]BYTE</tt>' are very different -- the latter is a single-level array of two dimensions
	(a 2D matrix of <tt>BYTE</tt>s), whilst the former is a two-level array, each of one dimension (an array of arrays of <tt>BYTE</tt>s).
</p>
<p>
	Any channel-type `end-type' is valid for arrays of channel-ends, shared or unshared, client or server.
</p>
<p>
	Initialisation of such data is as expected -- the outer array must be allocated first.  For example:
</p>
<pre class="source">

    <span class="keyword">MOBILE</span> []<span class="keyword">MOBILE</span> []<span class="keyword">BYTE</span> <span class="var">msgs</span>:
    <span class="keyword">INT</span> <span class="var">i</span>:
    <span class="keyword">SEQ</span>
      <span class="var">i</span> := <span class="const">10</span>
      <span class="var">msgs</span> := <span class="keyword">MOBILE</span> [<span class="var">i</span>]<span class="keyword">MOBILE</span> []<span class="keyword">BYTE</span>
      <span class="var">msgs</span>[<span class="const">0</span>] := <span class="const">"hello, world!*n"</span>
      <span class="var">msgs</span>[<span class="const">1</span>] := <span class="var">msgs</span>[<span class="const">0</span>]
      out.string (<span class="var">msgs</span>[<span class="const">1</span>], <span class="const">0</span>, <span class="chan">screen!</span>)

</pre>
<!--}}}-->
<!--{{{  DEFINED dynamic mobile operator support-->
<hr />
<p />
<h2 class="tsel1 midheader"><a name="defined"><tt>DEFINED</tt> dynamic mobile operator support</a></h2>
<p>
	<em>added 20/03/2003</em>
</p>
<p>
	For the majority of programming languages, once defined, a variable stays that way -- there is no clear
	way to undefine variables in most languages (with some exceptions, such as assigning from a function whose
	result is undefined).  In occam, ordinary variables are considered undefined until assignment or input to.
	Once defined, they stay that way.  Mobile variables, however, can transition between undefined and defined,
	based on the program logic (there is also other <em>definedness</em> states -- partially defined and possibly
	defined amongst them).
</p>
<p>
	At some points in a program, it may be unknown (in the program logic) whether a particular variable is
	defined or undefined.  For example, consider a mobile channel-end -- it may or may not be connected to
	a server.  Or a dynamic mobile array -- it may either contain zero elements (undefined) or some elements
	(defined), separate from the definedness states of those elements.
</p>
<p>
	The `<tt>DEFINED</tt>' operator provides a way of testing this at run-time, with subtle effects on the
	undefinedness checker.  For example, the following code fragment is valid:
</p>
<pre class="source">

    <span class="keyword">CHAN TYPE</span> FOO
      <span class="keyword">MOBILE RECORD</span>
        <span class="keyword">CHAN INT</span> <span class="chan">c?</span>:
    :

    FOO! <span class="var">f.c</span>:
    <span class="keyword">SEQ</span>
      <span class="keyword">IF</span>
        <span class="keyword">DEFINED</span> <span class="var">f.c</span>
          <span class="var">f.c</span>[c] ! <span class="const">42</span>
        <span class="const">TRUE</span>
          FOO? <span class="var">f.s</span>:
          <span class="keyword">SEQ</span>
            <span class="var">f.c</span>, <span class="var">f.s</span> := <span class="keyword">MOBILE</span> FOO
            <span class="keyword">FORK</span> server (<span class="var">f.s</span>)
            <span class="var">f.c</span>[<span class="chan">c</span>] ! <span class="const">42</span>

</pre>
<p>
	Attempts to use the <tt>DEFINED</tt> operator with non-dynamic mobiles (i.e. static mobiles and ordinary variables)
	results in a compiler error.  This may be modified in the future to work with other types.
</p>
<!--}}}-->
<!--{{{  Pre-processing support-->
<hr />
<p />
<h2 class="tsel1 midheader"><a name="preproc">Pre-processing support</a></h2>
<p>
	<em>added 16/03/2003</em>
</p>
<p>
	A limited support for pre-processing has now been added to occam.  Most usefully, it adds a mechanism for
	conditional compilation, using pre-processor constants.  Given the issues relating to the combination of
	conditional compilation and occam's indentation, the pre-processor is implemented as part of the compiler,
	with a special directive for limited control of indentation.
</p>
<p>
	For example:
</p>
<pre class="source">

    <span class="preproc">#DEFINE USE.INT.OUT</span>

    <span class="keyword">PROC</span> write.int (<span class="keyword">VAL INT</span> <span class="var">x</span>, <span class="keyword">CHAN BYTE</span> <span class="chan">out!</span>)
      <span class="preproc">#IF DEFINED (USE.INT.OUT)</span>
      out.int (<span class="var">x</span>, <span class="const">0</span>, <span class="chan">out!</span>)
      <span class="preproc">#ELSE</span>
      out.number (<span class="var">x</span>, <span class="const">0</span>, <span class="chan">out!</span>)
      <span class="preproc">#ENDIF</span>
    :

</pre>
<p>
	This would cause the use of `<tt>out.int</tt>' inside `<tt>write.int</tt>', instead of `<tt>out.number</tt>'.  Removing
	the `<tt>#DEFINE USE.OUT.INT</tt>' (or commenting it out) would reverse this.
</p>
<p>
	The above example demonstrates the obvious problem with indentation -- it would be nice if the contents of conditional
	compilation blocks were indented, but it would be somewhat extreme to always enforce this (temporary `<tt>#IF FALSE</tt>'ing of code, for example).
	Therefore, a special `<tt>#RELAX</tt>' directive is provided, that `relaxes' the indentation inside a conditional compilation block.
</p>
<p>
	Re-writing the above, for example:
</p>
<pre class="source">

    <span class="preproc">#DEFINE USE.INT.OUT</span>

    <span class="keyword">PROC</span> write.int (<span class="keyword">VAL INT</span> <span class="var">x</span>, <span class="keyword">CHAN BYTE</span> <span class="chan">out!</span>)
      <span class="preproc">#IF DEFINED (USE.INT.OUT)</span>
        <span class="preproc">#RELAX</span>
        out.int (<span class="var">x</span>, <span class="const">0</span>, <span class="chan">out!</span>)
      <span class="preproc">#ELSE</span>
        <span class="preproc">#RELAX</span>
        out.number (<span class="var">x</span>, <span class="const">0</span>, <span class="chan">out!</span>)
      <span class="preproc">#ENDIF</span>
    :

</pre>
<p>
	In addition to simply defining pre-processor constants, they may be defined (and re-defined) with values.  The values used may either be integers or strings.
	Anything else (besides nothing) is invalid.  When referring to pre-processor constant <em>values</em> in code, the name must be prefixed with `<tt>##</tt>'.
	Such substitutions are always literal.
</p>
<p>
	The compiler, before parsing of a file starts, defines various pre-processor constants.  Some of these depend on compiler build-time or run-time options.
	These are:
</p>
<table cellpadding="4">
	<tr class="oddcell"><th>Name</th><th>Type</th><th>Description</th></tr>
	<tr><td><tt>PROCESS.PRIORITY</tt></td><td>integer</td><td>if defined, the number of process priority levels supported</td></tr>
	<tr><td><tt>OCCAM2.5</tt></td><td>none</td><td>if defined, indicates that support for user-defined types and other occam 2.1 features is available</td></tr>
	<tr><td><tt>USER.DEFINED.OPERATORS</tt></td><td>none</td><td>defined if user-defined operators are supported</td></tr>
	<tr><td><tt>INITIAL.DECL</tt></td><td>none</td><td>defined if <tt>INITIAL</tt> declarations are supported</td></tr>
	<tr><td><tt>MOBILES</tt></td><td>none</td><td>defined if <tt>MOBILE</tt>s (all types) are supported</td></tr>
	<tr><td><tt>BLOCKING.SYSCALLS</tt></td><td>none</td><td>defined if blocking system-calls are supported</td></tr>
	<tr><td><tt>VERSION</tt></td><td>string</td><td>compiler version string</td></tr>
	<tr><td><tt>NEED.QUAD.ALIGNMENT</tt></td><td>none</td><td>defined if the target architecture requires 64-bit alignment of data</td></tr>
	<tr><td><tt>TARGET.CANONICAL</tt></td><td>string</td><td>canonical compiler target name, i.e. the host type that `<tt>occ21</tt>' was compiled for</td></tr>
	<tr><td><tt>TARGET.CPU</tt></td><td>string</td><td>target CPU -- the CPU type that the compiler runs on</td></tr>
	<tr><td><tt>TARGET.OS</tt></td><td>string</td><td>target OS -- the OS that the compiler runs on</td></tr>
	<tr><td><tt>TARGET.VENDOR</tt></td><td>string</td><td>target vendor -- the hardware in use (e.g. `pc')</td></tr>
</table>
<p>
	There is nothing to prevent a file re-defining or un-defining these.  In general, it is not a good idea, however.  Two additional built-ins are also maintained
	by the compiler, `<tt>FILE</tt>' and `<tt>LINE</tt>'.  These refer to the current file-name and line-number respectively.  For example:
</p>
<pre class="source">

    <span class="keyword">PROC</span> message (<span class="keyword">VAL</span> []<span class="keyword">BYTE</span> <span class="var">file</span>, <span class="keyword">VAL INT</span> <span class="var">line</span>, <span class="keyword">CHAN BYTE</span> <span class="chan">scr!</span>)
      <span class="keyword">SEQ</span>
        out.string (<span class="const">"Hello from "</span>, <span class="const">0</span>, <span class="chan">scr!</span>)
        out.string (<span class="var">file</span>, <span class="const">0</span>, <span class="chan">scr!</span>)
        out.string (<span class="const">", line "</span>, <span class="const">0</span>, <span class="chan">scr!</span>)
        out.int (<span class="var">line</span>, <span class="const">0</span>, <span class="chan">scr!</span>)
        <span class="chan">scr</span> ! <span class="const">'*n'</span>
    :

    <span class="keyword">PROC</span> main (<span class="keyword">CHAN BYTE</span> <span class="chan">kyb?</span>, <span class="chan">scr!</span>, <span class="chan">err!</span>)
      <span class="keyword">SEQ</span>
        <span class="comment">...  do stuff</span>
        message (<span class="preproc">##FILE</span>, <span class="preproc">##LINE</span>, <span class="chan">scr!</span>)
        <span class="comment">...  do more stuff</span>
    :

</pre>
<p>
	The mechanism for conditional compilation is formed using `<tt>#IF</tt>', `<tt>#ELIF</tt>', `<tt>#ELSE</tt>' and `<tt>#ENDIF</tt>'.  The expressions used in
	`<tt>#IF</tt>' and `<tt>#ELIF</tt>' are similar to occam expressions, but should not be mistaken for them.  Such expressions must be boolean and fully bracketed.
	The values of pre-processor constants may be referred to simply by name (omitting the `<tt>##</tt>'), and compared with constants and each other using a limited
	range of boolean operators.
</p>
<p>
	The three basic tests/expressions are `<tt>TRUE</tt>', `<tt>FALSE</tt>' and `<tt>DEFINED (</tt><em>name</em><tt>)</tt>', that tests whether or not a particular <em>name</em>
	is a pre-processor define.  For comparing strings are the operators `<tt>&lt;&gt;</tt>' and `<tt>=</tt>'.  For comparing integers, `<tt>&lt;&gt;</tt>', `<tt>=</tt>',
	`<tt>&lt;=</tt>', `<tt>&lt;</tt>', `<tt>&gt;</tt>' and `<tt>&gt;=</tt>'.  For combining/modifying the results of sub-expressions are `<tt>NOT</tt>', `<tt>AND</tt>' and `<tt>OR</tt>'.
	Evaluation of boolean tests is done in strict lazy order, so that one can write, for example:
</p>
<pre class="source">

    <span class="preproc">#IF (NOT DEFINED (PROCESS.PRIORITY)) OR (PROCESS.PRIORITY &lt; 32)</span>
      <span class="preproc">#RELAX</span>
      <span class="preproc">#ERROR not enough or no priority!</span>
    <span class="preproc">#ENDIF</span>

</pre>
<p>
	The two special pre-processor directives `<tt>#ERROR</tt>' and `<tt>#WARNING</tt>' are used to emit errors and warnings respectively.  An error will abort compilation.
	Substitutions of pre-processor values in the message are done using the `<tt>##</tt>' prefix.
</p>
<p>
	A more interesting example is where conditional compilation alters the logic of an occam program (alteration beyond clarity is not recommeded, however).  For example:
</p>
<pre class="source">

    <span class="keyword">WHILE</span> <span class="const">TRUE</span>
      <span class="preproc">#IF DEFINED (USE.PRIALT)</span>
      <span class="keyword">PRI ALT</span>
      <span class="preproc">#ELSE</span>
      <span class="keyword">ALT</span>
      <span class="preproc">#ENDIF</span>
        <span class="comment">...  alt guards</span>

</pre>
<!--}}}-->
<!--{{{  Empty array specifications-->
<hr />
<p />
<h2 class="tsel1 midheader"><a name="earray">Empty array specifications</a></h2>
<p>
	<em>added 13/02/2003</em>
</p>
<p>
	Traditionally in occam, producing an array of size zero has been difficult -- using a zero-length slice of another array.  Attempts to write `<tt>[]</tt>' would
	be banned by the compiler.  You could write `<tt>""</tt>' for an empty array of <tt>BYTE</tt>s, however.
</p>
<p>
	This has now been remedied.  The literal empty array `<tt>[]</tt>' may be used where appropriate (and legal).  Additionally, `<tt>[]</tt>' is allowed as a parameter to
	non-<tt>VAL</tt> formals, and in abbreviations (both renaming).  For example:
</p>
<pre class="source">

    <span class="keyword">SEQ</span>
      out.string (<span class="const">[]</span>, <span class="const">0</span>, <span class="chan">scr!</span>)
      
      []<span class="keyword">BYTE</span> <span class="var">x</span> <span class="keyword">IS</span> <span class="const">[]</span>:
      out.string (<span class="var">x</span>, <span class="const">0</span>, <span class="chan">scr!</span>)

</pre>
<p>
	The abbreviation is not something that would be written normally, but can happen when <tt>PROC</tt> calls are inlined.  Note that although `<tt>[]</tt>' is
	valid for non-val renamings, `<tt>[[]]</tt>' is not -- the outermost array contains a single element.
</p>
<!--}}}-->
<!--{{{  Recursive channel types-->
<hr />
<p />
<h2 class="tsel1 midheader"><a name="recct">Recursive channel types</a></h2>
<p>
	<em>added 03/09/2002</em>
</p>
<p>
	Recursive channel-types add a useful feature to the existing <a href="#chantypes">mobile channel-types</a> -- the ability for a channel within a mobile channel-type
	to transport ends of its own type.  This is particularly useful in client-server networks that involve <em>one-to-one</em> connections between clients and servers,
	established over shared channels -- it provides a means for the client to say ``i'm done'' to the server.  For example:
</p>
<pre class="source">

    <span class="keyword">RECURSIVE CHAN TYPE</span> BUF.MGR
      <span class="keyword">MOBILE RECORD</span>
        <span class="keyword">CHAN INT</span> <span class="chan">req?</span>:
        <span class="keyword">CHAN MOBILE</span> []BYTE <span class="chan">resp!</span>, <span class="chan">ret?</span>:
        <span class="keyword">CHAN</span> BUF.MGR! <span class="chan">done?</span>:
    :

    <span class="keyword">PROC</span> server (<span class="keyword">SHARED CHAN</span> BUF.MGR? <span class="chan">clients?</span>)
      BUF.MGR? <span class="var">link</span>:
      <span class="keyword">WHILE</span> <span class="const">TRUE</span>
        <span class="keyword">SEQ</span>
          <span class="keyword">CLAIM</span> <span class="chan">clients?</span>
            <span class="chan">clients</span> ? <span class="var">link</span>
          <span class="keyword">INITIAL BOOL</span> <span class="var">ok</span> <span class="keyword">IS</span> <span class="const">TRUE</span>:
          <span class="keyword">WHILE</span> <span class="var">ok</span>
            <span class="keyword">ALT</span>
              <span class="keyword">INT</span> <span class="var">size</span>:
              <span class="var">link</span>[<span class="chan">req</span>] ? <span class="var">size</span>
                <span class="comment">...  allocate buffer, give to client, take back again</span>
              BUF.MGR! <span class="var">cli</span>:
              <span class="var">link</span>[<span class="chan">done</span>] ? <span class="var">cli</span>
                <span class="var">ok</span> := <span class="const">FALSE</span>
    :

    <span class="keyword">PROC</span> client (<span class="keyword">SHARED CHAN</span> BUF.MGR? <span class="chan">to.servers!</span>)
      <span class="keyword">SEQ</span>
        <span class="comment">...  some initial local processing</span>
        BUF.MGR? <span class="var">svr</span>:
        BUF.MGR! <span class="var">cli</span>:
        <span class="keyword">SEQ</span>
          <span class="var">svr</span>, <span class="var">cli</span> := <span class="keyword">MOBILE</span> BUF.MGR
          <span class="comment">-- connect to a server</span>
          <span class="keyword">CLAIM</span> <span class="chan">to.servers!</span>
            <span class="chan">to.servers</span> ! <span class="var">svr</span>
          <span class="comment">...  communicate with server using `cli'</span>
          <span class="var">cli</span>[<span class="chan">done</span>] ! <span class="var">cli</span>
          <span class="comment">-- `cli' and `svr' both undefined</span>
    :

</pre>
<p>
	The interesting bit is the last action performed by the client, `<tt>cli[done] ! cli</tt>', that returns the channel-end to the server, to which it is connected.  One way
	to think of this is to imagine the two processes connected by a hose-pipe, where the returning action turns the hose-pipe in on itself at the client end, until it `pops out'
	at the server end.
</p>
<p>
	For completeness, a network using the above `<tt>client</tt>' and `<tt>server</tt>' processes is easily constructed (using <a href="#anonct">anonymous channel-types</a> and
	<a href="#forking">forked processes</a>):
</p>
<pre class="source">

    <span class="keyword">PROC</span> network (<span class="keyword">VAL INT</span> <span class="var">n.cli</span>, <span class="var">n.svr</span>)
      <span class="keyword">SHARED CHAN</span> BUF.MGR <span class="chan">c</span>:
      <span class="keyword">FORKING</span>
      	<span class="keyword">SEQ</span>
          <span class="keyword">SEQ</span> i = <span class="const">0</span> <span class="keyword">FOR</span> <span class="var">n.cli</span>
            <span class="keyword">FORK</span> client (<span class="chan">c!</span>)
          <span class="keyword">SEQ</span> i = <span class="const">0</span> <span class="keyword">FOR</span> <span class="var">n.svr</span>
            <span class="keyword">FORK</span> server (<span class="chan">c?</span>)
    :

</pre>
<!--}}}-->
<!--{{{  Anonymous channel types-->
<hr />
<p />
<h2 class="tsel1 midheader"><a name="anonct">Anonymous channel types</a></h2>
<p>
	<em>added 03/09/2002</em>
</p>
<p>
	Anonymous channel-types provide a convenience.  Quite often, we want a mobile channel-end of only one channel.  The usual way would be to declare a
	<a href="#chantypes">mobile channel-type</a> with a single channel, and use that.  For example:
</p>
<pre class="source">

    <span class="keyword">CHAN TYPE</span> THING
      <span class="keyword">MOBILE RECORD</span>
        <span class="keyword">CHAN INT</span> <span class="chan">c?</span>:
    :

    THING? <span class="var">svr</span>:
    <span class="keyword">SHARED</span> THING! <span class="var">cli</span>:
    <span class="keyword">SEQ</span>
      <span class="var">svr</span>, <span class="var">cli</span> := <span class="keyword">MOBILE</span> THING
      <span class="keyword">PAR</span>
        <span class="keyword">SEQ</span> i = <span class="const">0</span> <span class="keyword">FOR</span> <span class="const">2</span>
          <span class="keyword">INT</span> <span class="var">x</span>:
          <span class="var">svr</span>[<span class="chan">c</span>] ? <span class="var">x</span>
        <span class="keyword">CLAIM</span> <span class="var">cli</span>
          <span class="var">cli</span>[<span class="chan">c</span>] ! <span class="const">42</span>
        <span class="keyword">CLAIM</span> <span class="var">cli</span>
          <span class="var">cli</span>[<span class="chan">c</span>] ! <span class="keyword">MOSTNEG INT</span>

</pre>
<p>
	This is somewhat cumbersome, given the simple nature of what we're trying to do -- share a single channel.  An equivalent version, using anonymous channel
	types, is:
</p>
<pre class="source">

    <span class="keyword">SHARED</span>! <span class="keyword">CHAN INT</span> <span class="chan">c</span>:
    <span class="keyword">PAR</span>
      <span class="keyword">SEQ</span> i = <span class="const">0</span> <span class="keyword">FOR</span> <span class="const">2</span>
        <span class="keyword">INT</span> <span class="var">x</span>:
        <span class="chan">c</span> ? <span class="var">x</span>
      <span class="keyword">CLAIM</span> <span class="chan">c!</span>
        <span class="chan">c</span> ! <span class="const">42</span>
      <span class="keyword">CLAIM</span> <span class="chan">c!</span>
        <span class="chan">c</span> ! <span class="keyword">MOSTNEG INT</span>

</pre>
<p>
	This is much easier to follow, and it is still largely clear what is going on.
</p>
<p>
	Anonymous channel-types are created by use of the `<tt>SHARED</tt>' keyword in an ordinary channel declaration.  By default, both ends of the anonymous
	channel type will be shared, unless restricted by an additional `<tt>?</tt>' or `<tt>!</tt>' (as in the above fragment).  Two restrictions apply to
	anonymous channel-types.  Firstly, whenever referred to by name, a channel-direction specifier must be used to indicate the client or server end (e.g. `<tt>c!</tt>'
	for the client-end).  Secondly, anonymous channel types may not be assigned or communicated, but they may be renamed.  The one exception is that the
	compiler allows an anonymous channel-type to be used as a parameter for a <tt>FORK</tt>ed process.  Additionally, the KRoC run-time system supports anonymous
	channel-types for the standard top-level parameters (in addition to different combinations of top-level parameters).  For example:
</p>
<pre class="source">

    <span class="keyword">PROC</span> say.hello (<span class="keyword">SHARED CHAN BYTE</span> <span class="chan">out!</span>)
      <span class="keyword">VAL</span> []<span class="keyword">BYTE</span> message <span class="keyword">IS</span> <span class="const">"hello, forked and shared world!*n"</span>:
      <span class="keyword">CLAIM</span> <span class="chan">out!</span>
        <span class="keyword">SEQ</span> i = <span class="const">0</span> <span class="keyword">FOR SIZE</span> message
          <span class="chan">out</span> ! message[i]
    :

    <span class="keyword">PROC</span> example (<span class="keyword">CHAN BYTE</span> <span class="chan">kyb?</span>, <span class="keyword">SHARED CHAN BYTE</span> <span class="chan">scr!</span>)
      <span class="keyword">FORKING</span>
        <span class="keyword">SEQ</span>
          <span class="keyword">FORK</span> say.hello (<span class="chan">scr!</span>)
          <span class="keyword">FORK</span> say.hello (<span class="chan">scr!</span>)
    :

</pre>
<p>
	As can be inferred from the above example, when an anonymous channel-type is used as a formal parameter, any restriction on the <tt>SHARED</tt> can
	be omitted.
</p>
<p>
	Inside the body of a <tt>CLAIM</tt> an anonymous channel-type behaves like an ordinary occam channel.  This includes renaming, which is not allowed
	for ordinary mobile channel-types.  Typical usage, for example:
</p>
<pre class="source">

    <span class="preproc">#USE "course.lib"</span>

    <span class="keyword">PROC</span> simple (<span class="keyword">SHARED CHAN BYTE</span> <span class="chan">scr!</span>)
      <span class="keyword">PAR</span>
        <span class="keyword">CLAIM</span> <span class="chan">scr!</span>
          out.string (<span class="const">"hello world 1!*n"</span>, <span class="const">0</span>, <span class="chan">scr!</span>)
        <span class="keyword">CLAIM</span> <span class="chan">scr!</span>
          out.string (<span class="const">"hello world 2!*n"</span>, <span class="const">0</span>, <span class="chan">scr!</span>)
    :

</pre>
<!--}}}-->
<!--{{{  FORKed parallel processes-->
<hr />
<p />
<h2 class="tsel1 midheader"><a name="forking"><tt>FORK</tt>ed parallel processes</a></h2>
<p>
	<em>added 01/09/2002</em>
</p>
<p>
	The `<tt>FORK</tt>' provides a means for dynamically creating a free-running parallel process.  A type of `join' is available by use of a `<tt>FORKING</tt>' block, that
	acts as a barrier on which forked processes synchronise.  If a <tt>FORK</tt> is not enclosed in any <tt>FORKING</tt> block, it runs freely.
</p>
<p>
	The type of <tt>FORK</tt> supported is that of a new <tt>PROC</tt> instance.  When instanced normally, <tt>PROC</tt> parameters use a <em>renaming</em> semantics.
	When <tt>FORK</tt>ed, the parameters use a <em>communication</em> semantics.  This means that non-communicable parameter types are not allowed in a <tt>FORK</tt>.
	This restriction is typically channel and reference parameters.  However, if the need <em>really</em> arises, such things can be declared `<tt>#PRAGMA SHARED</tt>' and passed
	anyway.  Any mobile type is, of course, allowed.
</p>
<p>
	The use of `<tt>FORK</tt>' is likely to be application-specific (particularly useful for building server-farms -- see
	<a href="http://www.cs.kent.ac.uk/pubs/2002/1512/">Prioritised dynamic communicating processes: Part 2</a>, <a href="publications.html">downloadable from here</a>).  A
	simple example of the <tt>FORK</tt> is:
</p>
<pre class="source">

    <span class="keyword">PROC</span> big.sum (<span class="keyword">VAL</span> []<span class="keyword">INT</span> <span class="var">data</span>)
      <span class="comment">...  spend some time processing and write results to file</span>
    :

    <span class="keyword">PRO</span>C application (<span class="keyword">CHAN BYTE</span> <span class="chan">kyb?</span>, <span class="chan">scr!</span>, <span class="chan">err!</span>)
      <span class="keyword">FORKING</span>
        <span class="keyword">MOBILE</span> []<span class="keyword">INT</span> <span class="var">data</span>:
        <span class="keyword">SEQ</span>
          <span class="comment">...  allocate and initialise `data'</span>
          <span class="keyword">FORK</span> big.sum (<span class="var">data</span>)
          <span class="comment">...  continue with application</span>
    :

</pre>
<p>
	After the <tt>FORK</tt>, `<tt>data</tt>' will remain defined.  Since the formal parameter type is `<tt>VAL []BYTE</tt>', the data will be copied locally into the <tt>FORK</tt>ed
	process, leaving the source (a mobile in this case) alone.
</p>
<p>
	Connecting a <tt>FORK</tt> process to the rest of the process network is best done using <a href="#chantypes">mobile channel types</a> or
	<a href="#anonct">anonymous channel types</a>.  For example:
</p>
<pre class="source">

    <span class="keyword">CHAN TYPE</span> FOO
      <span class="keyword">MOBILE RECORD</span>
        <span class="keyword">CHAN INT</span> <span class="chan">in?</span>:
        <span class="keyword">CHAN INT</span> <span class="chan">out!</span>:
    :

    <span class="keyword">PROC</span> server (FOO? <span class="var">link</span>)
      <span class="keyword">WHILE</span> <span class="const">TRUE</span>
        <span class="comment">...  do server stuff</span>
    :

    <span class="keyword">PROC</span> client (<span class="keyword">SHARED</span> FOO! <span class="var">link</span>)
      <span class="keyword">CLAIM</span> <span class="var">link</span>
        <span class="comment">...  do client stuff</span>
    :

    <span class="keyword">PROC</span> network ()
      FOO? <span class="var">f.s</span>:
      <span class="keyword">SHARED</span> FOO! <span class="var">f.c</span>:
      <span class="keyword">SEQ</span>
        <span class="var">f.s</span>, <span class="var">f.c</span> := <span class="keyword">MOBILE</span> FOO
        <span class="keyword">FORK</span> server (<span class="var">f.s</span>)
        <span class="keyword">SEQ</span> i = <span class="const">0</span> FOR <span class="const">10</span>
          <span class="keyword">FORK</span> client (<span class="var">f.c</span>)
        <span class="comment">...  do some other stuff</span>
    :

</pre>
<!--}}}-->
<!--{{{  MOBILE structured channel types-->
<hr />
<p />
<h2 class="tsel1 midheader"><a name="chantypes">MOBILE structured channel types</a></h2>
<p>
	<em>added 30/06/2002</em>
</p>
<p>
	Structured channel-types provide a mechanism for grouping related channels together inside a `<tt>RECORD</tt>' type.  Ordinarily, these types are declared to be <em>mobile</em>.
	This provides a mechanism for <em>moving</em> bundles of channel <em>ends</em> around inside a process network.
	Starting with an example type declaration:
</p>
<pre class="source">

    <span class="keyword">CHAN TYPE</span> FOO
      <span class="keyword">MOBILE RECORD</span>
        <span class="keyword">CHAN INT</span> <span class="chan">request?</span>:
        <span class="keyword">CHAN INT</span> <span class="chan">response!</span>:
    :

</pre>
<p>
	A channel in occam has two ends -- one for reading and one for writing.  Channel types (bundles) have two conceptual ends, termed `<em>server</em>' and `<em>client</em>'.
	<a href="#chandir">Channel direction-specifiers</a> must be used inside the channel-type declaration, so that the compiler can enforce correct
	usage on a particular end (client or server).
</p>
<p>
	Declaration and initialisation of a channel-bundle (mobile channel-type) is relatively simple.  For example, using the above declaration of `<tt>FOO</tt>':
</p>
<pre class="source">

    FOO! <span class="var">foo.c</span>:         <span class="comment">-- client end</span>
    FOO? <span class="var">foo.s</span>:         <span class="comment">-- server end</span>
    <span class="keyword">SEQ</span>
      <span class="var">foo.c</span>, <span class="var">foo.s</span> := <span class="keyword">MOBILE</span> FOO
      <span class="comment">...  processes using `foo.c' and `foo.s'</span>

</pre>
<p>
	The allocating assignment is similar to that used with dynamic mobile arrays (see the <a href="#mobiles">mobiles section</a>).  A bundle of channels is <em>dynamically</em>
	created and the two ends assigned to `<tt>foo.c</tt>' and `<tt>foo.s</tt>'.  The order in which the end-variables are given is unimportant;  what matters is that one is
	a <em>client-end</em> and the other a <em>server-end</em> of the same mobile channel type.
</p>
<p>
	The channel-ends within a channel-bundle are accessed using the familiar record subscription syntax.  For (a slightly expanded) example:
</p>
<pre class="source">

    <span class="keyword">CHAN TYPE</span> BUF.MGR
      <span class="keyword">MOBILE RECORD</span>
        <span class="keyword">CHAN INT</span> <span class="chan">request?</span>:
        <span class="keyword">CHAN MOBILE</span> []<span class="keyword">BYTE</span> <span class="chan">response!</span>:
        <span class="keyword">CHAN MOBILE</span> []<span class="keyword">BYTE</span> <span class="chan">return?</span>:
    :

    <span class="keyword">PROC</span> server (BUF.MGR? <span class="var">link</span>)
      <span class="keyword">WHILE</span> <span class="const">TRUE</span>
        <span class="keyword">INT</span> <span class="var">n</span>:
        <span class="keyword">MOBILE</span> []<span class="keyword">BYTE</span> <span class="var">b</span>:
        <span class="keyword">SEQ</span>
          <span class="var">link</span>[<span class="chan">request</span>] ? <span class="var">n</span>         <span class="comment">-- input required size</span>
          <span class="var">b</span> := <span class="keyword">MOBILE</span> [<span class="var">n</span>]<span class="keyword">BYTE</span>       <span class="comment">-- allocate buffer</span>
          <span class="keyword">SEQ</span> i = <span class="const">0</span> <span class="keyword">FOR SIZE</span> <span class="var">b</span>      <span class="comment">-- zero buffer</span>
            <span class="var">b</span>[i] := <span class="const">0</span> (<span class="keyword">BYTE</span>)
          <span class="var">link</span>[<span class="chan">response</span>] ! <span class="var">b</span>        <span class="comment">-- give to client</span>
          <span class="var">link</span>[<span class="chan">return</span>] ? <span class="var">b</span>          <span class="comment">-- take back from client</span>
    :

    <span class="keyword">PROC</span> client (BUF.MGR! <span class="chan">link</span>)
      <span class="keyword">MOBILE</span> []<span class="keyword">BYTE</span> <span class="var">buf</span>:
      <span class="keyword">SEQ</span>
        <span class="var">link</span>[<span class="chan">request</span>] ! <span class="const">1024</span>        <span class="comment">-- send request</span>
        <span class="var">link</span>[<span class="chan">response</span>] ? <span class="var">buf</span>        <span class="comment">-- get response</span>
        <span class="comment">...  use `buf'</span>
        <span class="var">link</span>[<span class="chan">return</span>] ! <span class="var">buf</span>          <span class="comment">-- return buffer</span>
    :

    <span class="keyword">PROC</span> network ()
      BUF.MGR! <span class="var">cli</span>:
      BUF.MGR? <span class="var">svr</span>:
      <span class="keyword">SEQ</span>
        <span class="var">cli</span>, <span class="var">svr</span> := <span class="keyword">MOBILE</span> BUF.MGR
        <span class="keyword">PAR</span>
          server (<span class="var">svr</span>)
          client (<span class="var">cli</span>)
    :

</pre>
<p>
	Unfortunately, an <a href="#arrayc">array constructor</a> cannot be used (at present) in the `<tt>server</tt>' process to create the array, since
	the size of an array-constructor must be a compile-time constant.
</p>
<p>
	The above `<tt>network</tt>' allocates a `<tt>BUF.MGR</tt>' channel bundle then runs client and server processes in parallel, connected by that bundle.
	Because the channel-ends are <em>mobile</em>, however, they can be communicated (and assigned).  Thus, we might `wrap' the earlier `<tt>client</tt>' and
	`<tt>server</tt>' processes such that the ends (on which to communicate with each other) are inputted first.  For example:
</p>
<pre class="source">

    <span class="keyword">PROC</span> w.server (<span class="keyword">CHAN</span> BUF.MGR? <span class="chan">link.in?</span>)
      BUF.MGR? <span class="var">link</span>:
      <span class="keyword">SEQ</span>
        <span class="chan">link.in</span> ? <span class="var">link</span>
        server (<span class="var">link</span>)
    :

    <span class="keyword">PROC</span> w.client (<span class="keyword">CHAN</span> BUF.MGR! <span class="chan">link.in?</span>)
      BUF.MGR! <span class="var">link</span>:
      <span class="keyword">SEQ</span>
        <span class="chan">link.in</span> ? <span class="var">link</span>
        client (<span class="var">link</span>)
    :

</pre>
<p>
	The modified `<tt>network</tt>' process would be:
</p>
<pre class="source">

    <span class="keyword">PROC</span> w.network ()
      <span class="keyword">CHAN</span> BUF.MGR! <span class="chan">c.cli</span>:
      <span class="keyword">CHAN</span> BUF.MGR? <span class="chan">c.svr</span>:
      <span class="keyword">PAR</span>
        w.server (<span class="chan">c.svr?</span>)
        w.client (<span class="chan">c.cli?</span>)

        BUF.MGR! <span class="var">cli</span>:
        BUF.MGR? <span class="var">svr</span>:
        <span class="keyword">SEQ</span>
          <span class="var">cli</span>, <span class="var">svr</span> := <span class="keyword">MOBILE</span> BUF.MGR
          <span class="chan">c.cli</span> ! <span class="var">cli</span>
          <span class="chan">c.svr</span> ! <span class="var">svr</span>
          <span class="comment">-- `cli' and `svr' now undefined (moved)</span>
    :

</pre>
<p>
	Although such channel-bundle ends are mobile, applying the <tt>CLONE</tt> operator (to produce a mobile copy) makes little sense -- how would access between copies be controlled ?
	or, would new server processes be automatically generated..?.
</p>
<p>
	The paradigm of a <em>shared server</em> is one that has long existed in occam -- usually controlled by <tt>ALT</tt>ing
	over multiple channels.  To capture this more effectively, channel-bundle ends may be declared `<tt>SHARED</tt>'.  This allows for four different arrangements of client/server
	connections:  single client, single server;  multiple clients, single server;  single client, multiple servers; and multiple clients with multiple servers.
</p>
<p>
	To control access to shared channel-ends, <tt>CLAIM</tt> blocks must be used.  Modifying the `<tt>client</tt>' process for example:
</p>
<pre class="source">

    <span class="keyword">PROC</span> client (<span class="keyword">SHARED</span> BUF.MGR! <span class="var">link</span>)
      <span class="keyword">CLAIM</span> <span class="var">link</span>
        <span class="keyword">MOBILE</span> []<span class="keyword">BYTE</span> <span class="var">buf</span>:
        <span class="keyword">SEQ</span>
          <span class="var">link</span>[<span class="chan">request</span>] ! <span class="const">1024</span>        <span class="comment">-- send request</span>
          <span class="var">link</span>[<span class="chan">response</span>] ? <span class="var">buf</span>        <span class="comment">-- get response</span>
          <span class="comment">...  use `buf'</span>
          <span class="var">link</span>[<span class="chan">return</span>] ! <span class="var">buf</span>          <span class="comment">-- return buffer</span>
    :

</pre>
<p>
	Parallel processes compete for access to a <tt>CLAIM</tt> block by means of a semaphore, on which they queue in FIFO order.  The rules pertaining to nested <tt>CLAIM</tt>s
	are that no nested claims are allowed inside a client-end claim, and that server claims may be nested (possibly with a client claim at the innermost point).  This prevents
	partially-aquired resource deadlock on clients, but not on servers.  Neither does it prevent cyclic deadlock.  Avoiding deadlock through the use of <tt>CLAIM</tt> is a
	program design issue.  Possible (or partial) compiler-based solutions to this are being thought about -- strict ordering and multi-claims (`<tt>CLAIM x, y</tt>') may be
	one solution.
</p>
<p>
	Inside a <tt>CLAIM</tt> block, the channel-end being <tt>CLAIM</tt>ed behaves largely as its non-shared version.  However, it may not be input or assigned to, or renamed.
	This ensures that whatever is <tt>CLAIM</tt>ed doesn't <em>move</em> (and isn't given the opportunity to through renaming -- less obvious in separate compilation).
</p>
<p>
	For shared ends, the <tt>CLONE</tt> operator is meaningful.  In fact, when dealing with shared ends, the compiler will always <tt>CLONE</tt> for assignment or communication,
	regardless of whether the `<tt>CLONE</tt>' keyword is present.  If the need ever arises to forcefully release a channel-end, it can be done by declaring it undefined to the
	compiler (that will insert code if it thinks otherwise).  For example:
</p>
<pre class="source">

    <span class="keyword">SHARED</span> FOO! <span class="var">f.c</span>:
    <span class="keyword">SHARED</span> FOO? <span class="var">f.s</span>, <span class="var">f.other</span>:
    <span class="keyword">SEQ</span>
      <span class="var">f.c</span>, <span class="var">f.s</span> := <span class="keyword">MOBILE</span> FOO
      <span class="var">f.other</span> := <span class="var">f.s</span>
      <span class="comment">-- auto-clone, `f.s' still valid</span>
      <span class="preproc">#PRAMGA UNDEFINED f.s</span>
      <span class="comment">-- `f.s' no longer defined</span>

</pre>
<p>
	The above examples show only a small amount of what can be achieved using mobile channel-types.  For a fuller analysis, see the papers
	``<a href="http://www.cs.kent.ac.uk/pubs/2002/1511/">Prioritised dynamic communicating processes: Part 1</a>'' and
	``<a href="http://www.cs.kent.ac.uk/pubs/2002/1512/">Prioritised dynamic communicating processes: Part 2</a>''.  The texts of these papers are
	available on <a href="publications.html">my publications page</a>, and also from the <a href="http://www.wotug.org/">WoTUG website</a>.
</p>
<!--}}}-->
<!--{{{  Process priority support-->
<hr />
<p />
<h2 class="tsel1 midheader"><a name="priority">Process priority support</a></h2>
<p>
	<em>added 04/02/2002</em>
</p>
<p>
	Support for 32 levels of process priority has been added to the occam system.  These range from 0 (highest
	priority) to 31 (lowest priority).  Most of the hard work related to priority handling is done in the
	run-time kernel.  In occam, priority is handled using the following compiler pre-defines:
</p>
<pre class="source">

    <span class="keyword">INT FUNCTION</span> GETPRI ()
    <span class="keyword">PROC</span> SETPRI (<span class="keyword">VAL INT</span> p)

    <span class="keyword">PROC</span> INCPRI ()
    <span class="keyword">PROC</span> DECPRI ()

</pre>
<p>
	These simply end up as calls to two new transputer instructions, `<tt>GETPRI</tt>' and `<tt>SETPRI</tt>'.
	By default, the top-level occam process starts at the highest priority (0).
</p>
<!--}}}-->
<!--{{{  PLACED channels and arrays-->
<hr />
<p />
<h2 class="tsel1 midheader"><a name="placed"><tt>PLACED</tt> channels and arrays</a></h2>
<p>
	<em>added 14/01/2002</em>
</p>
<p>
	Placed channels are what constitutes the compiler support for <em>user-defined channels</em>.  Placed arrays
	allow occam programs to use externally allocated memory.  While fairly separate in function, placed arrays
	and channels share a large amount of compiler code, thus their description together here.
</p>
<p>
	Placed channels can be defined in one of two ways:
</p>
<pre class="source">

    <span class="keyword">INT</span> <span class="var">addr</span>:
    <span class="keyword">SEQ</span>
      <span class="comment">.. get "addr" from UDC stuff</span>

      <span class="keyword">CHAN INT</span> <span class="chan">c!</span>:
      <span class="keyword">PLACE</span> <span class="chan">c!</span> <span class="keyword">AT</span> <span class="var">addr</span>:
      <span class="comment">.. process using "c" for output</span>

</pre>
<p>
	or:
</p>
<pre class="source">

    <span class="keyword">INT</span> <span class="var">addr</span>:
    <span class="keyword">SEQ</span>
      <span class="comment">.. get "addr" from UDC stuff</span>

      <span class="keyword">PLACED CHAN INT</span> <span class="chan">c!</span> <span class="var">addr</span>:
      <span class="comment">.. processing using "c" for output</span>

</pre>
<p>
	The second example demonstrates the <a href="#optof">optional <tt>OF</tt></a> and optional <tt>AT</tt>.  These
	channels are flagged as being <em>placed</em> by the compiler.  When communication is performed on these channels,
	a second set of I/O instructions is used: <tt>EXTIN</tt>, <tt>EXTOUT</tt>, <tt>EXTOUTWORD</tt>, <tt>EXTOUTBYTE</tt>,
	<tt>EXTENBC</tt> and <tt>EXTNDISC</tt>.  The operation of these is similar to the same non-<tt>EXT</tt> instructions.
	When the channel is <tt>PLACE</tt>d, the <tt>EXTVRFY</tt> instruction is generated to check the channel before using
	it for communication.
</p>
<p>
	Currently <em>not</em> supported for placed channels are <tt>MOBILE</tt> communication and extended rendezvous.  There
	is documentation on-the-way for using placed channels and some example code is provided in the KRoC/Linux distribution.
</p>
<p>
	Placed arrays allow occam programs to access external memory, much like the transputer did.  Rather than having a
	static address, the address used in the <tt>PLACE</tt>ment can be run-time computed.  Both the two-line placement and
	the single-line <tt>PLACED</tt> syntaxes are supported, for example:
</p>
<pre class="source">

    <span class="keyword">INT</span> <span class="var">addr</span>:
    <span class="keyword">SEQ</span>
      C.malloc (<span class="const">#8000</span>, <span class="var">addr</span>)      <span class="comment">-- or however</span>

      <span class="keyword">PLACED</span> [<span class="const">#8000</span>]<span class="keyword">BYTE</span> <span class="var">data</span> <span class="var">addr</span>:
      <span class="comment">.. process using "data"</span>

</pre>
<p>
	The hash character is just the occam way of specifying hexadecimal numbers.  For i386 systems, a special compiler-directive
	exists (`<tt>#PRAGMA IOSPACE</tt>') which arranges for i/o space to be used, rather than memory space.  This would
	typically be used, for example, to access the VGA registers, parallel port registers, etc., for example:
</p>
<pre class="source">

    <span class="keyword">INT</span> <span class="var">io.base</span>, <span class="var">io.size</span>:
    <span class="keyword">SEQ</span>
      <span class="var">io.base</span> := <span class="const">#378</span>          <span class="comment">-- parport0</span>
      <span class="var">io.size</span> := <span class="const">8</span>

      <span class="comment">.. get access to region with ioperm() / whatever ..</span>

      <span class="keyword">PLACED</span> [<span class="const">8</span>]<span class="keyword">BYTE</span> <span class="var">parport0</span> <span class="var">io.base</span>:
      <span class="preproc">#PRAGMA IOSPACE parport0</span>
      <span class="keyword">SEQ</span>
        <span class="keyword">BYTE</span> <span class="var">b</span>:
        <span class="var">b</span> := <span class="var">parport0</span>[<span class="const">0</span>]       <span class="comment">-- will turn into "inb" at address 0x378</span>

</pre>
<p>
	<strong>Note:</strong> because placed channels and arrays allow access to memory outside the normal workspace/vectorspace,
	there is a high degree of risk associated with using them.  That is, if a bad address is supplied to the <tt>PLACE</tt>,
	undefined behavior may result.
</p>
<!--}}}-->
<!--{{{  Modified ALT disabling sequence-->
<hr />
<p />
<h2 class="tsel1 midheader"><a name="revalt">Modified <tt>ALT</tt> disabling sequence</a></h2>
<p>
	<em>added 10/01/2002</em>
</p>
<p>
	The ALT disabling sequence has been modified to perform a reverse disable in the case of ``<tt>PRI ALT</tt>''s,
	and a reversed ``<tt>PRI ALT</tt>'' in the case of plain ``<tt>ALT</tt>''s.
</p>
<p>
	Three new instructions have been added to the instruction set which are now used in place of the three
	existing alternative-disable instructions (``<tt>DISC</tt>'', ``<tt>DIST</tt>'' and ``<tt>DISS</tt>'').
	These new instructions behave differently in that the guard will always be selected if it is ready,
	rather than being selected if it is ready and nothing had been ready previously, which was the default
	behavior with ``<tt>DISC</tt>'', etc.  These new instructions are called ``<tt>NDISC</tt>'', ``<tt>NDIST</tt>''
	and ``<tt>NDISS</tt>''.  The input and output registers used are the same as the existing ones.
</p>
<p>
	For example, the code:
</p>
<pre class="source">

    <span class="keyword">ALT</span>
      <span class="chan">a</span> ? <span class="var">x</span>
        P
      <span class="chan">b</span> ? <span class="var">y</span>
        Q
      <span class="chan">c</span> ? <span class="var">z</span>
        R

</pre>
<p>
	will enable ``a'', ``b'' and ``c'' in that order, do the alternative wait if none were ready, then
	disable in the same sequence using the ``<tt>NDISC</tt>'' instruction.  If ``c'' is ready, it will be
	be selected, since it is the last guard examined in the disable sequence, regardless of whether ``a''
	and/or ``b'' were ready.  The ``<tt>PRI ALT</tt>'' is handled in a similar way, except that the guards
	are examined in reverse.  For example:
</p>
<pre class="source">

    <span class="keyword">PRI ALT</span>
      <span class="chan">a</span> ? <span class="var">x</span>
        P
      <span class="chan">b</span> ? <span class="var">y</span>
        Q
      <span class="chan">c</span> ? <span class="var">z</span>
        R

</pre>
<p>
	will have the guards disabled in the order ``c'', ``b'' then ``a''.  Thus, if ``a'' is ready, it will
	be selected regardless of whether ``b'' and/or ``c'' were ready.
</p>
<p>
	For the most part, correct programs will run as they did.  Programs which assume a ``<tt>PRI ALT</tt>''
	for a regular ``<tt>ALT</tt>'' may behave incorrectly.  There are some cases where this might not be
	immediately obvious though, for example:
</p>
<pre class="source">

    <span class="keyword">TIMER</span> tim:
    <span class="keyword">INT</span> <span class="var">t</span>:
    <span class="keyword">BOOL</span> <span class="var">got.first</span>:
    <span class="keyword">SEQ</span>
      <span class="var">got.first</span> := <span class="const">FALSE</span>
      tim ? <span class="var">t</span>
      <span class="keyword">ALT</span>
        tim ? <span class="keyword">AFTER</span> (<span class="var">t</span> <span class="keyword">PLUS</span> <span class="const">10000</span>)
          <span class="var">got.first</span> := <span class="const">TRUE</span>
        tim ? <span class="keyword">AFTER</span> (<span class="var">t</span> <span class="keyword">PLUS</span> <span class="const">20000</span>)
          <span class="keyword">IF</span>
            <span class="var">got.first</span>
              <span class="keyword">SKIP</span>

</pre>
<p>
	will often find itself going ``<tt>STOP</tt>'', when ``<tt>got.first</tt>'' is false in the <tt>IF</tt> (last 3 lines).
	This is because a fine-grained timer is not guaranteed with the current run-time system (KRoC/Linux), if you ask to sleep
	for 10ms, it might be after 20ms when you wake up.  In the old <tt>ALT</tt> disabling sequence, the first guard would
	always be selected, since the ``<tt>DIST</tt>'' on the second would not select that process.  ``<tt>NDIST</tt>'' will
	select the second process, if that time has expired.
</p>
<!--}}}-->
<!--{{{  Extended rendezvous-->
<hr />
<p />
<h2 class="tsel1 midheader"><a name="extin">Extended rendezvous</a></h2>
<p>
	<em>added 19/12/2001</em>
</p>
<p>
	The extended rendezvous allows an inputting process to specify a process which will be executed after
	the communication has been performed, but before the outputting process resumes.  The syntax for these
	uses the double question-mark ``<tt>??</tt>'', for example, a simple echoing program might look like:
</p>
<pre class="source">

    <span class="keyword">PROC</span> echoing (<span class="keyword">CHAN BYTE</span> <span class="chan">kyb?</span>, <span class="chan">scr!</span>, <span class="chan">err!</span>)
      <span class="keyword">WHILE</span> <span class="const">TRUE</span>
        <span class="keyword">BYTE</span> <span class="var">b</span>:
        <span class="chan">kyb</span> ?? <span class="var">b</span>
          <span class="chan">scr</span> ! <span class="var">b</span>
          <span class="chan">scr</span> ! <span class="const">#FF</span>   <span class="comment">-- flush</span>
    :

</pre>
<p>
	Indented under the extended input ``<tt>??</tt>'' are two processes.  The first (<em>during process</em>) is
	the one executed before the outputting process continues;  the second (<em>after process</em>) is the one
	executed <em>after</em> the outputting process has resumed.  This second process may be missing,
	in which case `<tt>SKIP</tt>' is assumed.  The <em>during</em> process may not engage in the extended
	event (`<tt>kyb</tt>' channel in the above example) since this would cause deadlock.  The compiler checks
	for this.
</p>
<p>
	Tagged protocol channels are handled using a slightly different syntax (since we want <em>during</em> and
	<em>after</em> processes for each variant).  For example:
</p>
<pre class="source">

    <span class="keyword">PROTOCOL</span> TAGGED
      <span class="keyword">CASE</span>
        empty
        num; <span class="keyword">INT</span>
    :

    <span class="keyword">PROC</span> foo (<span class="keyword">CHAN</span> TAGGED <span class="chan">in?</span>, <span class="keyword">CHAN BYTE</span> <span class="chan">out!</span>)
      <span class="keyword">WHILE</span> <span class="const">TRUE</span>
        <span class="keyword">SEQ</span>
          <span class="comment">..</span>
          <span class="chan">in</span> ?? <span class="keyword">CASE</span>
            empty
              <span class="chan">out</span> ! <span class="const">'**'</span>
            <span class="keyword">INT</span> <span class="var">n</span>:
            num; <span class="var">n</span>
              <span class="chan">out</span> ! <span class="keyword">BYTE</span> (<span class="var">num</span> /\ <span class="const">#FF</span>)
              <span class="chan">out</span> ! <span class="const">'**'</span>
          ..
    :

</pre>
<!--}}}-->
<!--{{{  RESULT parameters and abbreviations-->
<hr />
<p />
<h2 class="tsel1 midheader"><a name="result"><tt>RESULT</tt> parameters and abbreviations</a></h2>
<p>
	<em>added 18/12/2001</em>
</p>
<p>
	As per the occam-3 specification, parameters and abbreviations may be declared
	with the <tt>RESULT</tt> `prefix'.  The primary purpose of these is to provide
	more information to the compiler, so it can check that parameters are defined
	when <tt>PROC</tt>s return, and that <tt>RESULT</tt> abbreviations are left
	defined when they go out of scope.
</p>
<p>
	Syntactically, the <tt>RESULT</tt> occurs where one might park a <tt>VAL</tt>,
	for example:
</p>
<pre class="source">

    <span class="keyword">PROC</span> fac (<span class="keyword">VAL INT</span> n, <span class="keyword">RESULT INT</span> <span class="var">v</span>)
      <span class="keyword">SEQ</span>
        <span class="comment">...</span>
        <span class="var">v</span> := <span class="comment">...</span>
    :

    <span class="keyword">PROC</span> thing (<span class="comment">...</span>)
      <span class="keyword">INT</span> <span class="var">v</span>:
      <span class="keyword">SEQ</span>
        <span class="comment">...</span>
        <span class="keyword">RESULT INT</span> <span class="var">i</span> <span class="keyword">IS</span> <span class="var">v</span>:
        fac (<span class="const">6</span>, <span class="var">i</span>)
    :

</pre>
<p>
	Two different implementations of <tt>RESULT</tt> abbreviations are supported.  The first, and default,
	treats the abbreviation as one without the <tt>RESULT</tt> keyword, but performs the additional check
	(for <em>definedness</em>) when the variable leaves scope, e.g.:
</p>
<pre class="source">

    <span class="keyword">RESULT</span> TYPE <span class="var">a</span> <span class="keyword">IS</span> <span class="var">v</span>:
    P

</pre>
<p>
	becomes:
</p>
<pre class="source">

    TYPE <span class="var">a</span> <span class="keyword">IS</span> <span class="var">v</span>:
    <span class="keyword">SEQ</span>
      P
      <span class="comment">-- checks that `a' is defined</span>

</pre>
<p>
	The second implementation, selected with the `<tt>-zrv</tt>' compiler flag generates a fresh variable then
	assigns into it.  From the above:
</p>
<pre class="source">

    TYPE <span class="var">anon</span>:
    <span class="keyword">SEQ</span>
      TYPE <span class="var">a</span> <span class="keyword">IS</span> <span class="var">anon</span>:
      P
      <span class="comment">-- checks that `a' is defined</span>
      <span class="var">v</span> := <span class="var">anon</span>

</pre>
<p>
	Although probably rare, there are cases where this second transformation will ultimately result in more
	efficient code, especially if `<tt>v</tt>' is large and non-local (accessed through the static-link).
</p>
<!--}}}-->
<!--{{{  Nested PROTOCOL definitions-->
<hr />
<p />
<h2 class="tsel1 midheader"><a name="nproto">Nested <tt>PROTOCOL</tt> definitions</a></h2>
<p>
	<em>added 12/12/2001</em>
</p>
<p>
	Nested <tt>PROTOCOL</tt>s allow one <tt>PROTOCOL</tt> definition to be used within another.  For example:
</p>
<pre class="source">

    <span class="keyword">PROTOCOL</span> simple <span class="keyword">IS INT</span>:
    <span class="keyword">PROTOCOL</span> seq.proto <span class="keyword">IS INT</span>; <span class="keyword">INT</span>; simple:
    <span class="keyword">PROTOCOL</span> seq.other <span class="keyword">IS BYTE</span>; seq.proto; <span class="keyword">INT</span>::[]<span class="keyword">BYTE</span>
    <span class="keyword">PROTOCOL</span> similar <span class="keyword">IS</span> seq.other:

</pre>
<p>
	In the above, `<tt>seq.other</tt>' has the structure ``<tt>BYTE; INT; INT; INT; INT::[]BYTE</tt>''.
	It should be noted that `<tt>similar</tt>' and `<tt>seq.other</tt>' are still distinct <tt>PROTOCOL</tt>s.
</p>
<p>
	Tagged protocols can also be used, for example:
</p>
<pre class="source">

    <span class="keyword">PROTOCOL</span> tagged
      <span class="keyword">CASE</span>
        empty
        int; <span class="keyword">INT</span>
        data; <span class="keyword">BYTE</span>; similar; <span class="keyword">INT16</span>
    :

    <span class="keyword">PROTOCOL</span> more.tags
      <span class="keyword">CASE</span>
        <span class="keyword">FROM</span> tagged
        flibble; seq.proto
    :

</pre>
<!--}}}-->
<!--{{{  Modified behaviour for SKIP in ALTs-->
<hr />
<p />
<h2 class="tsel1 midheader"><a name="altskips">Modified behavior for <tt>SKIP</tt> in <tt>ALT</tt>s</a></h2>
<p>
	<em>added 10/12/2001</em>
</p>
<p>
	The checking of <tt>SKIP</tt> guards in <tt>ALT</tt>s and <tt>PRI ALT</tt>s has been modified.  For `<tt>ALT</tt>'
	processes, the absence of a ``<tt>exp &amp;</tt>'' pre-condition on a ``<tt>SKIP</tt>'' will result in a warning.
	If the `<tt>-strict</tt>' option is used, non-pre-conditioned `<tt>SKIP</tt>'s will generate errors (as was the
	default behavior).  This code, for example:
</p>
<pre class="source">

    <span class="keyword">PROC</span> wibble (<span class="keyword">CHAN INT</span> <span class="chan">in.0?</span>, <span class="chan">in.1?</span>, <span class="chan">out!</span>)
      <span class="keyword">INT</span> <span class="var">v</span>:
      <span class="keyword">ALT</span>
        <span class="chan">in.0</span> ? <span class="var">v</span>
          <span class="chan">out</span> ! <span class="var">v</span>
        <span class="keyword">SKIP</span>
          <span class="chan">out</span> ! <span class="const">0</span>
        <span class="chan">in.1</span> ? <span class="var">v</span>
          <span class="chan">out</span> ! <span class="var">v</span>
    :

</pre>
<p>
	will generate a warning about the non-pre-conditioned <tt>SKIP</tt> (or error with `<tt>-strict</tt>').  For
	`<tt>PRI ALT</tt>'s, a non-pre-conditioned <tt>SKIP</tt> guard is allowed, but only as the last (or only)
	guard.  The following is a valid example:
</p>
<pre class="source">

    <span class="keyword">PROC</span> wibble2 (<span class="keyword">CHAN INT</span> <span class="chan">in.0?</span>, <span class="chan">out!</span>)
      <span class="keyword">PRI ALT</span>
        <span class="keyword">INT</span> <span class="var">v</span>:
        <span class="chan">in.0</span> ? <span class="var">v</span>
          <span class="chan">out</span> ! <span class="var">v</span>
        <span class="keyword">SKIP</span>
          <span class="chan">out</span> ! (<span class="const">-1</span>)
    :

</pre>
<!--}}}-->
<!--{{{  Recursion in occam-->
<hr />
<p />
<h2 class="tsel1 midheader"><a name="recursion">Recursion in occam</a></h2>
<p>
	<em>added 30/11/2001</em>
</p>
<p>
	On the theme of dynamic occam, recursion has now been implemented.  This is still fairly basic and
	there are several restrictions:
</p>
<ul>
	<li>Only PROCs can be recursive</li>
	<li>Only self-recursion is allowed</li>
</ul>
<p>
	Recursive <tt>PROC</tt>s are declared by adding the ``<tt>RECURSIVE</tt>'' or ``<tt>REC</tt>'' keyword
	to the procedure header.  Here is an example:
</p>
<pre class="source">

    <span class="keyword">REC PROC</span> thing (<span class="keyword">VAL INT</span> c, <span class="keyword">CHAN BYTE</span> <span class="chan">out!</span>)
      <span class="keyword">SEQ</span>
        out.string (<span class="const">"Hello world at "</span>, <span class="const">0</span>, <span class="chan">out!</span>)
        out.int (c, <span class="const">0</span>, <span class="chan">out!</span>)
        <span class="chan">out</span> ! <span class="const">'*n'</span>
        <span class="keyword">IF</span>
          c = <span class="const">0</span>
            <span class="keyword">SKIP</span>
          <span class="const">TRUE</span>
            thing (c - <span class="const">1</span>, <span class="chan">out!</span>)
    :

</pre>
<p>
	This example is actually slightly silly, since we could do tail-call optimisation, thus removing the
	recursion.  This optimisation has not been implemented yet however.
</p>
<!--}}}-->
<!--{{{  STEP in replicators-->
<hr />
<p />
<h2 class="tsel1 midheader"><a name="step"><tt>STEP</tt> in replicators</a></h2>
<p>
	<em>added 14/11/2000</em>
</p>
<p>
	The ability to have STEP in replicators has been added to the compiler.
	This allows the addition of ``<tt>STEP</tt> <em>n</em>'' to replicator expressions of (<tt>SEQ</tt>,
	<tt>PAR</tt>, <tt>ALT</tt> and <tt>IF</tt>).  For example:
</p>
<pre class="source">

    <span class="keyword">SEQ</span> i = <span class="const">0</span> <span class="keyword">FOR</span> <span class="const">5</span> <span class="keyword">STEP</span> <span class="const">2</span>
      foo (i)

</pre>
<p>
	is equivalent to:
</p>
<pre class="source">

    <span class="keyword">SEQ</span>
      foo (<span class="const">0</span>)
      foo (<span class="const">2</span>)
      foo (<span class="const">4</span>)
      foo (<span class="const">6</span>)
      foo (<span class="const">8</span>)

</pre>
<p>
	The <tt>STEP</tt> expression is evaluated before the replication, and may be any
	valid occam expression (including <tt>VALOF</tt> expressions) in <tt>SEQ</tt>, <tt>ALT</tt> and <tt>IF</tt>
	replications.  For <tt>PAR</tt>allel replicators, the <tt>STEP</tt> expression must be
	constant.
</p>
<p>
	For efficiency, three loop-end (<tt>LEND</tt>) instructions are provided.  One
	is for a <tt>STEP</tt> of 1, another for a <tt>STEP</tt> of -1, and a final one for
	arbitrary <tt>STEP</tt>s.  For instance, having:
</p>
<pre class="source">

    <span class="keyword">PRI ALT</span> i = <span class="const">4</span> <span class="keyword">FOR</span> <span class="const">5</span> <span class="keyword">STEP</span> <span class="const">-1</span>
      <span class="comment">...</span>

</pre>
<p>
	is no more expensive than having:
</p>
<pre class="source">

     <span class="keyword">PRI ALT</span> i = <span class="const">0</span> <span class="keyword">FOR</span> <span class="const">5</span>
       <span class="comment">...</span>

</pre>
<p>
	or
</p>
<pre class="source">

     <span class="keyword">PRI ALT</span> i = <span class="const">0</span> <span class="keyword">FOR</span> <span class="const">5</span> <span class="keyword">STEP</span> <span class="const">1</span>
       <span class="comment">...</span>

</pre>
<!--}}}-->
<!--{{{  Channel direction specifiers-->
<hr />
<p />
<h2 class="tsel1 midheader"><a name="chandir">Channel direction specifiers</a></h2>
<p>
	<em>added 23/10/2001</em>
</p>
<p>
	The direction of communication on channel parameters to <tt>PROC</tt>s can
	now be specified in their formal and actual parameters.  The compiler will
	bear this in mind when checking the channel usage inside a <tt>PROC</tt>.
	It also adds more information to a <tt>PROC</tt>s interface from the code
	perspective.  For example:
</p>
<pre class="source">

    <span class="keyword">PROC</span> foo (<span class="keyword">CHAN INT</span> <span class="chan">in?</span>, <span class="chan">out!</span>, <span class="keyword">CHAN BOOL</span> <span class="chan">terminate?</span>)
      <span class="comment">...</span>
    :

</pre>
<p>
	and:
</p>
<pre class="source">

    <span class="keyword">CHAN INT</span> <span class="chan">c</span>:
    <span class="keyword">PAR</span>
      foo (<span class="chan">c?</span>, <span class="comment">...</span>)
      other (<span class="chan">c!</span>)

</pre>
<p>
	The usage of this also applies to channel abbreviations, for example:
</p>
<pre class="source">

    <span class="keyword">PROC</span> foo.2 ([<span class="const">8</span>]<span class="keyword">CHAN INT64</span> <span class="chan">in?</span>, <span class="keyword">CHAN INT64</span> <span class="chan">out!</span>)
      <span class="comment">...</span>
      <span class="keyword">CHAN INT</span> <span class="chan">r?</span> <span class="keyword">IS</span> <span class="chan">in</span>[<span class="var">i</span>]?:
      <span class="comment">...</span>
    :

</pre>
<p>
	the compiler will check that output channels are not abbreviated as input channels and visa-versa.
</p>
<p>
	In <em>strict</em> mode (using the ``<tt>-s</tt>'' flag to <tt>kroc</tt>), usage of channel-direction specifiers
	is enforced.
</p>
<p>
	When referring to array slices, the direction specifier should go inside with the array, eg:
</p>
<pre class="source">

    <span class="keyword">PROC</span> thing ([]<span class="keyword">CHAN INT</span> <span class="chan">in?</span>)
      []<span class="keyword">CHAN INT</span> <span class="chan">i?</span> <span class="keyword">IS</span> [<span class="chan">in?</span> <span class="keyword">FROM</span> <span class="const">2</span>]:
      <span class="comment">...</span>
    :

</pre>
<!--}}}-->
<!--{{{  Optional OF-->
<hr />
<p />
<h2 class="tsel1 midheader"><a name="optof">Optional <tt>OF</tt></a></h2>
<p>
	<em>added 23/10/2001</em>
</p>
<p>
	The usage of the ``<tt>OF</tt>'' keyword in channel specifiers is also optional now.  For example:
</p>
<pre class="source">

    <span class="keyword">PROC</span> bar (<span class="keyword">CHAN INT</span> <span class="var">in?</span>, <span class="var">out!</span>)
      <span class="comment">...</span>
      <span class="chan">out</span> ! <span class="const">42</span>
      <span class="comment">...</span>
    :

    <span class="keyword">PROC</span> switch ([<span class="const">2</span>]<span class="keyword">CHAN INT</span> <span class="chan">in?</span>, <span class="chan">out!</span>)
      <span class="comment">...</span>
    :

</pre>
<!--}}}-->
<!--{{{  Array constructors-->
<hr />
<p />
<h2 class="tsel1 midheader"><a name="arrayc">Array constructors</a></h2>
<p>
	<em>added 08/10/2001</em>
</p>
<p>
	Array constructors allow arrays to be created using a replicator and
	an expression.  An example of this is:
</p>
<pre class="source">

    [<span class="const">10</span>]<span class="keyword">INT</span> <span class="var">array</span>:
    <span class="keyword">SEQ</span>
      <span class="comment">...</span>
      <span class="var">array</span> := [i = <span class="const">0</span> <span class="keyword">FOR SIZE</span> <span class="var">array</span> | f(i)]
      <span class="comment">...</span>

</pre>
<p>
	where `<em>f()</em>' is some expression, which might or might not involve `<em>i</em>'.
</p>
<p>
	Internally, the array constructor is turned into a <tt>VALOF</tt> process,
	so array-constructors may be used as parameters, or anywhere an
	expression is valid.  The (obvious) limitation here is that array-constructors
	may not cause side-effects.  The non-obvious limitation is that the <em>count</em>
	must be a compiler-known constant.  This will be fixed at some point in the near
	future.  The <tt>STEP</tt> addition
	may also be used in array constructors.  The general syntax for this
	type of expression is:
</p>
<pre>
    "[" <em>&lt;repl&gt;</em> "=" <em>&lt;start&gt;</em> "FOR" <em>&lt;count&gt;</em> [ "STEP" <em>&lt;stride&gt;</em> ] "|" <em>&lt;expr&gt;</em> "]"
</pre>
<p>
	The line can be broken after the ``<tt>|</tt>'' to avoid things getting to long.
	A more extreme example of array constructors might be:
</p>
<pre class="source">

    <span class="keyword">PROC</span> show.3d (<span class="keyword">VAL</span> [][][]<span class="keyword">INT</span> n, <span class="comment">...</span>)
      <span class="comment">...</span>
    :

    <span class="comment">...</span>
    <span class="keyword">SEQ</span>
      show.3d ([x = <span class="const">0</span> <span class="keyword">FOR</span> <span class="const">10</span> | [y = <span class="const">0</span> <span class="keyword">FOR</span> <span class="const">10</span> | [z = <span class="const">0</span> <span class="keyword">FOR</span> <span class="const">10</span> |
               ((x - z) * (y + z)) ]]])
      <span class="comment">...</span>

</pre>
<p>
	<tt>INITIAL</tt> declarations now permit these to be used with dynamic <tt>MOBILE</tt> arrays.  For example:
</p>
<pre class="source">

    <span class="keyword">INITIAL MOBILE</span> []<span class="keyword">INT</span> <span class="var">x</span> <span class="keyword">IS</span> [i = <span class="const">0</span> <span class="keyword">FOR</span> <span class="const">100</span> | foo(i)]:
    <span class="comment">...</span>

</pre>
<!--}}}-->
<!--{{{  Variable replicated PARs-->
<hr />
<p />
<h2 class="tsel1 midheader"><a name="npar">Variable replicated <tt>PAR</tt>s</a></h2>
<p>
	<em>added 01/10/2001</em>
</p>
<p>
	This new feature allows for <tt>PAR</tt> replicators to have a variable count
	field.  This uses the dynamic memory support provided by the run-time
	system.  A simple example of this is:
</p>
<pre class="source">

    <span class="keyword">PROC</span> foo (<span class="keyword">CHAN INT</span> <span class="chan">in?</span>)
      <span class="keyword">INT</span> <span class="var">count</span>:
      <span class="keyword">SEQ</span>
        <span class="chan">in</span> ? <span class="var">count</span>
        <span class="keyword">PAR</span> i = <span class="const">0</span> <span class="keyword">FOR</span> <span class="var">count</span>
          some.process (i)
    :

</pre>
<p>
	In order to help support this, dynamic <tt>MOBILE []CHAN</tt> arrays are allowed,
	but <em>no checking</em> is performed on them when used with a replicated <tt>PAR</tt>.
	Run-time checking will probably be added at some point.
</p>
<p>
	An example of this type of usage (to build a pipeline of processes) is:
</p>
<pre class="source">

    <span class="keyword">PROC</span> sort.pump (<span class="keyword">VAL INT</span> size, <span class="keyword">CHAN INT</span> <span class="chan">in?</span>, <span class="chan">out!</span>)
      <span class="keyword">IF</span>
        size &gt; <span class="const">1</span>
          <span class="keyword">INITIAL MOBILE</span> []<span class="keyword">CHAN INT</span> <span class="chan">pipe</span> <span class="keyword">IS MOBILE</span> [size - <span class="const">1</span>]<span class="keyword">CHAN INT</span>:
          <span class="keyword">PAR</span>
            sort.cell (<span class="chan">in</span>, <span class="chan">pipe</span>[<span class="const">0</span>])
            <span class="keyword">PAR</span> i = <span class="const">0</span> <span class="keyword">FOR</span> (size - <span class="const">2</span>)
              sort.cell (<span class="chan">pipe</span>[i], <span class="chan">pipe</span>[i+<span class="const">1</span>])
            sort.cell (<span class="chan">pipe</span>[size-<span class="const">2</span>], <span class="chan">out</span>)
        <span class="const">TRUE</span>
          sort.cell (<span class="chan">in</span>, <span class="chan">out</span>)
    :

</pre>
<!--}}}-->
<!--{{{  MOBILE data types-->
<hr />
<p />
<h2 class="tsel1 midheader"><a name="mobiles"><tt>MOBILE</tt> data types</a></h2>
<p>
	<em>added 08/09/2001</em>
</p>
<p>
	Mobiles are a new <em>type class</em> in occam -- i.e. for most ordinary types, a compatible <em>mobile</em> version now exists.
	Mobiles are different in one key way: assignment and communication of mobiles uses a <em>movement</em> semantics, instead of the usual <em>copying</em>
	semantics.  This implies that when a process outputs a mobile variable, it <em>loses</em> it -- and any subsequent attempt to <em>read</em> from the variable
	is undefined (illegal).
</p>
<p>
	To the programmer, mobiles offer a potential performance gain, with only minor intrusion to code.  The run-time system (on a single-memory machine) implements
	mobiles by pointer-swapping references, that is a very low-cost operation (mobile commstime is around 20ns more than the ordinary commstime).  More importantly,
	however, mobiles provide an efficient means to implement the familiar ``packet passing'' abstraction (in the past, occam programs have <em>moved</em> pointers
	around at run-time, for efficiency, but this was wholly un-checked and required the use of in-line assembler).
</p>
<p>
	Essentially, two basic types of mobile variables are supported:
</p>
<ul>
	<li>Static mobiles, whose size is known at compile-time</li>
	<li>Dynamic mobile arrays, whose size is only known at run-time</li>
</ul>
<p>
	Static mobiles are allocated (by the compiler) into a global memory `heap' known as <em>mobilespace</em>.  Like workspace and vectorspace, the required
	size of this area is known at compile-time.  Dynamic process creation (<a href="#recursion">recursion</a>, <a href="#npar">variable replicated <tt>PAR</tt>s</a>,
	and <a href="#forking">forked processes</a>) complicates this slightly.  For mobilespace requiring dynamic processes, <em>hooks</em>
	are allocated inside the enclosing mobilespace.  Once dynamic memory has been allocated for mobilespace, it cannot be returned to the general memory pool --
	since references inside mobilespace may have migrated into other processes.  More details on the technical aspects of mobilespace can be found in the
	`<em><a href="http://www.cs.kent.ac.uk/pubs/2001/1295/index.html">Mobile Data, Dynamic Allocation and Zero Aliasing: an occam Experiment</a></em>' paper.
</p>
<p>
	Dynamic mobile arrays are somewhat simpler, since they are largely run-time only -- but incur a greater overhead for allocation/release than static mobiles
	(tens of nano-seconds).
</p>
<p>
	Mobile variables can be declared in two ways: using the `<tt>MOBILE</tt>' keyword directly in the declaration; or declaring variables of a named `<tt>MOBILE</tt>' type.
	The first, for example:
</p>
<pre class="source">

    <span class="keyword">MOBILE INT</span> <span class="var">x</span>, <span class="var">y</span>:
    <span class="keyword">SEQ</span>
      <span class="var">x</span> := <span class="const">42</span>
      <span class="var">y</span> := <span class="var">x</span>
      <span class="comment">-- `x' now undefined</span>


    <span class="keyword">MOBILE</span> []<span class="keyword">REAL64</span> <span class="var">data</span>:
    <span class="keyword">SEQ</span>
      <span class="var">data</span> := <span class="keyword">MOBILE</span> [<span class="const">128</span>]<span class="keyword">REAL64</span>
      <span class="var">data</span>[<span class="const">42</span>] := <span class="const">99.0</span>

</pre>
<p>
	The first fragment declares two simple mobile integers.  The second is slightly more interesting, requiring a special <em>allocation</em> assignment to create the
	array.  Until they are allocated, dynamic mobile arrays have zero-size and are considered to be undefined (as far as the undefinedness checker is concerned).  Any
	attempt to access a non-existant element will result in the usual run-time (range) error.
</p>
<p>
	Communication behaves in much the same way as assignment, for example:
</p>
<pre class="source">

    <span class="keyword">CHAN MOBILE</span> []<span class="keyword">INT</span> <span class="chan">vals</span>:
    <span class="keyword">PAR</span>
      <span class="comment">--{{{  producer</span>
      <span class="keyword">MOBILE</span> []<span class="keyword">INT</span> <span class="var">x</span>:
      <span class="keyword">SEQ</span>
        <span class="var">x</span> := <span class="keyword">MOBILE</span> [<span class="const">10</span>]<span class="keyword">INT</span>
        <span class="keyword">SEQ</span> i = <span class="const">0</span> <span class="keyword">FOR SIZE</span> <span class="var">x</span>
          <span class="var">x</span>[i] := i
        <span class="chan">c</span> ! <span class="var">x</span>
        <span class="comment">-- `x' is no longer defined</span>
      <span class="comment">--}}}</span>
      <span class="comment">--{{{  consumer</span>
      <span class="keyword">MOBILE</span> []<span class="keyword">INT</span> <span class="var">v</span>:
      <span class="keyword">INT</span> <span class="var">x</span>:
      <span class="keyword">SEQ</span>
        <span class="chan">c</span> ? <span class="var">v</span>
        <span class="var">x</span> := <span class="var">v</span>[<span class="const">5</span>]
      <span class="comment">--}}}</span>

</pre>
<p>
	As far as type compatability goes: wherever a non-mobile variable is valid, its mobile equivalent is valid too.  For example:
</p>
<pre class="source">

    <span class="keyword">MOBILE REAL64</span> <span class="var">m.v</span>:
    <span class="keyword">REAL64</span> <span class="var">s.v</span>:
    <span class="keyword">SEQ</span>
      <span class="var">m.v</span> := <span class="const">24.5</span> (<span class="keyword">REAL64</span>)
      <span class="var">s.v</span> := <span class="var">m.v</span>
      <span class="comment">-- m.v still valid (copy)</span>

</pre>
<p>
	Assignment is only considered mobile if both variables (LHS and RHS) are themselves mobile -- i.e. mixed mobile/non-mobile assignment
	results in the usual copy semantics.  Communication is only mobile if the channel protocol is mobile.  The following, for example,
	uses non-mobile communication:
</p>
<pre class="source">

    <span class="keyword">CHAN</span> [<span class="const">5</span>]<span class="keyword">INT</span> <span class="chan">c</span>:
    <span class="keyword">PAR</span>
      <span class="comment">--{{{  producer</span>
      <span class="keyword">MOBILE</span> [<span class="const">5</span>]<span class="keyword">INT</span> <span class="var">x</span>:
      <span class="keyword">SEQ</span>
        <span class="keyword">SEQ</span> i = <span class="const">0</span> <span class="keyword">FOR SIZE</span> <span class="var">x</span>
          <span class="var">x</span>[i] := i
        <span class="chan">c</span> ! <span class="var">x</span>
        <span class="comment">-- `x' is still defined</span>
      <span class="comment">--}}}</span>
      <span class="comment">--{{{  consumer</span>
      <span class="keyword">MOBILE</span> [<span class="const">5</span>]<span class="keyword">INT</span> <span class="var">v</span>:
      <span class="keyword">INT</span> <span class="var">x</span>:
      <span class="keyword">SEQ</span>
        <span class="chan">c</span> ? <span class="var">v</span>
        <span class="var">x</span> := <span class="var">v</span>[<span class="const">5</span>]
      <span class="comment">--}}}</span>

</pre>
<p>
	Changing the channel declaration to `<tt>CHAN MOBILE [5]INT c:</tt>' would, as expected, result in mobile communication.  This is static
	mobile communication, however, since the size of `<tt>[5]INT</tt>' is known at compile-time.
</p>
<p>
	When a non-mobile variable is used in mobile communication or assignment, the compiler automatically <em>promotes</em> the variable to its
	mobile equivalent.  For dynamic mobile arrays, this includes automatic allocation of the array, making the programmer's life somewhat easier.
</p>
<p>
	The second method of declaring mobiles involves declaring mobile types.  For example:
</p>
<pre class="source">

    <span class="keyword">DATA TYPE</span> STRING <span class="keyword">IS MOBILE</span> []<span class="keyword">BYTE</span>:

    <span class="keyword">DATA TYPE</span> PACKET
      <span class="keyword">MOBILE RECORD</span>
        [<span class="const">1024</span>]<span class="keyword">BYTE</span> data:
        <span class="keyword">INT</span> offset:
    :

</pre>
<p>
	Then using that type as usual.  For example, and demonstrating automatic mobile promotion:
</p>
<pre class="source">

    STRING <span class="var">s</span>:
    PACKET <span class="var">p</span>:
    <span class="keyword">SEQ</span>
      <span class="var">s</span> := <span class="const">"hello, occam world!*n"</span>
      [<span class="var">p</span>[data] <span class="keyword">FOR SIZE</span> <span class="var">s</span>] := <span class="var">s</span>
      <span class="var">p</span>[offset] := <span class="keyword">SIZE</span> <span class="var">s</span>

</pre>
<p>
	The <a href="#arrayc">array constructor</a> may also be used with dynamic mobile arrays and automatic promotion.  For example:
</p>
<pre class="source">

    <span class="keyword">CHAN MOBILE</span> []<span class="keyword">REAL64</span> <span class="chan">c</span>:
    <span class="keyword">PAR</span>
      <span class="comment">--{{{  producer</span>
      <span class="chan">c</span> ! [i = <span class="const">0</span> <span class="keyword">FOR</span> <span class="const">128</span> | ((<span class="keyword">REAL64</span> i) * PI) / <span class="const">128.0</span>]
      <span class="comment">--}}}</span>
      <span class="comment">--{{{  consumer</span>
      <span class="keyword">MOBILE</span> []<span class="keyword">REAL64</span> <span class="var">data</span>:
      <span class="keyword">SEQ</span>
        <span class="chan">c</span> ? <span class="var">data</span>
        <span class="comment">...  use `data'</span>
      <span class="comment">--}}}</span>

</pre>
<p>
	In some cases, it may be desirable to prevent mobile assignment or communication, where movement semantics are the default.
	This is done through use of the `<tt>CLONE</tt>' <em>operator</em>, that produces a duplicate of its mobile argument.  The
	compiler will not automatically promote a non-mobile operand given to <tt>CLONE</tt>, thus `<tt>CLONE 5</tt>' is illegal.
	The <tt>CLONE</tt> operator also helps resolve potential ambiguities.  The following fragment, for example, leaves `<tt>x</tt>' and `<tt>y</tt>' both
	defined:
</p>
<pre class="source">

    <span class="keyword">MOBILE INT</span> <span class="var">x</span>, <span class="var">y</span>:
    <span class="keyword">SEQ</span>
      <span class="var">x</span> := <span class="const">42</span>
      <span class="var">y</span> := (<span class="var">x</span> + <span class="const">5</span>)

</pre>
<p>
	But if we later removed the `<tt>+ 5</tt>':
</p>
<pre class="source">

    <span class="keyword">MOBILE INT</span> <span class="var">x</span>, <span class="var">y</span>:
    <span class="keyword">SEQ</span>
      <span class="var">x</span> := <span class="const">42</span>
      <span class="var">y</span> := (<span class="var">x</span>)

</pre>
<p>
	It is not immediately clear whether this results in movement or copying semantics -- i.e. whether `<tt>x</tt>' is defined after the second assignment.
	In fact, the compiler will use copying semantics for this -- two reasons: firstly, because of the brackets; and secondly, because any mobile type less than
	or equal to 8 bytes is automatically made non-mobile (because the equivalent non-mobile assignments and communications are quicker).
</p>
<p>
	The <tt>CLONE</tt> operator can clear this ambiguity up, however:
</p>
<pre class="source">

    <span class="keyword">MOBILE INT</span> <span class="var">x</span>, <span class="var">y</span>:
    <span class="keyword">SEQ</span>
      <span class="var">x</span> := <span class="const">42</span>
      <span class="var">y</span> := <span class="keyword">CLONE</span> <span class="var">x</span>

</pre>
<p>
	A more practical example might be:
</p>
<pre class="source">

    <span class="keyword">DATA TYPE</span> STRING <span class="keyword">IS MOBILE</span> []<span class="keyword">BYTE</span>:
    <span class="keyword">CHAN</span> STRING <span class="chan">c</span>:
    <span class="keyword">PAR</span>
      <span class="comment">--{{{  producer</span>
      STRING <span class="var">x</span>:
      <span class="keyword">SEQ</span>
        <span class="var">x</span> := <span class="const">"hello, world!*n"</span>
        <span class="chan">c</span> ! <span class="keyword">CLONE</span> <span class="var">x</span>
        [<span class="var">x</span> <span class="keyword">FROM</span> <span class="const">7</span> <span class="keyword">FOR</span> <span class="const">5</span>] := <span class="const">"occam"</span>
        <span class="chan">c</span> ! <span class="var">x</span>
      <span class="comment">--}}}</span>
      <span class="comment">--{{{  consumer</span>
      STRING <span class="var">v</span>, <span class="var">w</span>:
      <span class="keyword">SEQ</span>
        <span class="chan">c</span> ? <span class="var">v</span>
        <span class="chan">c</span> ? <span class="var">w</span>
        <span class="comment">...  use `v' and `w'</span>
      <span class="comment">--}}}</span>

</pre>
<p>
	Or in a mobile `<tt>tap</tt>' process (using the <a href="#extin">extended rendezvous</a>), for example:
</p>
<pre class="source">

    <span class="keyword">PROC</span> mi.tap (<span class="keyword">CHAN MOBILE</span> []<span class="keyword">INT</span> <span class="chan">in?</span>, <span class="chan">out!</span>, <span class="chan">report!</span>)
      <span class="keyword">WHILE</span> <span class="const">TRUE</span>
        <span class="keyword">MOBILE</span> []<span class="keyword">INT</span> <span class="var">x</span>:
        <span class="chan">in</span> ?? <span class="var">x</span>
          <span class="chan">out</span> ! <span class="keyword">CLONE</span> <span class="var">x</span>
          <span class="chan">report</span> ! <span class="var">x</span>
    :

</pre>
<p>
	The compiler (and run-time system) also support <em>multi-dimensional</em> dynamic mobile arrays.  These can be used
	with automatic-promotion and array constructors too.  For example:
</p>
<pre class="source">

    <span class="keyword">DATA TYPE</span> I.MATRIX <span class="keyword">IS MOBILE</span> [][]<span class="keyword">INT</span>:

    <span class="keyword">PAR</span>
      <span class="comment">--{{{  producer</span>
      I.MATRIX <span class="var">x</span>:
      <span class="keyword">SEQ</span>
        <span class="var">x</span> := [i = <span class="const">0</span> <span class="keyword">FOR</span> <span class="const">64</span> | [j = <span class="const">0</span> <span class="keyword">FOR</span> <span class="const">64</span> | (i * j)]]
        <span class="chan">c</span> ! <span class="var">x</span>
      <span class="comment">--}}}</span>
      <span class="comment">--{{{  consumer</span>
      I.MATRIX <span class="var">m</span>:
      <span class="keyword">INT</span> <span class="var">sum</span>:
      <span class="keyword">SEQ</span>
        <span class="chan">c</span> ? <span class="var">m</span>
        <span class="var">sum</span> := <span class="const">0</span>
        <span class="keyword">SEQ</span> i = <span class="const">0</span> <span class="keyword">FOR SIZE</span> <span class="var">m</span>
          <span class="keyword">SEQ</span> j = <span class="const">0</span> <span class="keyword">FOR SIZE</span> <span class="var">m</span>[i]
            <span class="var">sum</span> := <span class="var">sum</span> + <span class="var">m</span>[i][j]

        <span class="comment">...  do something useful</span>
      <span class="comment">--}}}</span>

</pre>
<!--}}}-->

		<p />
		<hr />
		<p>
		<em>Last modified: Sun Mar 20 13:46:45 2005 by Fred Barnes</em>.
		</p>
	</body>
</html>

