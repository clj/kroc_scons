--
--	sdlraster.occ -- occam X raster UDC / SDL raster
--	Copyright (C) 2005-2006 Fred Barnes  <frmb@kent.ac.uk>
--
--	This program is free software; you can redistribute it and/or modify
--	it under the terms of the GNU General Public License as published by
--	the Free Software Foundation; either version 2 of the License, or
--	(at your option) any later version.
--
--	This program is distributed in the hope that it will be useful,
--	but WITHOUT ANY WARRANTY; without even the implied warranty of
--	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--	GNU General Public License for more details.
--
--	You should have received a copy of the GNU General Public License
--	along with this program; if not, write to the Free Software
--	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
--

#INCLUDE "sdlraster.inc"

--{{{  module documentation
--** Simple bitmap display using SDL.
--
-- @module sdlraster

--}}}

#PRAGMA EXTERNAL "PROC C.sdlraster.set.buffer (VAL INT n, VAL [][]INT r) = 0"
#PRAGMA EXTERNAL "PROC C.sdlraster.set.update.buffer (VAL [][]INT r) = 0"
#PRAGMA EXTERNAL "PROC C.sdlraster.clear ([][]INT r) = 0"
#PRAGMA EXTERNAL "PROC C.sdlraster.update (VAL [][]INT r) = 0"
#PRAGMA EXTERNAL "PROC C.sdlraster.update.n (VAL INT n) = 0"

--{{{  handy functions
INT FUNCTION SDLEVENT.XPOS (VAL SDLEVENT ev) IS (INT ev[x]):
INT FUNCTION SDLEVENT.YPOS (VAL SDLEVENT ev) IS (INT ev[y]):
INT FUNCTION SDLEVENT.BUTTON (VAL SDLEVENT ev) IS (ev[id]):
INT FUNCTION SDLEVENT.BSTATE (VAL SDLEVENT ev) IS (ev[mod]):
INT FUNCTION SDLEVENT.KSTATE (VAL SDLEVENT ev) IS (ev[mod]):
--}}}

VAL INT REFRESH.US IS 20000:

--{{{  PROC SDLRaster (VAL []BYTE dispname, VAL INT width, height, nbuffers, CHAN RASTER in?, out!, CHAN SDLEVENT events!, CHAN INT control?)
--* Start a new window.
-- Windows repeatedly output a blank [@ref RASTER] and input one to display.
-- @param dispname Window title
-- @param width Width of window
-- @param height Height of window
-- @param nbuffers Number of display buffers
-- @param in Raster input
-- @param out Raster output
-- @param events Input events
-- @param control Control messages
PROC SDLRaster (VAL []BYTE dispname, VAL INT width, height, nbuffers, CHAN RASTER in?, out!, CHAN SDLEVENT events!, CHAN INT control?)
  CHAN RASTER.EVENT r.events:
  CHAN RASTER loop.in, loop.out, buffer:
  CHAN BOOL ready, shutdown:
  PAR
    miniraster (dispname, width, height, nbuffers + 2, loop.in?, loop.out!, r.events!)
    SEQ
      SEQ i = 0 FOR nbuffers + 2
        RASTER r:
        SEQ
          loop.out ? r
          C.sdlraster.set.buffer (i, r)
          loop.in ! r
      
      PAR
        RASTER r:
        TIMER time:
        INT timeout:
        SEQ
          loop.out ? r
          time ? timeout
          timeout := timeout PLUS REFRESH.US

          INITIAL BOOL done IS FALSE:
          WHILE NOT done
            PRI ALT
              INT ctl:
              control ? ctl
                done := (ctl = CTL.SHUTDOWN)
              BOOL b:
              ready ? b
                SEQ
                  buffer ! r
                  loop.out ? r
                  C.sdlraster.set.update.buffer (r)
              RASTER ret:
              in ? ret
                SEQ
                  loop.in ! ret
                  time ? timeout
                  timeout := timeout PLUS REFRESH.US
              time ? AFTER timeout
                SEQ
                  timeout := timeout PLUS REFRESH.US
                  loop.in ! r
                  loop.out ? r
                  C.sdlraster.set.update.buffer (r)
                  RESCHEDULE ()

          PAR
            miniraster.shutdown (loop.out?, loop.in!)
            shutdown ! TRUE
            BOOL b:
            SEQ
              ready ? b
              r := MOBILE [0][0]INT
              buffer ! r

        INITIAL BOOL done IS FALSE:
        RASTER r:
        WHILE NOT done
          SEQ
            ready ! TRUE
            buffer ? r
            IF
              (SIZE r[0]) > 0
                out ! r
              TRUE
                done := TRUE

        INITIAL BOOL done IS FALSE:
        WHILE NOT done
          ALT
            shutdown ? done
              SKIP
            RASTER.EVENT r.ev:
            r.events ? r.ev
              SDLEVENT ev:
              SEQ
                ev[type]  := r.ev[type]
                ev[data]  := r.ev[id] \/ (((INT r.ev[x]) << 20) \/ ((INT r.ev[y]) << 8))
                ev[id]    := r.ev[id]
                ev[mod]   := r.ev[mod]
                ev[x]     := r.ev[x]
                ev[y]     := r.ev[y]
                events ! ev
:
--}}}
--{{{  PROC SDLRasterClear ([][]INT r)
--* Clear a raster.
PROC SDLRasterClear ([][]INT r)
  SEQ
    C.sdlraster.clear (r)
:
--}}}
--{{{  PROC SDLRasterUpdate ([][]INT r)
--* Force a raster to be drawn on the screen.
-- (This cheats a bit, since you don't actually need to return the raster to
-- the [@ref SDLRaster] process to get it redrawn.)
PROC SDLRasterUpdate ([][]INT r)
  SEQ
    C.sdlraster.update (r)
:
--}}}
--{{{  PROC SDLRasterUpdateBuf (VAL INT bufnum)
--* Force a particular display buffer to be drawn on the screen.
PROC SDLRasterUpdateBuf (VAL INT bufnum)
  SEQ
    C.sdlraster.update.n (bufnum)
:
--}}}
--{{{  PROC SDLRasterAutoClose (CHAN SDLEVENT events?, CHAN INT control!)
--* Respond to [@ref EVENT.QUIT] messages with [@ref CTL.SHUTDOWN].
-- This can be used in trivial programs to handle closing the window.
PROC SDLRasterAutoClose (CHAN SDLEVENT events?, CHAN INT control!)
  INITIAL BOOL running IS TRUE:
  WHILE running
    SDLEVENT ev:
    SEQ
      events ? ev
      CASE ev[type]
        RASTER.ET.QUIT
          SEQ
            control ! CTL.SHUTDOWN
            running := FALSE
        ELSE
          SKIP
:
--}}}

