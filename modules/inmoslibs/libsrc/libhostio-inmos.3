'\" t
.\"
.\" Manual page for hostio.lib - INMOS occam toolset host file server library
.\"
.\" $Source: /u0/src/local/bin/oc2man/RCS/hostio-lib.man,v $
.\"
.\" $Id: hostio-lib.man,v 1.4 1993/02/24 14:19:30 djb1 Exp $
.\"
.\" Copyright (C) 1993 David Beckett, University of Kent at Canterbury
.\"
.\" This was derived from hostio.lib (the library) using ilist and the
.\" perl program fixilist.pl which cleaned up the output.
.\"
.\" Modified slightly by Fred Barnes, 2004-2005  <frmb@kent.ac.uk>
.TH LIBHOSTIO-INMOS 3 "February 1993" "kroc 1.4.0" KRoC
.SH NAME
so.ask, so.buffer, so.close, so.commandline, so.core, so.date.to.ascii, so.eof,
so.exit, so.ferror, so.flush,
so.fwrite.char, so.fwrite.hex.int, so.fwrite.hex.int32, so.fwrite.hex.int64,
so.fwrite.int, so.fwrite.int32, so.fwrite.int64, so.fwrite.nl,
so.fwrite.real32, so.fwrite.real64, so.fwrite.string, so.fwrite.string.nl,
so.getenv, so.getkey, so.gets, so.multiplexor, so.open, so.open.temp,
so.overlapped.buffer, so.overlapped.multiplexor, so.overlapped.pri.multiplexor,
so.parse.command.line, so.pollkey, so.pri.multiplexor, so.puts, so.read,
so.read.echo.any.int, so.read.echo.hex.int, so.read.echo.hex.int32, so.read.echo.hex.int64,
so.read.echo.int, so.read.echo.int32, so.read.echo.int64,
so.read.echo.line, so.read.echo.real32, so.read.echo.real64, so.read.line,
so.remove, so.rename, so.seek, so.system, so.tell, so.test.exists, so.time,
so.time.to.ascii, so.time.to.date, so.today.ascii, so.today.date, so.version,
so.write, so.write.char,
so.write.hex.int, so.write.hex.int32, so.write.hex.int64,
so.write.int, so.write.int32, so.write.int64, so.write.nl,
so.write.real32, so.write.real64, so.write.string, so.write.string.nl,
sp.receive.packet, sp.send.packet
\- KRoC INMOS occam toolset host file server library
.SH SYNOPSIS
.B #INCLUDE \fB"hostio.inc\fB"\fR
.br
.B #USE \fB"hostio.lib\fB"\fR
.br
.B kroc -lhostio
.PP
.BI "PROC so.ask (CHAN OF SP " fs ", " ts ", VAL []BYTE " prompt ", VAL []BYTE " replies ", VAL BOOL " display.possible.replies ", VAL BOOL " echo.reply ", INT " reply.number ")"
.br
.BI "PROC so.buffer (CHAN OF SP " fs ", " ts ", CHAN OF SP " from.user ", " to.user " CHAN OF BOOL " stopper ")"
.br
.BI "PROC so.close (CHAN OF SP " fs ", " ts ", VAL INT32 " streamid ", BYTE " result ")"
.br
.BI "PROC so.commandline (CHAN OF SP " fs ", " ts ", VAL BYTE " all ", INT " length ", []BYTE " string ", BYTE " result ")"
.br
.BI "PROC so.core (CHAN OF SP " fs ", " ts ", VAL INT32 " offset ", INT " bytes.read ", []BYTE " data ", BYTE " result ")"
.br
.BI "PROC so.date.to.ascii (VAL [6]INT " date ", VAL BOOL " long.years ", VAL BOOL " days.first ", [19]BYTE " string ")"
.br
.BI "PROC so.eof (CHAN OF SP " fs ", " ts ", VAL INT32 " streamid ", BYTE " result ")"
.br
.BI "PROC so.exit (CHAN OF SP " fs ", " ts ", VAL INT32 " status ")"
.br
.BI "PROC so.ferror (CHAN OF SP " fs ", " ts ", VAL INT32 " streamid ", INT32 " error.no ", INT " length ", []BYTE " message ", BYTE " result ")"
.br
.BI "PROC so.flush (CHAN OF SP " fs ", " ts ", VAL INT32 " streamid ", BYTE " result ")"
.PP
.BI "PROC so.fwrite.char (CHAN OF SP " fs ", " ts ", VAL INT32 " streamid ", VAL BYTE " char ", BYTE " result ")"
.br
.BI "PROC so.fwrite.hex.int (CHAN OF SP " fs ", " ts ", VAL INT32 " streamid ", VAL INT " n ", VAL INT " width ", BYTE " result ")"
.br
.BI "PROC so.fwrite.hex.int32 (CHAN OF SP " fs ", " ts ", VAL INT32 " streamid ", VAL INT32 " n ", VAL INT " width ", BYTE " result ")"
.br
.BI "PROC so.fwrite.hex.int64 (CHAN OF SP " fs ", " ts ", VAL INT32 " streamid ", VAL INT64 " n ", VAL INT " width ", BYTE " result ")"
.br
.BI "PROC so.fwrite.int (CHAN OF SP " fs ", " ts ", VAL INT32 " streamid ", VAL INT " n ", VAL INT " width ", BYTE " result ")"
.br
.BI "PROC so.fwrite.int32 (CHAN OF SP " fs ", " ts ", VAL INT32 " streamid ", VAL INT32 " n ", VAL INT " width ", BYTE " result ")"
.br
.BI "PROC so.fwrite.int64 (CHAN OF SP " fs ", " ts ", VAL INT32 " streamid ", VAL INT64 " n ", VAL INT " width ", BYTE " result ")"
.br
.BI "PROC so.fwrite.nl (CHAN OF SP " fs ", " ts ", VAL INT32 " streamid ", BYTE " result ")"
.br
.BI "PROC so.fwrite.real32 (CHAN OF SP " fs ", " ts ", VAL INT32 " streamid ", VAL REAL32 " r ", VAL INT " Ip ", VAL INT " Dp ", BYTE " result ")"
.br
.BI "PROC so.fwrite.real64 (CHAN OF SP " fs ", " ts ", VAL INT32 " streamid ", VAL REAL64 " r ", VAL INT " Ip ", VAL INT " Dp ", BYTE " result ")"
.br
.BI "PROC so.fwrite.string (CHAN OF SP " fs ", " ts ", VAL INT32 " streamid ", VAL []BYTE " string ", BYTE " result ")"
.br
.BI "PROC so.fwrite.string.nl (CHAN OF SP " fs ", " ts ", VAL INT32 " streamid ", VAL []BYTE " string ", BYTE " result ")"
.PP
.BI "PROC so.getenv (CHAN OF SP " fs ", " ts ", VAL []BYTE " name ", INT " length ", []BYTE " value ", BYTE " result ")"
.br
.BI "PROC so.getkey (CHAN OF SP " fs ", " ts ", BYTE " key ", BYTE " result ")"
.br
.BI "PROC so.gets (CHAN OF SP " fs ", " ts ", VAL INT32 " streamid ", INT " bytes.read ", []BYTE " data ", BYTE " result ")"
.br
.BI "PROC so.multiplexor (CHAN OF SP " fs ", " ts ", []CHAN OF SP " from.user ", " to.user ", CHAN OF BOOL " stopper ")"
.br
.BI "PROC so.open (CHAN OF SP " fs ", " ts ", VAL []BYTE " name ", VAL BYTE " type ", VAL BYTE " mode ", INT32 " streamid ", BYTE " result ")"
.br
.BI "PROC so.open.temp (CHAN OF SP " fs ", " ts ", VAL BYTE " type ", [6]BYTE " filename ", INT32 " streamid ", BYTE " result ")"
.br
.BI "PROC so.overlapped.buffer (CHAN OF SP " fs ", " ts ", CHAN OF SP " from.user ", " to.user ", CHAN OF BOOL " stopper ")"
.br
.BI "PROC so.overlapped.multiplexor (CHAN OF SP " fs ", " ts ", []CHAN OF SP " from.user ", " to.user " CHAN OF BOOL " stopper ", []INT " queue ")"
.br
.BI "PROC so.overlapped.pri.multiplexor (CHAN OF SP " fs ", " ts ", []CHAN OF SP " from.user ", " to.user " CHAN OF BOOL " stopper ", []INT " queue ")"
.PP
.BI "PROC so.parse.command.line (CHAN OF SP " fs ", " ts ", VAL [][]BYTE " option.strings ", VAL []INT " option.parameters.required ", []BOOL " option.exists ", [][2]INT " option.parameters ", INT " error.len ", []BYTE " line ")"
.br
.BI "PROC so.pollkey (CHAN OF SP " fs ", " ts ", BYTE " key ", BYTE " result ")"
.br
.BI "PROC so.popen.read (CHAN OF SP " fs ", " ts ", VAL []BYTE " filename ", VAL []BYTE " path.variable.name ", VAL BYTE " open.type ", INT " full.len ", []BYTE " full.name ", INT32 " stream.id ", BYTE " result ")"
.br
.BI "PROC so.pri.multiplexor (CHAN OF SP " fs ", " ts ", []CHAN OF SP " from.user ", " to.user ", CHAN OF BOOL " stopper ")"
.br
.BI "PROC so.puts (CHAN OF SP " fs ", " ts ", VAL INT32 " streamid ", VAL []BYTE " data ", BYTE " result ")"
.br
.BI "PROC so.read (CHAN OF SP " fs ", " ts ", VAL INT32 " streamid ", INT " bytes.read ", []BYTE " data ")"
.PP
.BI "PROC so.read.echo.any.int (CHAN OF SP " fs ", " ts ", INT " n ", BOOL " error ")"
.br
.BI "PROC so.read.echo.hex.int (CHAN OF SP " fs ", " ts ", INT " n ", BOOL " error ")"
.br
.BI "PROC so.read.echo.hex.int32 (CHAN OF SP " fs ", " ts ", INT32 " n ", BOOL " error ")"
.br
.BI "PROC so.read.echo.hex.int64 (CHAN OF SP " fs ", " ts ", INT64 " n ", BOOL " error ")"
.br
.BI "PROC so.read.echo.int (CHAN OF SP " fs ", " ts ", INT " n ", BOOL " error ")"
.br
.BI "PROC so.read.echo.int32 (CHAN OF SP " fs ", " ts ", INT32 " n ", BOOL " error ")"
.br
.BI "PROC so.read.echo.int64 (CHAN OF SP " fs ", " ts ", INT64 " n ", BOOL " error ")"
.br
.BI "PROC so.read.echo.line (CHAN OF SP " fs ", " ts ", INT " len ", []BYTE " line ", BYTE " result ")"
.br
.BI "PROC so.read.echo.real32 (CHAN OF SP " fs ", " ts ", REAL32 " n ", BOOL " error ")"
.br
.BI "PROC so.read.echo.real64 (CHAN OF SP " fs ", " ts ", REAL64 " n ", BOOL " error ")"
.br
.BI "PROC so.read.line (CHAN OF SP " fs ", " ts ", INT " len ", []BYTE " line ", BYTE " result ")"
.PP
.BI "PROC so.remove (CHAN OF SP " fs ", " ts ", VAL []BYTE " name ", BYTE " result ")"
.br
.BI "PROC so.rename (CHAN OF SP " fs ", " ts ", VAL []BYTE " oldname ", VAL []BYTE " newname ", BYTE " result ")"
.br
.BI "PROC so.seek (CHAN OF SP " fs ", " ts ", VAL INT32 " streamid ", VAL INT32 " offset ", VAL INT32 " origin ", BYTE " result ")"
.br
.BI "PROC so.system (CHAN OF SP " fs ", " ts ", VAL []BYTE " command ", INT32 " status ", BYTE " result ")"
.br
.BI "PROC so.tell (CHAN OF SP " fs ", " ts ", VAL INT32 " streamid ", INT32 " position ", BYTE " result ")"
.br
.BI "PROC so.test.exists (CHAN OF SP " fs ", " ts ", VAL []BYTE " filename ", BOOL " exists ")"
.br
.BI "PROC so.time (CHAN OF SP " fs ", " ts ", INT32 " localtime ", INT32 " UTCtime ")"
.br
.BI "PROC so.time.to.ascii (VAL INT32 " time ", VAL BOOL " long.years ", VAL BOOL " days.first ", [19]BYTE " string ")"
.br
.BI "PROC so.time.to.date (VAL INT32 " input.time ", [6]INT " date ")"
.br
.BI "PROC so.today.ascii (CHAN OF SP " fs ", " ts ", VAL BOOL " long.years ", VAL BOOL " days.first ", [19]BYTE " string ")"
.br
.BI "PROC so.today.date (CHAN OF SP " fs ", " ts ", [6]INT " date ")"
.br
.BI "PROC so.version (CHAN OF SP " fs ", " ts ", BYTE " version ", BYTE " host ", BYTE " os ", BYTE " board ")"
.br
.BI "PROC so.write (CHAN OF SP " fs ", " ts ", VAL INT32 " streamid ", VAL []BYTE " data ", INT " length ")"
.PP
.BI "PROC so.write.char (CHAN OF SP " fs ", " ts ", VAL BYTE " char ")"
.br
.BI "PROC so.write.hex.int (CHAN OF SP " fs ", " ts ", VAL INT " n ", VAL INT " width ")"
.br
.BI "PROC so.write.hex.int32 (CHAN OF SP " fs ", " ts ", VAL INT32 " n ", VAL INT " width ")"
.br
.BI "PROC so.write.hex.int64 (CHAN OF SP " fs ", " ts ", VAL INT64 " n ", VAL INT " width ")"
.br
.BI "PROC so.write.int (CHAN OF SP " fs ", " ts ", VAL INT " n ", VAL INT " width ")"
.br
.BI "PROC so.write.int32 (CHAN OF SP " fs ", " ts ", VAL INT32 " n ", VAL INT " width ")"
.br
.BI "PROC so.write.int64 (CHAN OF SP " fs ", " ts ", VAL INT64 " n ", VAL INT " width ")"
.br
.BI "PROC so.write.nl (CHAN OF SP " fs ", " ts ")"
.br
.BI "PROC so.write.real32 (CHAN OF SP " fs ", " ts ", VAL REAL32 " r ", VAL INT " Ip ", VAL INT " Dp ")"
.br
.BI "PROC so.write.real64 (CHAN OF SP " fs ", " ts ", VAL REAL64 " r ", VAL INT " Ip ", VAL INT " Dp ")"
.br
.BI "PROC so.write.string (CHAN OF SP " fs ", " ts ", VAL []BYTE " string ")"
.br
.BI "PROC so.write.string.nl (CHAN OF SP " fs ", " ts ", VAL []BYTE " string ")"
.PP
.BI "PROC sp.receive.packet (CHAN OF SP " fs ", INT16 " length ", []BYTE " packet ", BOOL " error ")"
.br
.BI "PROC sp.send.packet (CHAN OF SP " ts ", VAL []BYTE " packet ", BOOL " error ")"
.PP
.SH SUMMARY
The occam toolset library hostio.lib provides the main interface
between the host and the transputer network.
.PP
The pair of channels \fBCHAN OF SP\fR \fIfs\fR, \fIts\fR to and from the server
are the first two parameters for most \fBhostio.lib\fR library
procedure.
.PP
When a new stream is opened with \fBso.open\fR, a \fBVAL INT32\fR
\fIstreamid\fR is returned.  This is used to reference the stream and is
used in all procedure calls related to files.
.PP
Error returns from procedures are passed out a variable called
\fIresult\fR which can take the following values:

.TS
lf(CR) lw(5i).
spr.ok	The operation was successful
spr.notok	Too many temporary files opened (\fBso.open.temp\fR)
spr.bad.name	Invalid name parameter
spr.bad.type	Invalid type parameter (\fBso.open\fR, \fBso.open.temp\fR)
spr.bad.mode	Invalid mode parameter (\fBso.open\fR)
spr.bad.origin	Invalid origin parameter (\fBso.seek\fR)
spr.bad.packet.size	Some data was larger than the built in buffer
spr.buffer.overflow	Part of the operation exceeded the 256 byte buffer
>=spr.operation.failed	Server returned a failure
.TE

.PP
.SH "DESCRIPTION"
\fBso.ask\fR prompts for a user keyboard response from valid replies and return
\fIreply.number\fR as index.  If \fIdisplay.possible.replies\fR is
\fBTRUE\fR then print permitted replies on the screen.  If
\fIecho.reply\fR is \fBTRUE\fR then echo response on screen.
.PP
\fBso.buffer\fR provides buffering of the SP protocol passing requests
from the user to the system until any boolean is sent along
\fIstopper\fR.
.PP
\fBso.close\fR closes an open stream.
.PP
\fBso.commandline\fR returns the command line passed by the host in string
of \fISIZE length\fR bytes.  If \fIall\fR is set to
\fIsp.short.commandline\fR then strip server options or present
them if \fIsp.whole.commandline\fR.
.PP
\fBso.core\fR returns peeked memory of the root transputer.
.PP
For \fBso.date.to.ascii\fR see \fBso.time\fR and \fBso.time.to.ascii\fR etc.
.PP
\fBso.eof\fR returns a result of \fBspr.ok\fR if end-of-file has been reached on
the given stream.
.PP
\fBso.exit\fR terminates the server and exits the program with status
\fBsps.success\fR or \fBsps.failure\fR.
.PP
\fBso.ferror\fR puts a description of the given host \fIerror.no\fR in
a \fImessage\fR of \fISIZE length\fR.
.PP
\fBso.flush\fR flushes the output buffer of the given stream.
.PP
Write the given data type to a stream, usually a file, formatting
where necessary and possibly padding with spaces to a given field
\fIwidth\fR or printing \fIIp\fR integer places and \fIDp\fR
decimal places for \fBREAL32\fR and \fBREAL64\fR types. Hex
numbers are written prefixed by a '#'. PROCedures ending in
\fB.nl\fR write a newline sequence.
.PP
\fBso.getenv\fR returns the \fIvalue\fR of the given host environment variable
of \fISIZE length\fR bytes.
.PP
\fBso.getkey\fR waits for a keypress.
.PP
\fBso.gets\fR reads up to \fISIZE data\fR bytes from a line of the stream and returns the
number of bytes read.  The newline is not returned.
.PP
For \fBso.multiplexor\fR see \fBso.overlapped.multiplexor\fR.
.PP
\fBso.open\fR attempts to open the file \fIname\fR and returns the \fIstreamid\fR for file
operations if successful.  Valid types are \fBspt.binary\fR and
\fBspt.text\fR.  Valid modes are \fBspm.input\fR,
\fBspm.output\fR, \fBspm.append\fR, \fBspm.existing.update\fR,
\fBspm.new.update\fR and \fBspm.append.update\fR.
.PP
\fBso.open.temp\fR opens a temporary file and return its \fIfilename\fR and \fIstreamid\fR.
See \fBso.open\fR for valid types.
.PP
\fBso.overlapped.buffer\fR provides buffering of the SP protocol passing requests
from the user to the system until any boolean is sent along
\fIstopper\fR.  Communications are overlapped allowing inputs and
outputs to happen concurrently.
.PP
\fBso.overlapped.multiplexor\fR and \fBso.overlapped.pri.multiplexor\fR
provide multiplexing of the SP protocol.  Procedures
with \fBpri\fR in the name give priority to the lower numbered
channels.  Procedures with \fBoverlapped\fR in the name, overlap
communications allowing inputs and outputs to happen concurrently.
.PP
\fBso.parse.command.line\fR parses the command line for options.  See INMOS documentation for
details.
.PP
\fBso.pollkey\fB reads a character from the keyboard (\fIresult\fR = \fBspr.ok\fR)
or returns immediately if no key is ready (\fIresult\fR >=
\fBspr.operation.failed\fR).
.PP
\fBso.popen.read\fR opens a file like \fBso.open\fR but use the given environment
variable as a path to search for it.  The mode is always
\fBspm.input\fR and the full name and length are returned also.
.PP
For \fBso.pri.multiplexor\fR see \fBso.overlapped.multiplexor\fR.
.PP
\fBso.puts\fR writes the given line to the stream followed by a newline.
.PP
\fBso.read\fR reads up to \fISIZE data\fR bytes from the given stream and returns
the number read.
.PP
These (with \fBread.echo\fR in the name) read some data from the keyboard
terminated by return, echoing output
to the screen.  Hex numbers can be prefixed by a '#' or '$' or with
'%' which adds \fBMOSTNEG INT\fR to the value.
.PP
\fBso.read.line\fR 
reads a line of \fISIZE len\fR bytes from the keyboard with no
screen echo. The line terminator is removed.  See also
\fBso.read.echo.line\fR.
.PP
\fBso.remove\fR attempt to delete the given file.
.PP
\fBso.rename\fR attempts to rename file oldname to newname.
.PP
\fBso.seek\fR moves the file pointer on the given stream to a new offset.  Origin
can be \fBspo.start\fR, \fBspo.current\fR or \fBspo.end\fR.
.PP
\fBso.system\fR executes the given command on the host server.
.PP
\fBso.tell\fR returns the position of the file pointer for the given stream.
.PP
\fBso.test.exists\fR returns \fBTRUE\fR in \fIexists\fR if the file exists.
.PP
\fBso.time.to.ascii\fR, \fBso.time.to.date\fR, \fBso.today.ascii\fR and \fBso.today.date\fR
perform various time and date to/from ASCII conversions.  See also \fBso.date.to.ascii\fR,
\fBso.time\fR and \fBtime\fR(3).
\fI[6]INT date\fR is \fI[seconds, minutes, hour,
day, month, year]\fR.  Date format is \fI"HH:MM:SS\ DD/MM/YYYY"\fR.
If \fIlong.years\fR is \fBFALSE\fR use 2 digit years.  If
\fIdays.first\fR is \fBFALSE\fR then swap DD and MM (for U.S.)
.PP
\fBso.time\fR returns the local and UTC time (UNIX format - see \fBtime\fR(3)).
.PP
\fBso.version\fR returns version information.  See INMOS documentation for values.
.PP
\fBso.write\fR writes up to \fISIZE data\fR bytes to the given stream and returns
the \fIlength\fR written.
.PP
These write the given data type to the screen, formatting where necessary
and possibly padding with spaces to a given field width or printing
\fIIp\fR integer places and \fIDp\fR decimal places for
\fBREAL32\fR and \fBREAL64\fR types. Hex numbers are written
prefixed by a '#'. PROCedures ending in \fB.nl\fR write a newline
sequence.
.PP
For descriptions of the \fBsp.\fR procedures, see section H.3 of the INMOS manual.
.PP
.SH "SEE ALSO"
kroc(1)
.br
INMOS  occam 2 toolset user manual - part 2 (occam libraries and
appendices) INMOS document number 72 TDS 276 02.
.SH AUTHOR
This document is Copyright (C) 1993 David Beckett, University of Kent
at Canterbury.  This manual page is maintained by Fred Barnes  <frmb@kent.ac.uk>
.PP
The library contents are Copyright (C) 1991 INMOS Limited.
.SH NOTES
The hostio library is deprecated in favour of the new POSIX flavoured libraries
provided with KRoC.

