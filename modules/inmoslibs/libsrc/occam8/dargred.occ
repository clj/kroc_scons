--
--	Inmos Libraries
--	Copyright (C) 1988, 1989, 1990, 1991, 1993  Inmos Limited
--
--	This library is free software; you can redistribute it and/or
--	modify it under the terms of the GNU Lesser General Public
--	License as published by the Free Software Foundation; either
--	version 2 of the License, or (at your option) any later version.
--
--	This library is distributed in the hope that it will be useful,
--	but WITHOUT ANY WARRANTY; without even the implied warranty of
--	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
--	Lesser General Public License for more details.
--
--	You should have received a copy of the GNU Lesser General Public
--	License along with this library; if not, write to the Free Software
--	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
--

--** @module occam8

--{{{  #options and #comments
#OPTION "V"  -- no vector space
#COMMENT "TA compiler library, V1.3 06/04/90"
#COMMENT "(c) Copyright INMOS Limited 1988"
--}}}

#PRAGMA TRANSLATE DARGUMENT.REDUCE "DARGUMENT.REDUCE%O"

--{{{  
BOOL, INT32, REAL64 FUNCTION DARGUMENT.REDUCE (VAL REAL64 Y, Z, Z.err)

  --{{{  history
  -- 20 Aug 87
  -- Version using QUOTREM 20-3-1989
  --}}}

  #INCLUDE "endian.inc" -- 4-Sep-07

  BOOL   b :
  INT32  N :
  REAL64 X :
  VALOF
    --{{{  VALS
    VAL BitsPerWord    IS             32 :
    VAL DRealShift     IS             11 :
    VAL DRealExp       IS           #7FF :
    VAL Bias           IS           1023 :
    --}}}
    --{{{  IEEE64QUOTREM -- returning INT32
    BOOL, INT32, REAL64 FUNCTION IEEE64QUOTREM (VAL REAL64 X, VAL REAL64 Y)
    
      --  Beta-3 (11feb87)
      --  Modified to produce quotient 20-3-1989 PWT
    
      BOOL Error:
      INT32 Quotient :
      REAL64 Result:
      VALOF
        #PRAGMA TRANSLATE RealIDiv "RealIDiv%CHK"
        #USE "ridiv"  --  13-Sep-07
        --{{{  DEFs
        --{{{  Word length specific values for 32 bit machine
        VAL SignBit        IS #80000000 :
        VAL BitsPerWord    IS        32 :
        VAL BytesPerWord   IS         4 :
        --}}}
        --{{{  IEEE Double length constants for 32 bit implementation
        VAL DRealShift  IS            11 :
        VAL DBitsInFrac IS            53 :
        VAL DRealExpSh  IS            20 :
        VAL DRealExp    IS          #7FF :
        VAL DRealXcess  IS          1023 :
        VAL DRealRBit   IS          #400 :
        VAL DRealInf    IS     #7FF00000 :
        --}}}
        --{{{  NaNs
        --  These are the values of nans returned by the IMS T800
        VAL ZeroZeroDivNaN.hi  IS #7FF80000 :
        VAL InfInfDivNaN.hi    IS #7FF40000 :
        VAL ZeroInfMulNaN.hi   IS #7FF20000 :
        VAL AddSubInfInfNaN.hi IS #7FF10000 :
        VAL NegSqrtNaN.hi      IS #7FF08000 :
        VAL Real64to32NaN.hi   IS #7FF04000 :
        VAL RemInfNaN.hi       IS #7FF00800 :
        VAL RemZeroNaN.hi      IS #7FF00400 :
        --}}}
        --}}}
        --{{{  declarations
        INT Quotient RETYPES Quotient :
        [2]INT Result RETYPES Result :
        VAL [2]INT X RETYPES X :
        VAL [2]INT Y RETYPES Y :
        INT Xexp, Yexp :
        [2] INT Xfrac :
        PLACE Xfrac IN WORKSPACE :
        [2] INT Yfrac :
        PLACE Yfrac IN WORKSPACE :
        INT Carry, Guard, Places :
        [2] INT Ans :
        PLACE Ans IN WORKSPACE :
        VAL INT Sign IS SignBit :
        --}}}
        SEQ
          --{{{  Unpack operands
          --{{{  Seperate mantissa and exponents
          
          Xfrac [hi],  Xfrac [lo] := SHIFTLEFT ( X [hi],  X [lo],  DRealShift)
          Yfrac [hi],  Yfrac [lo] := SHIFTLEFT ( Y [hi],  Y [lo],  DRealShift)
          
          Xexp := (X [hi] >> DRealExpSh) /\ DRealExp
          Yexp := (Y [hi] >> DRealExpSh) /\ DRealExp
          --}}}
          
          Ans [lo] := 0
          Carry := 0                          --assume not normal case
          Error := FALSE                      --assume not normal case
          IF
            (Xexp <> DRealExp) AND (Yexp <> DRealExp)
              --{{{  zeros or real nos
              IF
                (Xexp <> 0) AND (Yexp <> 0)
                  --{{{  both normal nos
                  SEQ                                  --normal case
                    Carry := 1
                    Xfrac [hi] := Xfrac [hi] \/ Sign
                    Yfrac [hi] := Yfrac [hi] \/ Sign
                  --}}}
                ((Yexp \/ Yfrac [hi]) \/ Yfrac [lo]) = 0
                  --{{{  Y is zero
                  SEQ
                    Ans [hi] := RemZeroNaN.hi
                    Ans [lo] := 0
                    Error := TRUE
                  --}}}
                ((Xexp \/ Xfrac [hi]) \/ Xfrac [lo]) = 0
                  --{{{  X is zero
                  SEQ
                    Ans := X
                    Quotient := 0
                  --}}}
                TRUE
                  --{{{  one or both are denormalised
                  -- Put in implicit MSB
                  -- Normalise any denormaliseds and correct their exponents if op is
                  -- multiply, divide or rem leave unormal for add and sub
                  SEQ
                    Carry := 1                         --work to do
                    IF
                      Xexp <> 0                        --set leading bit
                        Xfrac [hi] := Xfrac [hi] \/ Sign
                      TRUE                             --set correct exponent
                        SEQ
                          Places,  Xfrac [hi],  Xfrac [lo] := NORMALISE ( Xfrac [hi],  Xfrac [lo])
                          Xexp := 1 - Places
                    IF
                      Yexp <> 0
                        Yfrac [hi] := Yfrac [hi] \/ Sign
                      TRUE
                        SEQ
                          Places,  Yfrac [hi],  Yfrac [lo] := NORMALISE ( Yfrac [hi],  Yfrac [lo])
                          Yexp := 1 - Places
                  --}}}
              --}}}
            TRUE
              --{{{  one or other inf/NAN
              SEQ
                Xfrac [hi] := Xfrac [hi] /\ (~Sign)      --clear top bits
                Yfrac [hi] := Yfrac [hi] /\ (~Sign)
                Error := TRUE
                IF
                  (Xexp = DRealExp) AND (Yexp = DRealExp)
                    --{{{  both inf/NaN
                    IF
                      ((Xfrac[hi] \/ Xfrac[lo]) \/ (Yfrac[hi] \/ Yfrac[lo])) = 0  -- both infs
                        SEQ
                          Ans [hi] := RemInfNaN.hi
                          Ans [lo] := 0
                      TRUE
                        SEQ
                          Guard, Places := LONGDIFF (Xfrac[lo], Yfrac[lo], 0)
                          Guard, Places := LONGDIFF (Xfrac[hi], Yfrac[hi], Guard)
                          IF
                            Places < 0
                              Ans := Y
                            TRUE
                              Ans := X
                    --}}}
                  Xexp = DRealExp
                    --{{{  X is inf/NaN
                    IF
                      (Xfrac [hi] \/ Xfrac [lo]) <> 0
                        Ans := X
                      TRUE
                        SEQ
                          Ans [hi] := RemInfNaN.hi
                          Ans [lo] := 0
                    --}}}
                  (Yfrac [hi] \/ Yfrac [lo]) <> 0
                    --{{{  Y is NaN
                    Ans := Y
                    --}}}
                  TRUE
                    --{{{  Y is inf
                    Ans := X
                    --}}}
              --}}}
          --}}}
          --{{{  evaluate
          IF
            Carry = 0
              --{{{  Answer is set up
              SEQ
                Result[hi] := Ans[hi]
                Result[lo] := Ans[lo]
              --}}}
            TRUE
              --{{{  Do remainder
              SEQ
                --{{{  find remainder
                SEQ
                  -- Denorms already normalised
                  Ans[hi] := X[hi] /\ Sign           --set correct sign
                  Places := Xexp - Yexp
                  IF
                    Places >= 0                    --general case
                      SEQ
                        Carry := Places /\ (BitsPerWord - 1)
                        Guard,  Xexp := SHIFTLEFT ( 0,  Xfrac[hi],  Carry)
                        Xfrac[hi],  Xfrac[lo] := SHIFTLEFT ( Xfrac[hi],  Xfrac[lo],  Carry)
                        Guard,  Xfrac[hi],  Xfrac[lo] := RealIDiv (Guard,  Xfrac[hi],  Xfrac[lo],  Yfrac)
                        Places := Places - Carry
                        WHILE Places > 0
                          SEQ
                            Guard := Xfrac[hi]
                            Xfrac[hi] := Xfrac[lo]
                            Xfrac[lo] := 0
                            Carry,  Xexp := LONGDIFF ( Xfrac[hi],  Yfrac[hi],  0)
                            IF
                              (Guard = 0) AND (Carry <> 0)     -- filter out some 0 quotients
                                SKIP
                              TRUE
                                Guard,  Xfrac[hi],  Xfrac[lo] := RealIDiv (Guard,  Xfrac[hi],  Xfrac[lo],  Yfrac)
                            Places := Places - BitsPerWord
                        IF
                          (Xfrac[hi] \/ Xfrac[lo]) = 0     --divides exactly
                            SEQ
                              Xexp := 0
                              Quotient := Guard
                          TRUE
                            SEQ
                              Ans[hi],  Ans[lo] := SHIFTRIGHT (Yfrac[hi],  Yfrac[lo],  1)
                              Carry,  Ans[lo] := LONGDIFF ( Ans[lo],  Xfrac[lo],  0)
                              Carry,  Ans[hi] := LONGDIFF ( Ans[hi], Xfrac[hi],  Carry)
                              IF
                                (Carry <> 0) OR (((Ans[hi] \/ Ans[lo]) = 0) AND
                                 ((Guard /\ 1) <> 0))
                                  --over half or exactly half -- round up
                                  SEQ
                                    Ans[hi] := (X[hi] >< Sign) /\ Sign--negate ans
                                    Carry,  Xfrac[lo] := LONGDIFF ( Yfrac[lo], Xfrac[lo],  0)
                                    Carry,  Xfrac[hi] := LONGDIFF ( Yfrac[hi], Xfrac[hi],  Carry)
                                    Quotient := Guard + 1
                                TRUE
                                  SEQ
                                    Ans[hi] := X[hi] /\ Sign        --reset sign
                                    Quotient := Guard
                              Xexp := Yexp
                    Places = (-1)                  --half to nearly one
                      SEQ
                        Carry,  Guard := LONGDIFF ( Yfrac[lo],  Xfrac[lo],  0)
                        Carry,  Guard := LONGDIFF ( Yfrac[hi],  Xfrac[hi],  Carry)
                        IF
                          Carry = 0                --X is answer
                            Quotient := 0
                          TRUE                     --Y-X is answer
                            SEQ
                              Ans[hi] := Ans[hi] >< Sign   --invert sign
                              Xfrac[hi],  Xfrac[lo] := SHIFTRIGHT (Xfrac[hi],  Xfrac[lo],  1)
                              Carry,  Xfrac[lo] := LONGDIFF ( Yfrac[lo], Xfrac[lo],  0)
                              Carry,  Xfrac[hi] := LONGDIFF ( Yfrac[hi], Xfrac[hi],  Carry)
                              Xexp := Yexp
                              Quotient := 1
                    TRUE                           --less than half
                      Quotient := 0
                  Guard := 0
                  Places,  Xfrac[hi],  Xfrac[lo] := NORMALISE ( Xfrac[hi],  Xfrac[lo])
                  Xexp := Xexp - Places            --ensure normalised
                  IF
                    Xexp <= 0                      --gone denorm
                      SEQ
                        Xfrac[hi],  Xfrac[lo] := SHIFTRIGHT (Xfrac[hi],  Xfrac[lo],  1 - Xexp)
                        Xexp := 0
                    TRUE
                      SKIP
                --}}}
                --{{{  pack result
                Places := Xfrac[lo]              --save round bits
                Xfrac[hi],  Xfrac[lo] := SHIFTRIGHT (Xfrac[hi] /\ (~Sign),  Xfrac[lo],  DRealShift)
                Carry,  Xexp := SHIFTRIGHT ( Xexp,  0,  DRealShift + 1)
                Xfrac[hi] := Xfrac[hi] \/ Xexp
                
                Result[hi] := Ans[hi] \/ Xfrac[hi]
                Result[lo] := Xfrac[lo]
                --}}}
                --{{{  adjust sign of quotient
                IF
                  ((X[hi] >< Y[hi]) /\ Sign) <> 0 -- signs differ
                    Quotient := MINUS Quotient
                  TRUE
                    SKIP
                --}}}
              --}}}
          --}}}
        RESULT Error, Quotient, Result
    :
    --}}}
    VAL INT Max.Diff IS 30 :
    INT exp1, exp2, frac :
    SEQ
      --{{{  extract exponents
      VAL [2]INT Y.int RETYPES Y:
      exp1, frac := SHIFTLEFT (0, (Y.int[hi] << 1), DRealShift)
      VAL [2]INT Z.int RETYPES Z:
      exp2, frac := SHIFTLEFT (0, (Z.int[hi] << 1), DRealShift)
      --}}}
      b, N, X := IEEE64QUOTREM (Y, Z)
      IF
        (exp1 - exp2) <= Max.Diff
          SEQ
            X := X - ((REAL64 ROUND N) * Z.err)
            INT32 Nprimed :
            BOOL bprimed :
            SEQ
              -- take another remainder in case the correction has taken us
              -- out of range :
              bprimed, Nprimed, X := IEEE64QUOTREM (X, Z)
              b := NOT (b OR bprimed) -- true unless an error
              N := N + Nprimed
        TRUE
          b := FALSE
    RESULT b, N, X
:
--}}}
