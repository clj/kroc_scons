--
--	Inmos Libraries
--	Copyright (C) 1988, 1989, 1990, 1991, 1993  Inmos Limited
--
--	This library is free software; you can redistribute it and/or
--	modify it under the terms of the GNU Lesser General Public
--	License as published by the Free Software Foundation; either
--	version 2 of the License, or (at your option) any later version.
--
--	This library is distributed in the hope that it will be useful,
--	but WITHOUT ANY WARRANTY; without even the implied warranty of
--	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
--	Lesser General Public License for more details.
--
--	You should have received a copy of the GNU Lesser General Public
--	License along with this library; if not, write to the Free Software
--	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
--

--** @module occam8

--{{{  #options and #comments
#OPTION "V"  -- no vector space
#COMMENT "TA compiler library, V1.3 07/04/90"
#COMMENT "(c) Copyright INMOS Limited 1988"
--}}}

#PRAGMA TRANSLATE ARGUMENT.REDUCE "ARGUMENT.REDUCE%O"

--{{{  
BOOL, INT32, REAL32 FUNCTION ARGUMENT.REDUCE (VAL REAL32 Y, Z, Z.err)

  --{{{  history
  -- (17 March 1989)
  -- Version using QUOTREM; V1.2, 20-3-1989
  -- V1.3, 7-Apr-90 SRH
  --}}}

  BOOL   b :
  INT32  N :
  REAL32 X :
  VALOF
    --{{{  VALs
    VAL BitsPerWord   IS        32 :
    VAL RealShift     IS         8 :
    VAL RealExp       IS       255 :
    VAL undefined.NaN IS #7F800010 :
    VAL Bias          IS       127 :
    --}}}
    VAL INT Max.Diff IS 20 :
    INT exp1, exp2, frac:
    --{{{  IEEE32QUOTREM -- returning INT32
    BOOL, INT32, REAL32 FUNCTION IEEE32QUOTREM (VAL REAL32 X, VAL REAL32 Y)
      --  Beta-3 (7may87)
      --  modified to produce quotient 17-3-1989 PWT
      INT32 Quotient :
      BOOL Error:
      REAL32 Result:
      VALOF
        INT Quotient RETYPES Quotient :
        INT Result RETYPES Result :
        VAL INT X RETYPES X :
        VAL INT Y RETYPES Y :
        --{{{  constants
        --{{{  Word length specific values for 32 bit machine
        VAL SignBit        IS #80000000 :
        VAL BitsPerWord    IS        32 :
        VAL MaxUnsignedInt IS #FFFFFFFF :
        VAL BytesPerWord   IS         4 :
        --}}}
        --{{{  IEEE Single length constants for 32 bit implementation
        VAL RealShift  IS         8 :
        VAL BitsInFrac IS        24 :
        VAL RealExpSh  IS        23 :
        VAL RealExp    IS       255 :
        VAL RealXcess  IS       127 :
        VAL RealRBit   IS       128 :
        VAL RealInf    IS #7F800000 :
        --}}}
        --{{{  NaNs
        --  These are the values of nans returned by the IMS T800
        VAL INT ZeroZeroDivNaN  IS #7FC00000 :
        VAL INT InfInfDivNaN    IS #7FA00000 :
        VAL INT ZeroInfMulNaN   IS #7F900000 :
        VAL INT AddSubInfInfNaN IS #7F880000 :
        VAL INT NegSqrtNaN      IS #7F840000 :
        VAL INT Real64to32NaN   IS #7F820000 :
        VAL INT RemInfNaN       IS #7F804000 :
        VAL INT RemZeroNaN      IS #7F802000 :
        --}}}
        --}}}
        --{{{  comment/variables
        -- compute floating point value :-
        --   Result : destination for result
        --   X      : left hand operand
        --   Y      : right hand operand (will be copied to local).
        --   For this version compute also the integer quotient
        INT Xexp, Xfrac, Yexp, Yfrac, Carry, Guard, Places, Ans :
        VAL INT Sign IS SignBit :
        --}}}
        SEQ
          --{{{  unpack operands
          --{{{  unpack operands
          Xexp,  Xfrac := SHIFTLEFT ( 0,  X << 1,  RealShift)
          Xfrac := Xfrac >> 1                 --room for leading bit
          Yexp,  Yfrac := SHIFTLEFT ( 0,  Y << 1,  RealShift)
          Yfrac := Yfrac >> 1
          --}}}
          --{{{  determine special cases
          Error := FALSE                      -- assume no errors
          Carry := 0                          --assume not normal case
          IF
            (Xexp <> RealExp) AND (Yexp <> RealExp)  --normal or zeros
              --{{{  
              IF
                (Xexp <> 0) AND (Yexp <> 0)   --normal case
                  --{{{  
                  SEQ
                    Carry := 1  -- work to do
                    Xfrac := Xfrac \/ Sign
                    Yfrac := Yfrac \/ Sign
                  --}}}
                (Yexp \/ Yfrac) = 0           --Y is zero
                  --{{{  quotient is undefined
                  SEQ
                    Ans := RemZeroNaN
                    Error := TRUE
                  --}}}
                (Xexp \/ Xfrac) = 0           --X is zero
                  --{{{  quotient is zero
                  SEQ
                    Ans := X
                    Quotient := 0
                  --}}}
                TRUE                          --one or other denormalised
                  --{{{  
                  SEQ
                    Carry := 1                --work to do
                    IF
                      Xexp <> 0               --set leading bit
                        Xfrac := Xfrac \/ Sign
                      TRUE                    --set correct exponent
                        Xexp := 1
                    IF
                      Yexp <> 0
                        Yfrac := Yfrac \/ Sign
                      TRUE
                        Yexp := 1
                  --}}}
              --}}}
            TRUE     -- at least one is inf/nan
              SEQ    -- quotient is undefined
                Error := TRUE
                IF
                  (Xexp = RealExp) AND (Yexp = RealExp)  --both NAN or inf
                    --{{{  
                    IF
                      (Xfrac \/ Yfrac) = 0  -- both inf
                        Ans := RemInfNaN
                      Yfrac > Xfrac         -- one a nan so return larger one
                        Ans := Y
                      TRUE
                        Ans := X
                    --}}}
                  Xexp = RealExp                    --X infinity/NaN
                    --{{{  
                    IF
                      Xfrac <> 0                    --X is NaN
                        Ans := X
                      TRUE                          --rem
                        Ans := RemInfNaN
                    --}}}
                  Yfrac <> 0                        --Y is NaN
                    --{{{  
                    Ans := Y                        --keep NaN
                    --}}}
                  TRUE                              --Y infinity
                    --{{{  
                    Ans := X
                    --}}}
          --}}}
          --}}}
          --{{{  evaluate
          IF
            Carry = 0                         --Answer set up
              Result := Ans
            TRUE
              SEQ
                --{{{  calculate remainder
                IF
                  Yexp = 1                       --possible denorm RHS
                    SEQ                          --normalise rhs
                      Places,  Yfrac,  Guard := NORMALISE ( Yfrac,  0)
                      Yexp := Yexp - Places      --ensure lhs normal too
                      Places,  Xfrac,  Guard := NORMALISE ( Xfrac,  0)
                      Xexp := Xexp - Places
                  TRUE
                    SKIP
                Ans := X /\ Sign
                Places := Xexp - Yexp
                IF
                  Places >= 0                    --general case
                    SEQ
                      Carry := BitsPerWord - (Places /\ (BitsPerWord - 1))
                      Xfrac,  Guard := SHIFTRIGHT ( Xfrac,  0,  Carry)
                      Guard,  Xfrac := LONGDIV ( Xfrac,  Guard,  Yfrac)
                      WHILE Places >= BitsPerWord
                        SEQ
                          Guard,  Xfrac := LONGDIV ( Xfrac,  0,  Yfrac)
                          Places := Places - BitsPerWord
                      IF
                        Xfrac = 0                --divides exactly
                          SEQ
                            Xexp := 0
                            Quotient := Guard
                        TRUE
                          SEQ                    --see if over half
                            Carry,  Xexp := LONGDIFF ( Yfrac >> 1,  Xfrac,  0)
                            IF
                              (Carry <> 0) OR ((Xexp = 0) AND ((Guard /\ 1) <> 0))--round up
                                SEQ -- ### add one to guard here ???
                                  Ans := Ans >< Sign      --negate answer
                                  Xfrac := Yfrac MINUS Xfrac
                                  Quotient := Guard + 1
                              TRUE                        --round up
                                Quotient := Guard
                            Xexp := Yexp
                  Places = (-1)                  --get ans by compare
                    SEQ
                      Carry,  Guard := LONGDIFF ( Yfrac,  Xfrac,  0)
                      IF
                        Carry = 0                --X is answer
                          Quotient := 0
                        TRUE                     --Y - X is answer
                          SEQ
                            Quotient := 1
                            Ans := Ans >< Sign   --invert sign
                            Xfrac := Yfrac MINUS (Xfrac >> 1)
                            Xexp := Yexp
                  TRUE                           --always X
                    Quotient := 0
                Places,  Xfrac,  Guard := NORMALISE ( Xfrac,  0)
                Xexp := Xexp - Places
                IF
                  Xexp <= 0                     --gone denorm
                    SEQ
                      Xfrac,  Guard := SHIFTRIGHT ( Xfrac,  0,  1 - Xexp)
                      Xexp := 0
                  TRUE
                    SKIP
                --}}}
                --{{{  pack result
                Xexp,  Xfrac := SHIFTRIGHT ( Xexp,  Xfrac << 1,  RealShift + 1)
                Result := Ans \/ Xfrac
                --}}}
                --{{{  adjust sign of quotient
                IF
                  ((X >< Y) /\ Sign) <> 0  -- signs differ
                    Quotient := - Quotient
                  TRUE
                    SKIP
                --}}}
          --}}}
        RESULT Error, Quotient, Result
    :
    --}}}
    SEQ
      --{{{  extract exponents
      VAL INT Y.int RETYPES Y:
      exp1, frac := SHIFTLEFT (0, Y.int << 1, RealShift)
      VAL INT Z.int RETYPES Z:
      exp2, frac := SHIFTLEFT (0, Z.int << 1, RealShift)
      --}}}
      b, N, X := IEEE32QUOTREM (Y, Z)
      IF
        (exp1 - exp2) <= Max.Diff
          SEQ
            X := X - ((REAL32 ROUND N) * Z.err)
            INT32 Nprimed :
            BOOL bprimed :
            SEQ
              -- take another remainder in case the correction has taken us
              -- out of range :
              bprimed, Nprimed, X := IEEE32QUOTREM (X, Z)
              b := NOT (b OR bprimed) -- true unless an error
              N := N + Nprimed
        TRUE
          b := FALSE
    RESULT b, N, X
:
--}}}

