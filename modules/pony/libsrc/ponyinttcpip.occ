-- Copyright: Mario Schweigler (C) 2005-2006
-- Institution: Computing Laboratory, University of Kent, Canterbury, UK
-- Description: pony internal TCP/IP code file

-- This program is free software; you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 2 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program; if not, write to the Free Software
-- Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
-- MA 02110-1301, USA.

--{{{  Compiler declarations
#INCLUDE "sock.module"
#INCLUDE "ponylib.inc"
#INCLUDE "ponyint.inc"
#INCLUDE "ponyinttcpip.inc"
#USE "ponyinttcpipsock.tce"
--}}}

--{{{  Enable/disable ping-pong time benchmark
--#DEFINE BENCHMARK.PINGPONGTIME
--}}}

--{{{  Processes

--{{{  Link-outputters

--{{{  PROC pony.int.link.out.fornctmgr.alloc
-- Parameters: own.chain.handle.svr | server-end of own chain-handle
--             next.chain.handle    | next chain-handle (client-end)
--             remote.node.id       | VAL: remote node-ID
--             nct.mgr.handle       | NCT-manager-handle (client-end)
--             output.msgs          | VAL: output messages?
--             int.msg.handle       | internal message-handle (client-end)
--             dir.type             | VAL: direction-type of the end to be allocated
--             share.type.alloc     | VAL: share-type of the end to be allocated
--             share.type.opposite  | VAL: share-type of the opposite end
--             type.hash            | VAL: type-hash of the NCT to be allocated
--             nct.name             | name of the NCT
PROC pony.int.link.out.fornctmgr.alloc (PONY.INT.TCPIP.LINKOUTCHAINHANDLE? own.chain.handle.svr,
                                        PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle,
                                        VAL INT remote.node.id,
                                        SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle,
                                        VAL BOOL output.msgs,
                                        SHARED PONY.INT.MSGHANDLE! int.msg.handle,
                                        VAL INT dir.type, share.type.alloc,
                                                share.type.opposite, type.hash,
                                        MOBILE []BYTE nct.name)
  SEQ
    -- Wait for start signal
    BOOL any:
    own.chain.handle.svr[ready] ? any
    --{{{  IN message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.fornctmgr.alloc "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": IN own.chainh: [any-int]"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    -- Pass message on to NCT-manager
    CLAIM nct.mgr.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.fornctmgr.alloc "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT nctmgrh: alloc; "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; "; "
                int.msg.handle[to.handler] ! msg.int; dir.type
                int.msg.handle[to.handler] ! msg.str; "; "
                int.msg.handle[to.handler] ! msg.int; share.type.alloc
                int.msg.handle[to.handler] ! msg.str; "; "
                int.msg.handle[to.handler] ! msg.int; share.type.opposite
                int.msg.handle[to.handler] ! msg.str; "; "
                int.msg.handle[to.handler] ! msg.hex; type.hash
                int.msg.handle[to.handler] ! msg.str; "; *""
                int.msg.handle[to.handler] ! msg.str; CLONE nct.name
                int.msg.handle[to.handler] ! msg.str; "*""
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: node-ID of the kernel making the request;
        --           direction-type of the end to be allocated
        --             (0 = client-end, 1 = server-end);
        --           share-type of the end to be allocated
        --             (1 = unshared, 2 = shared);
        --           share-type of the opposite end
        --             (0 = unknown, 1 = unshared, 2 = shared);
        --           type-hash of the NCT to be allocated;
        --           name of the NCT
        nct.mgr.handle[to.mgr] ! alloc; remote.node.id; dir.type;
                                        share.type.alloc; share.type.opposite;
                                        type.hash; nct.name
    -- Send next start signal
    --{{{  OUT message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.fornctmgr.alloc "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": OUT next.chainh: TRUE"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    next.chain.handle[ready] ! TRUE
:
--}}}
--{{{  PROC pony.int.link.out.formainkernel.alloc.error
-- Parameters: own.chain.handle.svr | server-end of own chain-handle
--             next.chain.handle    | next chain-handle (client-end)
--             remote.node.id       | VAL: remote node-ID
--             kernel.reply.handle  | kernel-reply-handle (client-end)
--             output.msgs          | VAL: output messages?
--             int.msg.handle       | internal message-handle (client-end)
--             result               | VAL: result
PROC pony.int.link.out.formainkernel.alloc.error (PONY.INT.TCPIP.LINKOUTCHAINHANDLE? own.chain.handle.svr,
                                                  PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle,
                                                  VAL INT remote.node.id,
                                                  SHARED PONY.INT.KERNELREPLYHANDLE! kernel.reply.handle,
                                                  VAL BOOL output.msgs,
                                                  SHARED PONY.INT.MSGHANDLE! int.msg.handle,
                                                  VAL INT result)
  SEQ
    -- Wait for start signal
    BOOL any:
    own.chain.handle.svr[ready] ? any
    --{{{  IN message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.formainkernel.alloc.error "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": IN own.chainh: [any-int]"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    -- Pass message on to main kernel
    CLAIM kernel.reply.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.formainkernel.alloc.error "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT kernelreplyh: alloc.error; "
                int.msg.handle[to.handler] ! msg.int; result
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: result
        kernel.reply.handle[to.kernel] ! alloc.error; result
    -- Send next start signal
    --{{{  OUT message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.formainkernel.alloc.error "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": OUT next.chainh: TRUE"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    next.chain.handle[ready] ! TRUE
:
--}}}
--{{{  PROC pony.int.link.out.formainkernel.alloc.confirm
-- Parameters: own.chain.handle.svr | server-end of own chain-handle
--             next.chain.handle    | next chain-handle (client-end)
--             remote.node.id       | VAL: remote node-ID
--             kernel.reply.handle  | kernel-reply-handle (client-end)
--             output.msgs          | VAL: output messages?
--             int.msg.handle       | internal message-handle (client-end)
--             nct.id               | VAL: NCT-ID of the newly allocated end
PROC pony.int.link.out.formainkernel.alloc.confirm (PONY.INT.TCPIP.LINKOUTCHAINHANDLE? own.chain.handle.svr,
                                                    PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle,
                                                    VAL INT remote.node.id,
                                                    SHARED PONY.INT.KERNELREPLYHANDLE! kernel.reply.handle,
                                                    VAL BOOL output.msgs,
                                                    SHARED PONY.INT.MSGHANDLE! int.msg.handle,
                                                    VAL INT nct.id)
  SEQ
    -- Wait for start signal
    BOOL any:
    own.chain.handle.svr[ready] ? any
    --{{{  IN message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.formainkernel.alloc.confirm "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": IN own.chainh: [any-int]"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    -- Pass message on to main kernel
    CLAIM kernel.reply.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.formainkernel.alloc.confirm "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT kernelreplyh: alloc.confirm; "
                int.msg.handle[to.handler] ! msg.int; nct.id
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: NCT-ID of the newly allocated end
        kernel.reply.handle[to.kernel] ! alloc.confirm; nct.id
    -- Send next start signal
    --{{{  OUT message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.formainkernel.alloc.confirm "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": OUT next.chainh: TRUE"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    next.chain.handle[ready] ! TRUE
:
--}}}
--{{{  PROC pony.int.link.out.fornctmgr.make.ctb.networked
-- Parameters: own.chain.handle.svr | server-end of own chain-handle
--             next.chain.handle    | next chain-handle (client-end)
--             remote.node.id       | VAL: remote node-ID
--             nct.mgr.handle       | NCT-manager-handle (client-end)
--             output.msgs          | VAL: output messages?
--             int.msg.handle       | internal message-handle (client-end)
--             request.nct.id       | VAL: NCT-ID of the decode-handler making the request
--             request.chan.id      | VAL: channel-ID of the decode-handler making the request
--             initial.cli.claimed  | VAL: client-end initially claimed?
--             initial.svr.claimed  | VAL: server-end initially claimed?
PROC pony.int.link.out.fornctmgr.make.ctb.networked (PONY.INT.TCPIP.LINKOUTCHAINHANDLE? own.chain.handle.svr,
                                                     PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle,
                                                     VAL INT remote.node.id,
                                                     SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle,
                                                     VAL BOOL output.msgs,
                                                     SHARED PONY.INT.MSGHANDLE! int.msg.handle,
                                                     VAL INT request.nct.id, request.chan.id,
                                                     VAL BOOL initial.cli.claimed, initial.svr.claimed)
  SEQ
    -- Wait for start signal
    BOOL any:
    own.chain.handle.svr[ready] ? any
    --{{{  IN message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.fornctmgr.make.ctb.networked "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": IN own.chainh: [any-int]"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    -- Pass message on to NCT-manager
    CLAIM nct.mgr.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.fornctmgr.make.ctb.networked "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT nctmgrh: make.ctb.networked; "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; "; "
                int.msg.handle[to.handler] ! msg.int; request.nct.id
                int.msg.handle[to.handler] ! msg.str; "; "
                int.msg.handle[to.handler] ! msg.int; request.chan.id
                int.msg.handle[to.handler] ! msg.str; "; "
                int.msg.handle[to.handler] ! msg.bool; initial.cli.claimed
                int.msg.handle[to.handler] ! msg.str; "; "
                int.msg.handle[to.handler] ! msg.bool; initial.svr.claimed
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: node-ID of the decode-handler making the request;
        --           NCT-ID of the decode-handler making the request;
        --           channel-ID of the decode-handler making the request;
        --           client-end initially claimed?;
        --           server-end initially claimed?
        nct.mgr.handle[to.mgr] ! make.ctb.networked; remote.node.id;
                                 request.nct.id; request.chan.id;
                                 initial.cli.claimed; initial.svr.claimed
    -- Send next start signal
    --{{{  OUT message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.fornctmgr.make.ctb.networked "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": OUT next.chainh: TRUE"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    next.chain.handle[ready] ! TRUE
:
--}}}
--{{{  PROC pony.int.link.out.fordechandler.make.ctb.networked.confirm
-- Parameters: own.chain.handle.svr | server-end of own chain-handle
--             next.chain.handle    | next chain-handle (client-end)
--             remote.node.id       | VAL: remote node-ID
--             ctb.mgr.handle       | CTB-manager-handle (client-end)
--             output.msgs          | VAL: output messages?
--             int.msg.handle       | internal message-handle (client-end)
--             recipient.nct.id     | VAL: NCT-ID of the recipient decode-handler;
--             recipient.chan.id    | VAL: channel-ID of the recipient decode-handler;
--             nct.id               | VAL: NCT-ID of the newly allocated end
PROC pony.int.link.out.fordechandler.make.ctb.networked.confirm (PONY.INT.TCPIP.LINKOUTCHAINHANDLE? own.chain.handle.svr,
                                                                 PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle,
                                                                 VAL INT remote.node.id,
                                                                 SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle,
                                                                 VAL BOOL output.msgs,
                                                                 SHARED PONY.INT.MSGHANDLE! int.msg.handle,
                                                                 VAL INT recipient.nct.id,
                                                                         recipient.chan.id, nct.id)
  SHARED PONY.INT.CTBINSTANTHANDLE! ctb.instant.handle:
  SHARED PONY.INT.DECODEREPLYHANDLE! dec.reply.handle:
  SEQ
    -- Wait for start signal
    BOOL any:
    own.chain.handle.svr[ready] ? any
    --{{{  IN message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.fordechandler.make.ctb.networked.confirm "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": IN own.chainh: [any-int]"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    -- Get CTB-instant-handle from CTB-manager
    CLAIM ctb.mgr.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.fordechandler.make.ctb.networked.confirm "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.instant.handle; "
                int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: NCT-ID
        ctb.mgr.handle[to.mgr] ! get.ctb.instant.handle; recipient.nct.id
        -- Get reply
        -- Carrying: CTB-instant-handle
        ctb.mgr.handle[from.mgr] ? CASE get.ctb.instant.handle.confirm;
                                        ctb.instant.handle
        --{{{  IN message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.fordechandler.make.ctb.networked.confirm "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.instant.handle.confirm; [cli-end]"
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
    -- Get decode-reply-handle from CTB-instant-handler
    CLAIM ctb.instant.handle
      SEQ
        -- Get current remote node
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.fordechandler.make.ctb.networked.confirm "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT ctbinsth "
                int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                int.msg.handle[to.handler] ! msg.str; ": get.dec.reply.handle; "
                int.msg.handle[to.handler] ! msg.int; recipient.chan.id
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: channel-ID
        ctb.instant.handle[to.handler] ! get.dec.reply.handle; recipient.chan.id
        -- Get reply
        -- Carrying: decode-reply-handle
        ctb.instant.handle[from.handler] ? CASE get.dec.reply.handle.confirm;
                                                dec.reply.handle
        --{{{  IN message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.fordechandler.make.ctb.networked.confirm "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": IN ctbinsth "
                int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                int.msg.handle[to.handler] ! msg.str; ": get.dec.reply.handle.confirm; [cli-end]"
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
    -- Pass message on to decode-handler
    CLAIM dec.reply.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.fordechandler.make.ctb.networked.confirm "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT decreplyh "
                int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                int.msg.handle[to.handler] ! msg.str; "/"
                int.msg.handle[to.handler] ! msg.int; recipient.chan.id
                int.msg.handle[to.handler] ! msg.str; ": make.ctb.networked.confirm; "
                int.msg.handle[to.handler] ! msg.int; nct.id
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: NCT-ID of the newly allocated end
        dec.reply.handle[to.handler] ! make.ctb.networked.confirm; nct.id
    -- Send next start signal
    --{{{  OUT message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.fordechandler.make.ctb.networked.confirm "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": OUT next.chainh: TRUE"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    next.chain.handle[ready] ! TRUE
:
--}}}
--{{{  PROC pony.int.link.out.forncthandler.claim.cli
-- Parameters: own.chain.handle.svr | server-end of own chain-handle
--             next.chain.handle    | next chain-handle (client-end)
--             remote.node.id       | VAL: remote node-ID
--             nct.mgr.handle       | NCT-manager-handle (client-end)
--             output.msgs          | VAL: output messages?
--             int.msg.handle       | internal message-handle (client-end)
--             request.nct.id       | VAL: NCT-ID of the CTB-handler making the request
PROC pony.int.link.out.forncthandler.claim.cli (PONY.INT.TCPIP.LINKOUTCHAINHANDLE? own.chain.handle.svr,
                                                PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle,
                                                VAL INT remote.node.id,
                                                SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle,
                                                VAL BOOL output.msgs,
                                                SHARED PONY.INT.MSGHANDLE! int.msg.handle,
                                                VAL INT request.nct.id)
  SHARED PONY.INT.NCTHANDLE! nct.handle:
  SEQ
    -- Wait for start signal
    BOOL any:
    own.chain.handle.svr[ready] ? any
    --{{{  IN message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.claim.cli "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": IN own.chainh: [any-int]"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    -- Get NCT-handle from NCT-manager
    CLAIM nct.mgr.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.claim.cli "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT nctmgrh: get.nct.handle; "
                int.msg.handle[to.handler] ! msg.int; request.nct.id
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: NCT-ID
        nct.mgr.handle[to.mgr] ! get.nct.handle; request.nct.id
        -- Get reply
        -- Carrying: NCT-handle
        nct.mgr.handle[from.mgr] ? CASE get.nct.handle.confirm;
                                        nct.handle
        --{{{  IN message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.claim.cli "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": IN nctmgrh: get.nct.handle.confirm; [cli-end]"
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
    -- Pass message on to NCT-handler
    CLAIM nct.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.claim.cli "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT ncth "
                int.msg.handle[to.handler] ! msg.int; request.nct.id
                int.msg.handle[to.handler] ! msg.str; ": claim.cli; "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: node-ID of the CTB-handler making the request
        nct.handle[to.handler] ! claim.cli; remote.node.id
    -- Send next start signal
    --{{{  OUT message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.claim.cli "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": OUT next.chainh: TRUE"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    next.chain.handle[ready] ! TRUE
:
--}}}
--{{{  PROC pony.int.link.out.forncthandler.claim.svr
-- Parameters: own.chain.handle.svr | server-end of own chain-handle
--             next.chain.handle    | next chain-handle (client-end)
--             remote.node.id       | VAL: remote node-ID
--             nct.mgr.handle       | NCT-manager-handle (client-end)
--             output.msgs          | VAL: output messages?
--             int.msg.handle       | internal message-handle (client-end)
--             request.nct.id       | VAL: NCT-ID of the CTB-handler making the request
PROC pony.int.link.out.forncthandler.claim.svr (PONY.INT.TCPIP.LINKOUTCHAINHANDLE? own.chain.handle.svr,
                                                PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle,
                                                VAL INT remote.node.id,
                                                SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle,
                                                VAL BOOL output.msgs,
                                                SHARED PONY.INT.MSGHANDLE! int.msg.handle,
                                                VAL INT request.nct.id)
  SHARED PONY.INT.NCTHANDLE! nct.handle:
  SEQ
    -- Wait for start signal
    BOOL any:
    own.chain.handle.svr[ready] ? any
    --{{{  IN message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.claim.svr "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": IN own.chainh: [any-int]"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    -- Get NCT-handle from NCT-manager
    CLAIM nct.mgr.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.claim.svr "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT nctmgrh: get.nct.handle; "
                int.msg.handle[to.handler] ! msg.int; request.nct.id
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: NCT-ID
        nct.mgr.handle[to.mgr] ! get.nct.handle; request.nct.id
        -- Get reply
        -- Carrying: NCT-handle
        nct.mgr.handle[from.mgr] ? CASE get.nct.handle.confirm;
                                        nct.handle
        --{{{  IN message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.claim.svr "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": IN nctmgrh: get.nct.handle.confirm; [cli-end]"
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
    -- Pass message on to NCT-handler
    CLAIM nct.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.claim.svr "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT ncth "
                int.msg.handle[to.handler] ! msg.int; request.nct.id
                int.msg.handle[to.handler] ! msg.str; ": claim.svr; "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: node-ID of the CTB-handler making the request
        nct.handle[to.handler] ! claim.svr; remote.node.id
    -- Send next start signal
    --{{{  OUT message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.claim.svr "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": OUT next.chainh: TRUE"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    next.chain.handle[ready] ! TRUE
:
--}}}
--{{{  PROC pony.int.link.out.forncthandler.new.other.end.confirm
-- Parameters: own.chain.handle.svr | server-end of own chain-handle
--             next.chain.handle    | next chain-handle (client-end)
--             remote.node.id       | VAL: remote node-ID
--             nct.mgr.handle       | NCT-manager-handle (client-end)
--             output.msgs          | VAL: output messages?
--             int.msg.handle       | internal message-handle (client-end)
--             request.nct.id       | VAL: NCT-ID of the CTB-handler making the request
PROC pony.int.link.out.forncthandler.new.other.end.confirm (PONY.INT.TCPIP.LINKOUTCHAINHANDLE? own.chain.handle.svr,
                                                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle,
                                                            VAL INT remote.node.id,
                                                            SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle,
                                                            VAL BOOL output.msgs,
                                                            SHARED PONY.INT.MSGHANDLE! int.msg.handle,
                                                            VAL INT request.nct.id)
  SHARED PONY.INT.NCTHANDLE! nct.handle:
  SEQ
    -- Wait for start signal
    BOOL any:
    own.chain.handle.svr[ready] ? any
    --{{{  IN message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.new.other.end.confirm "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": IN own.chainh: [any-int]"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    -- Get NCT-handle from NCT-manager
    CLAIM nct.mgr.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.new.other.end.confirm "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT nctmgrh: get.nct.handle; "
                int.msg.handle[to.handler] ! msg.int; request.nct.id
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: NCT-ID
        nct.mgr.handle[to.mgr] ! get.nct.handle; request.nct.id
        -- Get reply
        -- Carrying: NCT-handle
        nct.mgr.handle[from.mgr] ? CASE get.nct.handle.confirm;
                                        nct.handle
        --{{{  IN message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.new.other.end.confirm "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": IN nctmgrh: get.nct.handle.confirm; [cli-end]"
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
    -- Pass message on to NCT-handler
    CLAIM nct.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.new.other.end.confirm "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT ncth "
                int.msg.handle[to.handler] ! msg.int; request.nct.id
                int.msg.handle[to.handler] ! msg.str; ": new.other.end.confirm"
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        nct.handle[to.handler] ! new.other.end.confirm
    -- Send next start signal
    --{{{  OUT message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "forncthandler.new.other.end.confirm "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": OUT next.chainh: TRUE"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    next.chain.handle[ready] ! TRUE
:
--}}}
--{{{  PROC pony.int.link.out.forncthandler.release.cli
-- Parameters: own.chain.handle.svr | server-end of own chain-handle
--             next.chain.handle    | next chain-handle (client-end)
--             remote.node.id       | VAL: remote node-ID
--             nct.mgr.handle       | NCT-manager-handle (client-end)
--             output.msgs          | VAL: output messages?
--             int.msg.handle       | internal message-handle (client-end)
--             request.nct.id       | VAL: NCT-ID of the CTB-handler making the request
PROC pony.int.link.out.forncthandler.release.cli (PONY.INT.TCPIP.LINKOUTCHAINHANDLE? own.chain.handle.svr,
                                                  PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle,
                                                  VAL INT remote.node.id,
                                                  SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle,
                                                  VAL BOOL output.msgs,
                                                  SHARED PONY.INT.MSGHANDLE! int.msg.handle,
                                                  VAL INT request.nct.id)
  SHARED PONY.INT.NCTHANDLE! nct.handle:
  SEQ
    -- Wait for start signal
    BOOL any:
    own.chain.handle.svr[ready] ? any
    --{{{  IN message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.release.cli "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": IN own.chainh: [any-int]"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    -- Get NCT-handle from NCT-manager
    CLAIM nct.mgr.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.release.cli "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT nctmgrh: get.nct.handle; "
                int.msg.handle[to.handler] ! msg.int; request.nct.id
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: NCT-ID
        nct.mgr.handle[to.mgr] ! get.nct.handle; request.nct.id
        -- Get reply
        -- Carrying: NCT-handle
        nct.mgr.handle[from.mgr] ? CASE get.nct.handle.confirm;
                                        nct.handle
        --{{{  IN message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.release.cli "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": IN nctmgrh: get.nct.handle.confirm; [cli-end]"
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
    -- Pass message on to NCT-handler
    CLAIM nct.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.release.cli "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT ncth "
                int.msg.handle[to.handler] ! msg.int; request.nct.id
                int.msg.handle[to.handler] ! msg.str; ": release.cli"
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        nct.handle[to.handler] ! release.cli
    -- Send next start signal
    --{{{  OUT message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.release.cli "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": OUT next.chainh: TRUE"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    next.chain.handle[ready] ! TRUE
:
--}}}
--{{{  PROC pony.int.link.out.forncthandler.release.svr
-- Parameters: own.chain.handle.svr | server-end of own chain-handle
--             next.chain.handle    | next chain-handle (client-end)
--             remote.node.id       | VAL: remote node-ID
--             nct.mgr.handle       | NCT-manager-handle (client-end)
--             output.msgs          | VAL: output messages?
--             int.msg.handle       | internal message-handle (client-end)
--             request.nct.id       | VAL: NCT-ID of the CTB-handler making the request
PROC pony.int.link.out.forncthandler.release.svr (PONY.INT.TCPIP.LINKOUTCHAINHANDLE? own.chain.handle.svr,
                                                  PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle,
                                                  VAL INT remote.node.id,
                                                  SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle,
                                                  VAL BOOL output.msgs,
                                                  SHARED PONY.INT.MSGHANDLE! int.msg.handle,
                                                  VAL INT request.nct.id)
  SHARED PONY.INT.NCTHANDLE! nct.handle:
  SEQ
    -- Wait for start signal
    BOOL any:
    own.chain.handle.svr[ready] ? any
    --{{{  IN message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.release.svr "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": IN own.chainh: [any-int]"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    -- Get NCT-handle from NCT-manager
    CLAIM nct.mgr.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.release.svr "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT nctmgrh: get.nct.handle; "
                int.msg.handle[to.handler] ! msg.int; request.nct.id
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: NCT-ID
        nct.mgr.handle[to.mgr] ! get.nct.handle; request.nct.id
        -- Get reply
        -- Carrying: NCT-handle
        nct.mgr.handle[from.mgr] ? CASE get.nct.handle.confirm;
                                        nct.handle
        --{{{  IN message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.release.svr "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": IN nctmgrh: get.nct.handle.confirm; [cli-end]"
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
    -- Pass message on to NCT-handler
    CLAIM nct.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.release.svr "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT ncth "
                int.msg.handle[to.handler] ! msg.int; request.nct.id
                int.msg.handle[to.handler] ! msg.str; ": release.svr"
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        nct.handle[to.handler] ! release.svr
    -- Send next start signal
    --{{{  OUT message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.release.svr "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": OUT next.chainh: TRUE"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    next.chain.handle[ready] ! TRUE
:
--}}}
--{{{  PROC pony.int.link.out.forncthandler.eoi.done
-- Parameters: own.chain.handle.svr | server-end of own chain-handle
--             next.chain.handle    | next chain-handle (client-end)
--             remote.node.id       | VAL: remote node-ID
--             nct.mgr.handle       | NCT-manager-handle (client-end)
--             output.msgs          | VAL: output messages?
--             int.msg.handle       | internal message-handle (client-end)
--             request.nct.id       | VAL: NCT-ID of the CTB-handler making the request
PROC pony.int.link.out.forncthandler.eoi.done (PONY.INT.TCPIP.LINKOUTCHAINHANDLE? own.chain.handle.svr,
                                               PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle,
                                               VAL INT remote.node.id,
                                               SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle,
                                               VAL BOOL output.msgs,
                                               SHARED PONY.INT.MSGHANDLE! int.msg.handle,
                                               VAL INT request.nct.id)
  SHARED PONY.INT.NCTHANDLE! nct.handle:
  SEQ
    -- Wait for start signal
    BOOL any:
    own.chain.handle.svr[ready] ? any
    --{{{  IN message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.eoi.done "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": IN own.chainh: [any-int]"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    -- Get NCT-handle from NCT-manager
    CLAIM nct.mgr.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.eoi.done "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT nctmgrh: get.nct.handle; "
                int.msg.handle[to.handler] ! msg.int; request.nct.id
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: NCT-ID
        nct.mgr.handle[to.mgr] ! get.nct.handle; request.nct.id
        -- Get reply
        -- Carrying: NCT-handle
        nct.mgr.handle[from.mgr] ? CASE get.nct.handle.confirm;
                                        nct.handle
        --{{{  IN message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.eoi.done "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": IN nctmgrh: get.nct.handle.confirm; [cli-end]"
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
    -- Pass message on to NCT-handler
    CLAIM nct.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.eoi.done "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT ncth "
                int.msg.handle[to.handler] ! msg.int; request.nct.id
                int.msg.handle[to.handler] ! msg.str; ": eoi.done; "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: node-ID of the CTB-handler making the request
        nct.handle[to.handler] ! eoi.done; remote.node.id
    -- Send next start signal
    --{{{  OUT message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.forncthandler.eoi.done "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": OUT next.chainh: TRUE"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    next.chain.handle[ready] ! TRUE
:
--}}}
--{{{  PROC pony.int.link.out.forctbhandler.reclient.claim.confirm.nootherend
-- Parameters: own.chain.handle.svr | server-end of own chain-handle
--             next.chain.handle    | next chain-handle (client-end)
--             remote.node.id       | VAL: remote node-ID
--             ctb.mgr.handle       | CTB-manager-handle (client-end)
--             output.msgs          | VAL: output messages?
--             int.msg.handle       | internal message-handle (client-end)
--             recipient.nct.id     | VAL: NCT-ID of the recipient CTB-handler
PROC pony.int.link.out.forctbhandler.reclient.claim.confirm.nootherend (PONY.INT.TCPIP.LINKOUTCHAINHANDLE? own.chain.handle.svr,
                                                                        PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle,
                                                                        VAL INT remote.node.id,
                                                                        SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle,
                                                                        VAL BOOL output.msgs,
                                                                        SHARED PONY.INT.MSGHANDLE! int.msg.handle,
                                                                        VAL INT recipient.nct.id)
  SHARED PONY.INT.CTBMAINHANDLE! ctb.main.handle:
  SEQ
    -- Wait for start signal
    BOOL any:
    own.chain.handle.svr[ready] ? any
    --{{{  IN message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reclient.claim.confirm.nootherend "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": IN own.chainh: [any-int]"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    -- Get CTB-main-handle from CTB-manager
    CLAIM ctb.mgr.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reclient.claim.confirm.nootherend "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.main.handle; "
                int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: NCT-ID
        ctb.mgr.handle[to.mgr] ! get.ctb.main.handle; recipient.nct.id
        -- Get reply
        -- Carrying: CTB-main-handle
        ctb.mgr.handle[from.mgr] ? CASE get.ctb.main.handle.confirm;
                                        ctb.main.handle
        --{{{  IN message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reclient.claim.confirm.nootherend "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.main.handle.confirm; [cli-end]"
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
    -- Pass message on to CTB-handler
    CLAIM ctb.main.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reclient.claim.confirm.nootherend "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT ctbmainh "
                int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                int.msg.handle[to.handler] ! msg.str; " [from.ncthandler.re.client]: claim.confirm.nootherend"
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        ctb.main.handle[from.ncthandler.re.client] ! claim.confirm.nootherend
    -- Send next start signal
    --{{{  OUT message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reclient.claim.confirm.nootherend "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": OUT next.chainh: TRUE"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    next.chain.handle[ready] ! TRUE
:
--}}}
--{{{  PROC pony.int.link.out.forctbhandler.reserver.claim.confirm.nootherend
-- Parameters: own.chain.handle.svr | server-end of own chain-handle
--             next.chain.handle    | next chain-handle (client-end)
--             remote.node.id       | VAL: remote node-ID
--             ctb.mgr.handle       | CTB-manager-handle (client-end)
--             output.msgs          | VAL: output messages?
--             int.msg.handle       | internal message-handle (client-end)
--             recipient.nct.id     | VAL: NCT-ID of the recipient CTB-handler
PROC pony.int.link.out.forctbhandler.reserver.claim.confirm.nootherend (PONY.INT.TCPIP.LINKOUTCHAINHANDLE? own.chain.handle.svr,
                                                                        PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle,
                                                                        VAL INT remote.node.id,
                                                                        SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle,
                                                                        VAL BOOL output.msgs,
                                                                        SHARED PONY.INT.MSGHANDLE! int.msg.handle,
                                                                        VAL INT recipient.nct.id)
  SHARED PONY.INT.CTBMAINHANDLE! ctb.main.handle:
  SEQ
    -- Wait for start signal
    BOOL any:
    own.chain.handle.svr[ready] ? any
    --{{{  IN message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reserver.claim.confirm.nootherend "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": IN own.chainh: [any-int]"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    -- Get CTB-main-handle from CTB-manager
    CLAIM ctb.mgr.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reserver.claim.confirm.nootherend "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.main.handle; "
                int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: NCT-ID
        ctb.mgr.handle[to.mgr] ! get.ctb.main.handle; recipient.nct.id
        -- Get reply
        -- Carrying: CTB-main-handle
        ctb.mgr.handle[from.mgr] ? CASE get.ctb.main.handle.confirm;
                                        ctb.main.handle
        --{{{  IN message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reserver.claim.confirm.nootherend "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.main.handle.confirm; [cli-end]"
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
    -- Pass message on to CTB-handler
    CLAIM ctb.main.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reserver.claim.confirm.nootherend "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT ctbmainh "
                int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                int.msg.handle[to.handler] ! msg.str; " [from.ncthandler.re.server]: claim.confirm.nootherend"
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        ctb.main.handle[from.ncthandler.re.server] ! claim.confirm.nootherend
    -- Send next start signal
    --{{{  OUT message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reserver.claim.confirm.nootherend "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": OUT next.chainh: TRUE"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    next.chain.handle[ready] ! TRUE
:
--}}}
--{{{  PROC pony.int.link.out.forctbhandler.reclient.claim.confirm.otherendclaimed
-- Parameters: own.chain.handle.svr | server-end of own chain-handle
--             next.chain.handle    | next chain-handle (client-end)
--             remote.node.id       | VAL: remote node-ID
--             ctb.mgr.handle       | CTB-manager-handle (client-end)
--             output.msgs          | VAL: output messages?
--             int.msg.handle       | internal message-handle (client-end)
--             recipient.nct.id     | VAL: NCT-ID of the recipient CTB-handler
--             node.id              | VAL: node-ID of the other end's node
PROC pony.int.link.out.forctbhandler.reclient.claim.confirm.otherendclaimed (PONY.INT.TCPIP.LINKOUTCHAINHANDLE? own.chain.handle.svr,
                                                                             PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle,
                                                                             VAL INT remote.node.id,
                                                                             SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle,
                                                                             VAL BOOL output.msgs,
                                                                             SHARED PONY.INT.MSGHANDLE! int.msg.handle,
                                                                             VAL INT recipient.nct.id, node.id)
  SHARED PONY.INT.CTBMAINHANDLE! ctb.main.handle:
  SEQ
    -- Wait for start signal
    BOOL any:
    own.chain.handle.svr[ready] ? any
    --{{{  IN message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reclient.claim.confirm.otherendclaimed "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": IN own.chainh: [any-int]"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    -- Get CTB-main-handle from CTB-manager
    CLAIM ctb.mgr.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reclient.claim.confirm.otherendclaimed "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.main.handle; "
                int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: NCT-ID
        ctb.mgr.handle[to.mgr] ! get.ctb.main.handle; recipient.nct.id
        -- Get reply
        -- Carrying: CTB-main-handle
        ctb.mgr.handle[from.mgr] ? CASE get.ctb.main.handle.confirm;
                                        ctb.main.handle
        --{{{  IN message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reclient.claim.confirm.otherendclaimed "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.main.handle.confirm; [cli-end]"
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
    -- Pass message on to CTB-handler
    CLAIM ctb.main.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reclient.claim.confirm.otherendclaimed "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT ctbmainh "
                int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                int.msg.handle[to.handler] ! msg.str; " [from.ncthandler.re.client]: claim.confirm.otherendclaimed; "
                int.msg.handle[to.handler] ! msg.int; node.id
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: node-ID of the other end's node
        ctb.main.handle[from.ncthandler.re.client] ! claim.confirm.otherendclaimed; node.id
    -- Send next start signal
    --{{{  OUT message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reclient.claim.confirm.otherendclaimed "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": OUT next.chainh: TRUE"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    next.chain.handle[ready] ! TRUE
:
--}}}
--{{{  PROC pony.int.link.out.forctbhandler.reserver.claim.confirm.otherendclaimed
-- Parameters: own.chain.handle.svr | server-end of own chain-handle
--             next.chain.handle    | next chain-handle (client-end)
--             remote.node.id       | VAL: remote node-ID
--             ctb.mgr.handle       | CTB-manager-handle (client-end)
--             output.msgs          | VAL: output messages?
--             int.msg.handle       | internal message-handle (client-end)
--             recipient.nct.id     | VAL: NCT-ID of the recipient CTB-handler
--             node.id              | VAL: node-ID of the other end's node
PROC pony.int.link.out.forctbhandler.reserver.claim.confirm.otherendclaimed (PONY.INT.TCPIP.LINKOUTCHAINHANDLE? own.chain.handle.svr,
                                                                             PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle,
                                                                             VAL INT remote.node.id,
                                                                             SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle,
                                                                             VAL BOOL output.msgs,
                                                                             SHARED PONY.INT.MSGHANDLE! int.msg.handle,
                                                                             VAL INT recipient.nct.id, node.id)
  SHARED PONY.INT.CTBMAINHANDLE! ctb.main.handle:
  SEQ
    -- Wait for start signal
    BOOL any:
    own.chain.handle.svr[ready] ? any
    --{{{  IN message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reserver.claim.confirm.otherendclaimed "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": IN own.chainh: [any-int]"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    -- Get CTB-main-handle from CTB-manager
    CLAIM ctb.mgr.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reserver.claim.confirm.otherendclaimed "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.main.handle; "
                int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: NCT-ID
        ctb.mgr.handle[to.mgr] ! get.ctb.main.handle; recipient.nct.id
        -- Get reply
        -- Carrying: CTB-main-handle
        ctb.mgr.handle[from.mgr] ? CASE get.ctb.main.handle.confirm;
                                        ctb.main.handle
        --{{{  IN message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reserver.claim.confirm.otherendclaimed "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.main.handle.confirm; [cli-end]"
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
    -- Pass message on to CTB-handler
    CLAIM ctb.main.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reserver.claim.confirm.otherendclaimed "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT ctbmainh "
                int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                int.msg.handle[to.handler] ! msg.str; " [from.ncthandler.re.server]: claim.confirm.otherendclaimed; "
                int.msg.handle[to.handler] ! msg.int; node.id
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: node-ID of the other end's node
        ctb.main.handle[from.ncthandler.re.server] ! claim.confirm.otherendclaimed; node.id
    -- Send next start signal
    --{{{  OUT message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reserver.claim.confirm.otherendclaimed "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": OUT next.chainh: TRUE"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    next.chain.handle[ready] ! TRUE
:
--}}}
--{{{  PROC pony.int.link.out.forctbhandler.reclient.new.other.end
-- Parameters: own.chain.handle.svr | server-end of own chain-handle
--             next.chain.handle    | next chain-handle (client-end)
--             remote.node.id       | VAL: remote node-ID
--             ctb.mgr.handle       | CTB-manager-handle (client-end)
--             output.msgs          | VAL: output messages?
--             int.msg.handle       | internal message-handle (client-end)
--             recipient.nct.id     | VAL: NCT-ID of the recipient CTB-handler
--             node.id              | VAL: node-ID of the other end's node
PROC pony.int.link.out.forctbhandler.reclient.new.other.end (PONY.INT.TCPIP.LINKOUTCHAINHANDLE? own.chain.handle.svr,
                                                             PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle,
                                                             VAL INT remote.node.id,
                                                             SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle,
                                                             VAL BOOL output.msgs,
                                                             SHARED PONY.INT.MSGHANDLE! int.msg.handle,
                                                             VAL INT recipient.nct.id, node.id)
  SHARED PONY.INT.CTBMAINHANDLE! ctb.main.handle:
  SEQ
    -- Wait for start signal
    BOOL any:
    own.chain.handle.svr[ready] ? any
    --{{{  IN message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reclient.new.other.end "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": IN own.chainh: [any-int]"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    -- Get CTB-main-handle from CTB-manager
    CLAIM ctb.mgr.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reclient.new.other.end "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.main.handle; "
                int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: NCT-ID
        ctb.mgr.handle[to.mgr] ! get.ctb.main.handle; recipient.nct.id
        -- Get reply
        -- Carrying: CTB-main-handle
        ctb.mgr.handle[from.mgr] ? CASE get.ctb.main.handle.confirm;
                                        ctb.main.handle
        --{{{  IN message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reclient.new.other.end "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.main.handle.confirm; [cli-end]"
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
    -- Pass message on to CTB-handler
    CLAIM ctb.main.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reclient.new.other.end "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT ctbmainh "
                int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                int.msg.handle[to.handler] ! msg.str; " [from.ncthandler.re.client]: new.other.end; "
                int.msg.handle[to.handler] ! msg.int; node.id
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: node-ID of the other end's node
        ctb.main.handle[from.ncthandler.re.client] ! new.other.end; node.id
    -- Send next start signal
    --{{{  OUT message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reclient.new.other.end "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": OUT next.chainh: TRUE"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    next.chain.handle[ready] ! TRUE
:
--}}}
--{{{  PROC pony.int.link.out.forctbhandler.reserver.new.other.end
-- Parameters: own.chain.handle.svr | server-end of own chain-handle
--             next.chain.handle    | next chain-handle (client-end)
--             remote.node.id       | VAL: remote node-ID
--             ctb.mgr.handle       | CTB-manager-handle (client-end)
--             output.msgs          | VAL: output messages?
--             int.msg.handle       | internal message-handle (client-end)
--             recipient.nct.id     | VAL: NCT-ID of the recipient CTB-handler
--             node.id              | VAL: node-ID of the other end's node
PROC pony.int.link.out.forctbhandler.reserver.new.other.end (PONY.INT.TCPIP.LINKOUTCHAINHANDLE? own.chain.handle.svr,
                                                             PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle,
                                                             VAL INT remote.node.id,
                                                             SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle,
                                                             VAL BOOL output.msgs,
                                                             SHARED PONY.INT.MSGHANDLE! int.msg.handle,
                                                             VAL INT recipient.nct.id, node.id)
  SHARED PONY.INT.CTBMAINHANDLE! ctb.main.handle:
  SEQ
    -- Wait for start signal
    BOOL any:
    own.chain.handle.svr[ready] ? any
    --{{{  IN message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reserver.new.other.end "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": IN own.chainh: [any-int]"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    -- Get CTB-main-handle from CTB-manager
    CLAIM ctb.mgr.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reserver.new.other.end "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.main.handle; "
                int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: NCT-ID
        ctb.mgr.handle[to.mgr] ! get.ctb.main.handle; recipient.nct.id
        -- Get reply
        -- Carrying: CTB-main-handle
        ctb.mgr.handle[from.mgr] ? CASE get.ctb.main.handle.confirm;
                                        ctb.main.handle
        --{{{  IN message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reserver.new.other.end "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.main.handle.confirm; [cli-end]"
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
    -- Pass message on to CTB-handler
    CLAIM ctb.main.handle
      SEQ
        --{{{  OUT message
        IF
          output.msgs
            CLAIM int.msg.handle
              SEQ
                int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reserver.new.other.end "
                int.msg.handle[to.handler] ! msg.int; remote.node.id
                int.msg.handle[to.handler] ! msg.str; ": OUT ctbmainh "
                int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                int.msg.handle[to.handler] ! msg.str; " [from.ncthandler.re.server]: new.other.end; "
                int.msg.handle[to.handler] ! msg.int; node.id
                int.msg.handle[to.handler] ! msg.end; FALSE
          TRUE
            SKIP
        --}}}
        -- Carrying: node-ID of the other end's node
        ctb.main.handle[from.ncthandler.re.server] ! new.other.end; node.id
    -- Send next start signal
    --{{{  OUT message
    IF
      output.msgs
        CLAIM int.msg.handle
          SEQ
            int.msg.handle[to.handler] ! msg.str; "link.out.forctbhandler.reserver.new.other.end "
            int.msg.handle[to.handler] ! msg.int; remote.node.id
            int.msg.handle[to.handler] ! msg.str; ": OUT next.chainh: TRUE"
            int.msg.handle[to.handler] ! msg.end; FALSE
      TRUE
        SKIP
    --}}}
    next.chain.handle[ready] ! TRUE
:
--}}}

--}}}

--{{{  PROC pony.int.link.handler.tcpip
-- Parameters: own.node.id           | VAL: own node-ID
--             remote.node.id        | VAL: remote node-ID
--             socket                | VAL: socket
--             link.handle.svr       | server-end of link-handle
--             link.mgr.handle       | link-manager-handle (client-end)
--             link.mgr.handle.tcpip | TCP/IP link-manager-handle (client-end)
--             ctb.mgr.handle        | CTB-manager-handle (client-end)
--             nct.mgr.handle        | NCT-manager-handle (client-end)
--             kernel.reply.handle   | kernel-reply-handle (client-end)
--             output.errs           | VAL: output errors?
--             int.err.handle        | internal error-handle (client-end)
--             msg.type              | VAL: message-type
--             int.msg.handle        | internal message-handle (client-end)
PROC pony.int.link.handler.tcpip (VAL INT own.node.id, remote.node.id,
                                  VAL SOCKET socket,
                                  PONY.INT.LINKHANDLE? link.handle.svr,
                                  SHARED PONY.INT.LINKMGRHANDLE! link.mgr.handle,
                                  SHARED PONY.INT.LINKMGRHANDLE.TCPIP! link.mgr.handle.tcpip,
                                  SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle,
                                  SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle,
                                  SHARED PONY.INT.KERNELREPLYHANDLE! kernel.reply.handle,
                                  VAL BOOL output.errs,
                                  SHARED PONY.INT.ERRHANDLE! int.err.handle,
                                  VAL INT msg.type,
                                  SHARED PONY.INT.MSGHANDLE! int.msg.handle)
  VAL BOOL output.msgs IS ((msg.type = PONYC.MSGTYPE.STATUS) OR (msg.type = PONYC.MSGTYPE.STATUSERR)):
  VAL BOOL output.err.msgs IS ((msg.type = PONYC.MSGTYPE.ERR) OR (msg.type = PONYC.MSGTYPE.STATUSERR)):
  INITIAL SOCKET read.socket IS socket:
  INITIAL SOCKET write.socket IS socket:
  CHAN BOOL remote.shutdown:
  PAR
    --{{{  Reader (not active on dummy link-handler)
    IF
      (own.node.id = 0) AND (remote.node.id = 0)
        SKIP
      TRUE
        [1 + ((6 * BYTESIN (INT)) + BYTESIN (BOOL))]BYTE header:
        MOBILE []BYTE data.array:
        MOBILE []INT size.array:
        INT sock.result:
        INITIAL BOOL running IS TRUE:
        WHILE running
          SEQ
            -- Read message from remote node
            --{{{  SOCKET message
            IF
              output.msgs
                CLAIM int.msg.handle
                  SEQ
                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                    int.msg.handle[to.handler] ! msg.str; ": SOCKET: Read message from remote node"
                    int.msg.handle[to.handler] ! msg.end; FALSE
              TRUE
                SKIP
            --}}}
            pony.int.tcpip.socket.fullread.multi (read.socket, header,
                                                  data.array, size.array,
                                                  sock.result)
            IF
              --{{{  Error
              sock.result = (-1)
                SEQ
                  --{{{  SOCKET error message
                  IF
                    output.err.msgs
                      CLAIM int.msg.handle
                        SEQ
                          int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                          int.msg.handle[to.handler] ! msg.int; remote.node.id
                          int.msg.handle[to.handler] ! msg.str; ": SOCKET: Read operation failed"
                          int.msg.handle[to.handler] ! msg.end; TRUE
                    TRUE
                      SKIP
                  --}}}
                  --{{{  Send error to error-handler
                  IF
                    output.errs
                      PONY.ERROR err:
                      SEQ
                        err[ans.concerned] := FALSE
                        err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                        err[remote.node.concerned] := TRUE
                        err[remote.node.id] := remote.node.id
                        err[err.code] := PONYC.ERRCODE.TCPIP.READFAILURE
                        CLAIM int.err.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                    int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                    int.msg.handle[to.handler] ! msg.str; ", "
                                    int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                    int.msg.handle[to.handler] ! msg.str; ", "
                                    int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                    int.msg.handle[to.handler] ! msg.str; ", "
                                    int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                    int.msg.handle[to.handler] ! msg.str; ", "
                                    int.msg.handle[to.handler] ! msg.int; err[err.code]
                                    int.msg.handle[to.handler] ! msg.str; "]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: error
                            int.err.handle[to.handler] ! report.err; err
                    TRUE
                      SKIP
                  --}}}
                  running := FALSE
                  -- Shutdown due to error (error-flag is TRUE)
                  remote.shutdown ! TRUE
              --}}}
              TRUE
                SEQ
                  --{{{  SOCKET message
                  IF
                    output.msgs
                      CLAIM int.msg.handle
                        SEQ
                          int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                          int.msg.handle[to.handler] ! msg.int; remote.node.id
                          int.msg.handle[to.handler] ! msg.str; ": SOCKET: Received message from remote node"
                          int.msg.handle[to.handler] ! msg.end; FALSE
                    TRUE
                      SKIP
                  --}}}
                  CASE header[0]
                    --{{{  For NCT-manager: explicit allocation
                    PONYC.INT.TCPIP.LINKHEADER.FORNCTMGR.ALLOC
                      INITIAL [BYTESIN (INT)]BYTE dir.type.array IS [header FROM 1 FOR BYTESIN (INT)]:
                      INT dir.type RETYPES dir.type.array:
                      INITIAL [BYTESIN (INT)]BYTE share.type.alloc.array IS [header FROM (1 + BYTESIN (INT)) FOR BYTESIN (INT)]:
                      INT share.type.alloc RETYPES share.type.alloc.array:
                      INITIAL [BYTESIN (INT)]BYTE share.type.opposite.array IS [header FROM (1 + (2 * BYTESIN (INT))) FOR BYTESIN (INT)]:
                      INT share.type.opposite RETYPES share.type.opposite.array:
                      INITIAL [BYTESIN (INT)]BYTE type.hash.array IS [header FROM (1 + (3 * BYTESIN (INT))) FOR BYTESIN (INT)]:
                      INT type.hash RETYPES type.hash.array:
                      -- Pass message on to NCT-manager
                      CLAIM nct.mgr.handle
                        SEQ
                          --{{{  OUT message
                          IF
                            output.msgs
                              CLAIM int.msg.handle
                                SEQ
                                  int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                  int.msg.handle[to.handler] ! msg.int; remote.node.id
                                  int.msg.handle[to.handler] ! msg.str; ": OUT nctmgrh: alloc; "
                                  int.msg.handle[to.handler] ! msg.int; remote.node.id
                                  int.msg.handle[to.handler] ! msg.str; "; "
                                  int.msg.handle[to.handler] ! msg.int; dir.type
                                  int.msg.handle[to.handler] ! msg.str; "; "
                                  int.msg.handle[to.handler] ! msg.int; share.type.alloc
                                  int.msg.handle[to.handler] ! msg.str; "; "
                                  int.msg.handle[to.handler] ! msg.int; share.type.opposite
                                  int.msg.handle[to.handler] ! msg.str; "; "
                                  int.msg.handle[to.handler] ! msg.hex; type.hash
                                  int.msg.handle[to.handler] ! msg.str; "; *""
                                  int.msg.handle[to.handler] ! msg.str; CLONE data.array
                                  int.msg.handle[to.handler] ! msg.str; "*""
                                  int.msg.handle[to.handler] ! msg.end; FALSE
                            TRUE
                              SKIP
                          --}}}
                          -- Carrying: node-ID of the kernel making the request;
                          --           direction-type of the end to be allocated
                          --             (0 = client-end, 1 = server-end);
                          --           share-type of the end to be allocated
                          --             (1 = unshared, 2 = shared);
                          --           share-type of the opposite end
                          --             (0 = unknown, 1 = unshared, 2 = shared);
                          --           type-hash of the NCT to be allocated;
                          --           name of the NCT
                          nct.mgr.handle[to.mgr] ! alloc; remote.node.id; dir.type;
                                                          share.type.alloc; share.type.opposite;
                                                          type.hash; data.array
                    --}}}
                    --{{{  For main kernel: explicit allocation - error
                    PONYC.INT.TCPIP.LINKHEADER.FORMAINKERNEL.ALLOCERROR
                      INITIAL [BYTESIN (INT)]BYTE result.array IS [header FROM 1 FOR BYTESIN (INT)]:
                      INT result RETYPES result.array:
                      -- Pass message on to main kernel
                      CLAIM kernel.reply.handle
                        SEQ
                          --{{{  OUT message
                          IF
                            output.msgs
                              CLAIM int.msg.handle
                                SEQ
                                  int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                  int.msg.handle[to.handler] ! msg.int; remote.node.id
                                  int.msg.handle[to.handler] ! msg.str; ": OUT kernelreplyh: alloc.error; "
                                  int.msg.handle[to.handler] ! msg.int; result
                                  int.msg.handle[to.handler] ! msg.end; FALSE
                            TRUE
                              SKIP
                          --}}}
                          -- Carrying: result
                          kernel.reply.handle[to.kernel] ! alloc.error; result
                    --}}}
                    --{{{  For main kernel: explicit allocation - confirm
                    PONYC.INT.TCPIP.LINKHEADER.FORMAINKERNEL.ALLOCCONFIRM
                      INITIAL [BYTESIN (INT)]BYTE nct.id.array IS [header FROM 1 FOR BYTESIN (INT)]:
                      INT nct.id RETYPES nct.id.array:
                      -- Pass message on to main kernel
                      CLAIM kernel.reply.handle
                        SEQ
                          --{{{  OUT message
                          IF
                            output.msgs
                              CLAIM int.msg.handle
                                SEQ
                                  int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                  int.msg.handle[to.handler] ! msg.int; remote.node.id
                                  int.msg.handle[to.handler] ! msg.str; ": OUT kernelreplyh: alloc.confirm; "
                                  int.msg.handle[to.handler] ! msg.int; nct.id
                                  int.msg.handle[to.handler] ! msg.end; FALSE
                            TRUE
                              SKIP
                          --}}}
                          -- Carrying: NCT-ID of the newly allocated end
                          kernel.reply.handle[to.kernel] ! alloc.confirm; nct.id
                    --}}}
                    --{{{  For NCT-manager: make CTB networked
                    PONYC.INT.TCPIP.LINKHEADER.FORNCTMGR.MAKECTBNETWORKED
                      INITIAL [BYTESIN (INT)]BYTE request.nct.id.array IS [header FROM 1 FOR BYTESIN (INT)]:
                      INT request.nct.id RETYPES request.nct.id.array:
                      INITIAL [BYTESIN (INT)]BYTE request.chan.id.array IS [header FROM (1 + BYTESIN (INT)) FOR BYTESIN (INT)]:
                      INT request.chan.id RETYPES request.chan.id.array:
                      INITIAL [BYTESIN (INT)]BYTE initial.cli.claimed.array IS [header FROM (1 + (2 * BYTESIN (INT))) FOR BYTESIN (INT)]:
                      INT i.initial.cli.claimed RETYPES initial.cli.claimed.array:
                      INITIAL BOOL initial.cli.claimed IS BOOL i.initial.cli.claimed:
                      INITIAL [BYTESIN (INT)]BYTE initial.svr.claimed.array IS [header FROM (1 + (3 * BYTESIN (INT))) FOR BYTESIN (INT)]:
                      INT i.initial.svr.claimed RETYPES initial.svr.claimed.array:
                      INITIAL BOOL initial.svr.claimed IS BOOL i.initial.svr.claimed:
                      -- Pass message on to NCT-manager
                      CLAIM nct.mgr.handle
                        SEQ
                          --{{{  OUT message
                          IF
                            output.msgs
                              CLAIM int.msg.handle
                                SEQ
                                  int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                  int.msg.handle[to.handler] ! msg.int; remote.node.id
                                  int.msg.handle[to.handler] ! msg.str; ": OUT nctmgrh: make.ctb.networked; "
                                  int.msg.handle[to.handler] ! msg.int; remote.node.id
                                  int.msg.handle[to.handler] ! msg.str; "; "
                                  int.msg.handle[to.handler] ! msg.int; request.nct.id
                                  int.msg.handle[to.handler] ! msg.str; "; "
                                  int.msg.handle[to.handler] ! msg.int; request.chan.id
                                  int.msg.handle[to.handler] ! msg.str; "; "
                                  int.msg.handle[to.handler] ! msg.bool; initial.cli.claimed
                                  int.msg.handle[to.handler] ! msg.str; "; "
                                  int.msg.handle[to.handler] ! msg.bool; initial.svr.claimed
                                  int.msg.handle[to.handler] ! msg.end; FALSE
                            TRUE
                              SKIP
                          --}}}
                          -- Carrying: node-ID of the decode-handler making the request;
                          --           NCT-ID of the decode-handler making the request;
                          --           channel-ID of the decode-handler making the request;
                          --           client-end initially claimed?;
                          --           server-end initially claimed?
                          nct.mgr.handle[to.mgr] ! make.ctb.networked; remote.node.id;
                                                   request.nct.id; request.chan.id;
                                                   initial.cli.claimed; initial.svr.claimed
                    --}}}
                    --{{{  For decode-handler: make CTB networked - confirm
                    PONYC.INT.TCPIP.LINKHEADER.FORDECHANDLER.MAKECTBNETWORKEDCONFIRM
                      INITIAL [BYTESIN (INT)]BYTE recipient.nct.id.array IS [header FROM 1 FOR BYTESIN (INT)]:
                      INT recipient.nct.id RETYPES recipient.nct.id.array:
                      INITIAL [BYTESIN (INT)]BYTE recipient.chan.id.array IS [header FROM (1 + BYTESIN (INT)) FOR BYTESIN (INT)]:
                      INT recipient.chan.id RETYPES recipient.chan.id.array:
                      INITIAL [BYTESIN (INT)]BYTE nct.id.array IS [header FROM (1 + (2 * BYTESIN (INT))) FOR BYTESIN (INT)]:
                      INT nct.id RETYPES nct.id.array:
                      SHARED PONY.INT.CTBINSTANTHANDLE! ctb.instant.handle:
                      SHARED PONY.INT.DECODEREPLYHANDLE! dec.reply.handle:
                      SEQ
                        -- Get CTB-instant-handle from CTB-manager
                        CLAIM ctb.mgr.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.instant.handle; "
                                    int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID
                            ctb.mgr.handle[to.mgr] ! get.ctb.instant.handle; recipient.nct.id
                            -- Get reply
                            -- Carrying: CTB-instant-handle
                            ctb.mgr.handle[from.mgr] ? CASE get.ctb.instant.handle.confirm;
                                                            ctb.instant.handle
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.instant.handle.confirm; [cli-end]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                        -- Get decode-reply-handle from CTB-instant-handler
                        CLAIM ctb.instant.handle
                          SEQ
                            -- Get current remote node
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbinsth "
                                    int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                    int.msg.handle[to.handler] ! msg.str; ": get.dec.reply.handle; "
                                    int.msg.handle[to.handler] ! msg.int; recipient.chan.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: channel-ID
                            ctb.instant.handle[to.handler] ! get.dec.reply.handle; recipient.chan.id
                            -- Get reply
                            -- Carrying: decode-reply-handle
                            ctb.instant.handle[from.handler] ? CASE get.dec.reply.handle.confirm;
                                                                    dec.reply.handle
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN ctbinsth "
                                    int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                    int.msg.handle[to.handler] ! msg.str; ": get.dec.reply.handle.confirm; [cli-end]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                        -- Pass message on to decode-handler
                        CLAIM dec.reply.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT decreplyh "
                                    int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                    int.msg.handle[to.handler] ! msg.str; "/"
                                    int.msg.handle[to.handler] ! msg.int; recipient.chan.id
                                    int.msg.handle[to.handler] ! msg.str; ": make.ctb.networked.confirm; "
                                    int.msg.handle[to.handler] ! msg.int; nct.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID of the newly allocated end
                            dec.reply.handle[to.handler] ! make.ctb.networked.confirm; nct.id
                    --}}}
                    --{{{  For NCT-handler: claim client-end
                    PONYC.INT.TCPIP.LINKHEADER.FORNCTHANDLER.CLAIMCLI
                      INITIAL [BYTESIN (INT)]BYTE request.nct.id.array IS [header FROM 1 FOR BYTESIN (INT)]:
                      INT request.nct.id RETYPES request.nct.id.array:
                      SHARED PONY.INT.NCTHANDLE! nct.handle:
                      SEQ
                        -- Get NCT-handle from NCT-manager
                        CLAIM nct.mgr.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT nctmgrh: get.nct.handle; "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID
                            nct.mgr.handle[to.mgr] ! get.nct.handle; request.nct.id
                            -- Get reply
                            -- Carrying: NCT-handle
                            nct.mgr.handle[from.mgr] ? CASE get.nct.handle.confirm;
                                                            nct.handle
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN nctmgrh: get.nct.handle.confirm; [cli-end]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                        -- Pass message on to NCT-handler
                        CLAIM nct.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ncth "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.str; ": claim.cli; "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: node-ID of the CTB-handler making the request
                            nct.handle[to.handler] ! claim.cli; remote.node.id
                    --}}}
                    --{{{  For NCT-handler: claim server-end
                    PONYC.INT.TCPIP.LINKHEADER.FORNCTHANDLER.CLAIMSVR
                      INITIAL [BYTESIN (INT)]BYTE request.nct.id.array IS [header FROM 1 FOR BYTESIN (INT)]:
                      INT request.nct.id RETYPES request.nct.id.array:
                      SHARED PONY.INT.NCTHANDLE! nct.handle:
                      SEQ
                        -- Get NCT-handle from NCT-manager
                        CLAIM nct.mgr.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT nctmgrh: get.nct.handle; "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID
                            nct.mgr.handle[to.mgr] ! get.nct.handle; request.nct.id
                            -- Get reply
                            -- Carrying: NCT-handle
                            nct.mgr.handle[from.mgr] ? CASE get.nct.handle.confirm;
                                                            nct.handle
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN nctmgrh: get.nct.handle.confirm; [cli-end]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                        -- Pass message on to NCT-handler
                        CLAIM nct.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ncth "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.str; ": claim.svr; "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: node-ID of the CTB-handler making the request
                            nct.handle[to.handler] ! claim.svr; remote.node.id
                    --}}}
                    --{{{  For NCT-handler: confirm new-other-end
                    PONYC.INT.TCPIP.LINKHEADER.FORNCTHANDLER.NEWOTHERENDCONFIRM
                      INITIAL [BYTESIN (INT)]BYTE request.nct.id.array IS [header FROM 1 FOR BYTESIN (INT)]:
                      INT request.nct.id RETYPES request.nct.id.array:
                      SHARED PONY.INT.NCTHANDLE! nct.handle:
                      SEQ
                        -- Get NCT-handle from NCT-manager
                        CLAIM nct.mgr.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT nctmgrh: get.nct.handle; "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID
                            nct.mgr.handle[to.mgr] ! get.nct.handle; request.nct.id
                            -- Get reply
                            -- Carrying: NCT-handle
                            nct.mgr.handle[from.mgr] ? CASE get.nct.handle.confirm;
                                                            nct.handle
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN nctmgrh: get.nct.handle.confirm; [cli-end]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                        -- Pass message on to NCT-handler
                        CLAIM nct.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ncth "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.str; ": new.other.end.confirm"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            nct.handle[to.handler] ! new.other.end.confirm
                    --}}}
                    --{{{  For NCT-handler: release client-end
                    PONYC.INT.TCPIP.LINKHEADER.FORNCTHANDLER.RELEASECLI
                      INITIAL [BYTESIN (INT)]BYTE request.nct.id.array IS [header FROM 1 FOR BYTESIN (INT)]:
                      INT request.nct.id RETYPES request.nct.id.array:
                      SHARED PONY.INT.NCTHANDLE! nct.handle:
                      SEQ
                        -- Get NCT-handle from NCT-manager
                        CLAIM nct.mgr.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT nctmgrh: get.nct.handle; "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID
                            nct.mgr.handle[to.mgr] ! get.nct.handle; request.nct.id
                            -- Get reply
                            -- Carrying: NCT-handle
                            nct.mgr.handle[from.mgr] ? CASE get.nct.handle.confirm;
                                                            nct.handle
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN nctmgrh: get.nct.handle.confirm; [cli-end]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                        -- Pass message on to NCT-handler
                        CLAIM nct.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ncth "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.str; ": release.cli"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            nct.handle[to.handler] ! release.cli
                    --}}}
                    --{{{  For NCT-handler: release server-end
                    PONYC.INT.TCPIP.LINKHEADER.FORNCTHANDLER.RELEASESVR
                      INITIAL [BYTESIN (INT)]BYTE request.nct.id.array IS [header FROM 1 FOR BYTESIN (INT)]:
                      INT request.nct.id RETYPES request.nct.id.array:
                      SHARED PONY.INT.NCTHANDLE! nct.handle:
                      SEQ
                        -- Get NCT-handle from NCT-manager
                        CLAIM nct.mgr.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT nctmgrh: get.nct.handle; "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID
                            nct.mgr.handle[to.mgr] ! get.nct.handle; request.nct.id
                            -- Get reply
                            -- Carrying: NCT-handle
                            nct.mgr.handle[from.mgr] ? CASE get.nct.handle.confirm;
                                                            nct.handle
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN nctmgrh: get.nct.handle.confirm; [cli-end]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                        -- Pass message on to NCT-handler
                        CLAIM nct.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ncth "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.str; ": release.svr"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            nct.handle[to.handler] ! release.svr
                    --}}}
                    --{{{  For NCT-handler: end-over-itself operation completed
                    PONYC.INT.TCPIP.LINKHEADER.FORNCTHANDLER.EOIDONE
                      INITIAL [BYTESIN (INT)]BYTE request.nct.id.array IS [header FROM 1 FOR BYTESIN (INT)]:
                      INT request.nct.id RETYPES request.nct.id.array:
                      SHARED PONY.INT.NCTHANDLE! nct.handle:
                      SEQ
                        -- Get NCT-handle from NCT-manager
                        CLAIM nct.mgr.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT nctmgrh: get.nct.handle; "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID
                            nct.mgr.handle[to.mgr] ! get.nct.handle; request.nct.id
                            -- Get reply
                            -- Carrying: NCT-handle
                            nct.mgr.handle[from.mgr] ? CASE get.nct.handle.confirm;
                                                            nct.handle
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN nctmgrh: get.nct.handle.confirm; [cli-end]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                        -- Pass message on to NCT-handler
                        CLAIM nct.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ncth "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.str; ": eoi.done; "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: node-ID of the CTB-handler making the request
                            nct.handle[to.handler] ! eoi.done; remote.node.id
                    --}}}
                    --{{{  For CTB-handler regarding client-end: confirm claim - no other end
                    PONYC.INT.TCPIP.LINKHEADER.FORCTBHANDLER.RECLIENTCLAIMCONFIRMNOOTHEREND
                      INITIAL [BYTESIN (INT)]BYTE recipient.nct.id.array IS [header FROM 1 FOR BYTESIN (INT)]:
                      INT recipient.nct.id RETYPES recipient.nct.id.array:
                      SHARED PONY.INT.CTBMAINHANDLE! ctb.main.handle:
                      SEQ
                        -- Get CTB-main-handle from CTB-manager
                        CLAIM ctb.mgr.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.main.handle; "
                                    int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID
                            ctb.mgr.handle[to.mgr] ! get.ctb.main.handle; recipient.nct.id
                            -- Get reply
                            -- Carrying: CTB-main-handle
                            ctb.mgr.handle[from.mgr] ? CASE get.ctb.main.handle.confirm;
                                                            ctb.main.handle
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.main.handle.confirm; [cli-end]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                        -- Pass message on to CTB-handler
                        CLAIM ctb.main.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmainh "
                                    int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                    int.msg.handle[to.handler] ! msg.str; " [from.ncthandler.re.client]: claim.confirm.nootherend"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            ctb.main.handle[from.ncthandler.re.client] ! claim.confirm.nootherend
                    --}}}
                    --{{{  For CTB-handler regarding server-end: confirm claim - no other end
                    PONYC.INT.TCPIP.LINKHEADER.FORCTBHANDLER.RESERVERCLAIMCONFIRMNOOTHEREND
                      INITIAL [BYTESIN (INT)]BYTE recipient.nct.id.array IS [header FROM 1 FOR BYTESIN (INT)]:
                      INT recipient.nct.id RETYPES recipient.nct.id.array:
                      SHARED PONY.INT.CTBMAINHANDLE! ctb.main.handle:
                      SEQ
                        -- Get CTB-main-handle from CTB-manager
                        CLAIM ctb.mgr.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.main.handle; "
                                    int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID
                            ctb.mgr.handle[to.mgr] ! get.ctb.main.handle; recipient.nct.id
                            -- Get reply
                            -- Carrying: CTB-main-handle
                            ctb.mgr.handle[from.mgr] ? CASE get.ctb.main.handle.confirm;
                                                            ctb.main.handle
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.main.handle.confirm; [cli-end]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                        -- Pass message on to CTB-handler
                        CLAIM ctb.main.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmainh "
                                    int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                    int.msg.handle[to.handler] ! msg.str; " [from.ncthandler.re.server]: claim.confirm.nootherend"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            ctb.main.handle[from.ncthandler.re.server] ! claim.confirm.nootherend
                    --}}}
                    --{{{  For CTB-handler regarding client-end: confirm claim - other end claimed
                    PONYC.INT.TCPIP.LINKHEADER.FORCTBHANDLER.RECLIENTCLAIMCONFIRMOTHERENDCLAIMED
                      INITIAL [BYTESIN (INT)]BYTE recipient.nct.id.array IS [header FROM 1 FOR BYTESIN (INT)]:
                      INT recipient.nct.id RETYPES recipient.nct.id.array:
                      INITIAL [BYTESIN (INT)]BYTE node.id.array IS [header FROM (1 + BYTESIN (INT)) FOR BYTESIN (INT)]:
                      INT node.id RETYPES node.id.array:
                      SHARED PONY.INT.CTBMAINHANDLE! ctb.main.handle:
                      SEQ
                        --{{{  Store location of `other end's node' if applicable
                        IF
                          (node.id > 0) AND (node.id < own.node.id)
                            INITIAL [BYTESIN (INT)]BYTE node.ip.array IS [header FROM (1 + (2 * BYTESIN (INT))) FOR BYTESIN (INT)]:
                            INT node.ip RETYPES node.ip.array:
                            INITIAL [BYTESIN (INT)]BYTE node.port.array IS [header FROM (1 + (3 * BYTESIN (INT))) FOR BYTESIN (INT)]:
                            INT node.port RETYPES node.port.array:
                            CLAIM link.mgr.handle.tcpip
                              SEQ
                                --{{{  OUT message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                        int.msg.handle[to.handler] ! msg.int; remote.node.id
                                        int.msg.handle[to.handler] ! msg.str; ": OUT linkmgrh.tcpip: store.location; "
                                        int.msg.handle[to.handler] ! msg.int; node.id
                                        int.msg.handle[to.handler] ! msg.str; "; "
                                        int.msg.handle[to.handler] ! msg.hex; node.ip
                                        int.msg.handle[to.handler] ! msg.str; "; "
                                        int.msg.handle[to.handler] ! msg.int; node.port
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                                -- Carrying: node-ID
                                link.mgr.handle.tcpip[to.mgr] ! store.location; node.id;
                                                                                node.ip; node.port
                          TRUE
                            SKIP
                        --}}}
                        -- Get CTB-main-handle from CTB-manager
                        CLAIM ctb.mgr.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.main.handle; "
                                    int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID
                            ctb.mgr.handle[to.mgr] ! get.ctb.main.handle; recipient.nct.id
                            -- Get reply
                            -- Carrying: CTB-main-handle
                            ctb.mgr.handle[from.mgr] ? CASE get.ctb.main.handle.confirm;
                                                            ctb.main.handle
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.main.handle.confirm; [cli-end]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                        -- Pass message on to CTB-handler
                        CLAIM ctb.main.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmainh "
                                    int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                    int.msg.handle[to.handler] ! msg.str; " [from.ncthandler.re.client]: claim.confirm.otherendclaimed; "
                                    int.msg.handle[to.handler] ! msg.int; node.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: node-ID of the other end's node
                            ctb.main.handle[from.ncthandler.re.client] ! claim.confirm.otherendclaimed; node.id
                    --}}}
                    --{{{  For CTB-handler regarding server-end: confirm claim - other end claimed
                    PONYC.INT.TCPIP.LINKHEADER.FORCTBHANDLER.RESERVERCLAIMCONFIRMOTHERENDCLAIMED
                      INITIAL [BYTESIN (INT)]BYTE recipient.nct.id.array IS [header FROM 1 FOR BYTESIN (INT)]:
                      INT recipient.nct.id RETYPES recipient.nct.id.array:
                      INITIAL [BYTESIN (INT)]BYTE node.id.array IS [header FROM (1 + BYTESIN (INT)) FOR BYTESIN (INT)]:
                      INT node.id RETYPES node.id.array:
                      SHARED PONY.INT.CTBMAINHANDLE! ctb.main.handle:
                      SEQ
                        --{{{  Store location of `other end's node' if applicable
                        IF
                          (node.id > 0) AND (node.id < own.node.id)
                            INITIAL [BYTESIN (INT)]BYTE node.ip.array IS [header FROM (1 + (2 * BYTESIN (INT))) FOR BYTESIN (INT)]:
                            INT node.ip RETYPES node.ip.array:
                            INITIAL [BYTESIN (INT)]BYTE node.port.array IS [header FROM (1 + (3 * BYTESIN (INT))) FOR BYTESIN (INT)]:
                            INT node.port RETYPES node.port.array:
                            CLAIM link.mgr.handle.tcpip
                              SEQ
                                --{{{  OUT message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                        int.msg.handle[to.handler] ! msg.int; remote.node.id
                                        int.msg.handle[to.handler] ! msg.str; ": OUT linkmgrh.tcpip: store.location; "
                                        int.msg.handle[to.handler] ! msg.int; node.id
                                        int.msg.handle[to.handler] ! msg.str; "; "
                                        int.msg.handle[to.handler] ! msg.hex; node.ip
                                        int.msg.handle[to.handler] ! msg.str; "; "
                                        int.msg.handle[to.handler] ! msg.int; node.port
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                                -- Carrying: node-ID
                                link.mgr.handle.tcpip[to.mgr] ! store.location; node.id;
                                                                                node.ip; node.port
                          TRUE
                            SKIP
                        --}}}
                        -- Get CTB-main-handle from CTB-manager
                        CLAIM ctb.mgr.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.main.handle; "
                                    int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID
                            ctb.mgr.handle[to.mgr] ! get.ctb.main.handle; recipient.nct.id
                            -- Get reply
                            -- Carrying: CTB-main-handle
                            ctb.mgr.handle[from.mgr] ? CASE get.ctb.main.handle.confirm;
                                                            ctb.main.handle
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.main.handle.confirm; [cli-end]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                        -- Pass message on to CTB-handler
                        CLAIM ctb.main.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmainh "
                                    int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                    int.msg.handle[to.handler] ! msg.str; " [from.ncthandler.re.server]: claim.confirm.otherendclaimed; "
                                    int.msg.handle[to.handler] ! msg.int; node.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: node-ID of the other end's node
                            ctb.main.handle[from.ncthandler.re.server] ! claim.confirm.otherendclaimed; node.id
                    --}}}
                    --{{{  For CTB-handler regarding client-end: new other end
                    PONYC.INT.TCPIP.LINKHEADER.FORCTBHANDLER.RECLIENTNEWOTHEREND
                      INITIAL [BYTESIN (INT)]BYTE recipient.nct.id.array IS [header FROM 1 FOR BYTESIN (INT)]:
                      INT recipient.nct.id RETYPES recipient.nct.id.array:
                      INITIAL [BYTESIN (INT)]BYTE node.id.array IS [header FROM (1 + BYTESIN (INT)) FOR BYTESIN (INT)]:
                      INT node.id RETYPES node.id.array:
                      SHARED PONY.INT.CTBMAINHANDLE! ctb.main.handle:
                      SEQ
                        --{{{  Store location of `other end's node' if applicable
                        IF
                          (node.id > 0) AND (node.id < own.node.id)
                            INITIAL [BYTESIN (INT)]BYTE node.ip.array IS [header FROM (1 + (2 * BYTESIN (INT))) FOR BYTESIN (INT)]:
                            INT node.ip RETYPES node.ip.array:
                            INITIAL [BYTESIN (INT)]BYTE node.port.array IS [header FROM (1 + (3 * BYTESIN (INT))) FOR BYTESIN (INT)]:
                            INT node.port RETYPES node.port.array:
                            CLAIM link.mgr.handle.tcpip
                              SEQ
                                --{{{  OUT message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                        int.msg.handle[to.handler] ! msg.int; remote.node.id
                                        int.msg.handle[to.handler] ! msg.str; ": OUT linkmgrh.tcpip: store.location; "
                                        int.msg.handle[to.handler] ! msg.int; node.id
                                        int.msg.handle[to.handler] ! msg.str; "; "
                                        int.msg.handle[to.handler] ! msg.hex; node.ip
                                        int.msg.handle[to.handler] ! msg.str; "; "
                                        int.msg.handle[to.handler] ! msg.int; node.port
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                                -- Carrying: node-ID
                                link.mgr.handle.tcpip[to.mgr] ! store.location; node.id;
                                                                                node.ip; node.port
                          TRUE
                            SKIP
                        --}}}
                        -- Get CTB-main-handle from CTB-manager
                        CLAIM ctb.mgr.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.main.handle; "
                                    int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID
                            ctb.mgr.handle[to.mgr] ! get.ctb.main.handle; recipient.nct.id
                            -- Get reply
                            -- Carrying: CTB-main-handle
                            ctb.mgr.handle[from.mgr] ? CASE get.ctb.main.handle.confirm;
                                                            ctb.main.handle
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.main.handle.confirm; [cli-end]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                        -- Pass message on to CTB-handler
                        CLAIM ctb.main.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmainh "
                                    int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                    int.msg.handle[to.handler] ! msg.str; " [from.ncthandler.re.client]: new.other.end; "
                                    int.msg.handle[to.handler] ! msg.int; node.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: node-ID of the other end's node
                            ctb.main.handle[from.ncthandler.re.client] ! new.other.end; node.id
                    --}}}
                    --{{{  For CTB-handler regarding server-end: new other end
                    PONYC.INT.TCPIP.LINKHEADER.FORCTBHANDLER.RESERVERNEWOTHEREND
                      INITIAL [BYTESIN (INT)]BYTE recipient.nct.id.array IS [header FROM 1 FOR BYTESIN (INT)]:
                      INT recipient.nct.id RETYPES recipient.nct.id.array:
                      INITIAL [BYTESIN (INT)]BYTE node.id.array IS [header FROM (1 + BYTESIN (INT)) FOR BYTESIN (INT)]:
                      INT node.id RETYPES node.id.array:
                      SHARED PONY.INT.CTBMAINHANDLE! ctb.main.handle:
                      SEQ
                        --{{{  Store location of `other end's node' if applicable
                        IF
                          (node.id > 0) AND (node.id < own.node.id)
                            INITIAL [BYTESIN (INT)]BYTE node.ip.array IS [header FROM (1 + (2 * BYTESIN (INT))) FOR BYTESIN (INT)]:
                            INT node.ip RETYPES node.ip.array:
                            INITIAL [BYTESIN (INT)]BYTE node.port.array IS [header FROM (1 + (3 * BYTESIN (INT))) FOR BYTESIN (INT)]:
                            INT node.port RETYPES node.port.array:
                            CLAIM link.mgr.handle.tcpip
                              SEQ
                                --{{{  OUT message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                        int.msg.handle[to.handler] ! msg.int; remote.node.id
                                        int.msg.handle[to.handler] ! msg.str; ": OUT linkmgrh.tcpip: store.location; "
                                        int.msg.handle[to.handler] ! msg.int; node.id
                                        int.msg.handle[to.handler] ! msg.str; "; "
                                        int.msg.handle[to.handler] ! msg.hex; node.ip
                                        int.msg.handle[to.handler] ! msg.str; "; "
                                        int.msg.handle[to.handler] ! msg.int; node.port
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                                -- Carrying: node-ID
                                link.mgr.handle.tcpip[to.mgr] ! store.location; node.id;
                                                                                node.ip; node.port
                          TRUE
                            SKIP
                        --}}}
                        -- Get CTB-main-handle from CTB-manager
                        CLAIM ctb.mgr.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.main.handle; "
                                    int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID
                            ctb.mgr.handle[to.mgr] ! get.ctb.main.handle; recipient.nct.id
                            -- Get reply
                            -- Carrying: CTB-main-handle
                            ctb.mgr.handle[from.mgr] ? CASE get.ctb.main.handle.confirm;
                                                            ctb.main.handle
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.main.handle.confirm; [cli-end]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                        -- Pass message on to CTB-handler
                        CLAIM ctb.main.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmainh "
                                    int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                    int.msg.handle[to.handler] ! msg.str; " [from.ncthandler.re.server]: new.other.end; "
                                    int.msg.handle[to.handler] ! msg.int; node.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: node-ID of the other end's node
                            ctb.main.handle[from.ncthandler.re.server] ! new.other.end; node.id
                    --}}}
                    --{{{  In session: start session
                    PONYC.INT.TCPIP.LINKHEADER.INSESSION.STARTSESSION
                      INITIAL [BYTESIN (INT)]BYTE request.nct.id.array IS [header FROM 1 FOR BYTESIN (INT)]:
                      INT request.nct.id RETYPES request.nct.id.array:
                      SHARED PONY.INT.CTBMAINHANDLE! ctb.main.handle:
                      SEQ
                        -- Get CTB-main-handle from CTB-manager
                        CLAIM ctb.mgr.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.main.handle; "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID
                            ctb.mgr.handle[to.mgr] ! get.ctb.main.handle; request.nct.id
                            -- Get reply
                            -- Carrying: CTB-main-handle
                            ctb.mgr.handle[from.mgr] ? CASE get.ctb.main.handle.confirm;
                                                            ctb.main.handle
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.main.handle.confirm; [cli-end]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                        -- Pass message on to CTB-handler
                        CLAIM ctb.main.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmainh "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.str; " [to.handler]: start.session"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            ctb.main.handle[to.handler] ! start.session
                    --}}}
                    --{{{  In session: first CLC of a ULC
                    PONYC.INT.TCPIP.LINKHEADER.INSESSION.FIRSTCLC
                      INITIAL [BYTESIN (INT)]BYTE request.nct.id.array IS [header FROM 1 FOR BYTESIN (INT)]:
                      INT request.nct.id RETYPES request.nct.id.array:
                      INITIAL [BYTESIN (INT)]BYTE chan.id.array IS [header FROM (1 + BYTESIN (INT)) FOR BYTESIN (INT)]:
                      INT chan.id RETYPES chan.id.array:
                      INITIAL [BYTESIN (INT)]BYTE di.nlcs.first.array IS [header FROM (1 + (2 * BYTESIN (INT))) FOR BYTESIN (INT)]:
                      INT di.nlcs.first RETYPES di.nlcs.first.array:
                      INITIAL [BYTESIN (INT)]BYTE cte.nlcs.first.array IS [header FROM (1 + (3 * BYTESIN (INT))) FOR BYTESIN (INT)]:
                      INT cte.nlcs.first RETYPES cte.nlcs.first.array:
                      INITIAL [BYTESIN (BOOL)]BYTE has.rest.clcs.array IS [header FROM (1 + (4 * BYTESIN (INT))) FOR BYTESIN (BOOL)]:
                      BOOL has.rest.clcs RETYPES has.rest.clcs.array:
                      SHARED PONY.INT.CTBMAINHANDLE! ctb.main.handle:
                      SEQ
                        -- Get CTB-main-handle from CTB-manager
                        CLAIM ctb.mgr.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.main.handle; "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID
                            ctb.mgr.handle[to.mgr] ! get.ctb.main.handle; request.nct.id
                            -- Get reply
                            -- Carrying: CTB-main-handle
                            ctb.mgr.handle[from.mgr] ? CASE get.ctb.main.handle.confirm;
                                                            ctb.main.handle
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.main.handle.confirm; [cli-end]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                        -- Pass message on to CTB-handler
                        CLAIM ctb.main.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmainh "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.str; " [to.handler]: first.clc; "
                                    int.msg.handle[to.handler] ! msg.int; chan.id
                                    int.msg.handle[to.handler] ! msg.str; "; "
                                    int.msg.handle[to.handler] ! msg.int; di.nlcs.first
                                    int.msg.handle[to.handler] ! msg.str; "; "
                                    int.msg.handle[to.handler] ! msg.int; cte.nlcs.first
                                    int.msg.handle[to.handler] ! msg.str; "; "
                                    int.msg.handle[to.handler] ! msg.bool; has.rest.clcs
                                    int.msg.handle[to.handler] ! msg.str; "; [array ("
                                    int.msg.handle[to.handler] ! msg.int; SIZE data.array
                                    int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                                    int.msg.handle[to.handler] ! msg.int; SIZE size.array
                                    int.msg.handle[to.handler] ! msg.str; ")]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: channel-ID of the relevant channel;
                            --           number of data-item NLCs in first CLC;
                            --           number of channel-type-end NLCs in first CLC;
                            --           are there remaining CLCs?
                            --           data-array;
                            --           size-array
                            ctb.main.handle[to.handler] ! first.clc; chan.id;
                                                                     di.nlcs.first; cte.nlcs.first;
                                                                     has.rest.clcs;
                                                                     data.array; size.array
                    --}}}
                    --{{{  In session: remaining CLCs of a ULC
                    PONYC.INT.TCPIP.LINKHEADER.INSESSION.RESTCLCS
                      INITIAL [BYTESIN (INT)]BYTE request.nct.id.array IS [header FROM 1 FOR BYTESIN (INT)]:
                      INT request.nct.id RETYPES request.nct.id.array:
                      INITIAL [BYTESIN (INT)]BYTE chan.id.array IS [header FROM (1 + BYTESIN (INT)) FOR BYTESIN (INT)]:
                      INT chan.id RETYPES chan.id.array:
                      INITIAL [BYTESIN (INT)]BYTE di.nlcs.rest.array IS [header FROM (1 + (2 * BYTESIN (INT))) FOR BYTESIN (INT)]:
                      INT di.nlcs.rest RETYPES di.nlcs.rest.array:
                      INITIAL [BYTESIN (INT)]BYTE cte.nlcs.rest.array IS [header FROM (1 + (3 * BYTESIN (INT))) FOR BYTESIN (INT)]:
                      INT cte.nlcs.rest RETYPES cte.nlcs.rest.array:
                      SHARED PONY.INT.CTBMAINHANDLE! ctb.main.handle:
                      SEQ
                        -- Get CTB-main-handle from CTB-manager
                        CLAIM ctb.mgr.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.main.handle; "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID
                            ctb.mgr.handle[to.mgr] ! get.ctb.main.handle; request.nct.id
                            -- Get reply
                            -- Carrying: CTB-main-handle
                            ctb.mgr.handle[from.mgr] ? CASE get.ctb.main.handle.confirm;
                                                            ctb.main.handle
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.main.handle.confirm; [cli-end]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                        -- Pass message on to CTB-handler
                        CLAIM ctb.main.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmainh "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.str; " [to.handler]: rest.clcs; "
                                    int.msg.handle[to.handler] ! msg.int; chan.id
                                    int.msg.handle[to.handler] ! msg.str; "; "
                                    int.msg.handle[to.handler] ! msg.int; di.nlcs.rest
                                    int.msg.handle[to.handler] ! msg.str; "; "
                                    int.msg.handle[to.handler] ! msg.int; cte.nlcs.rest
                                    int.msg.handle[to.handler] ! msg.str; "; [array ("
                                    int.msg.handle[to.handler] ! msg.int; SIZE data.array
                                    int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                                    int.msg.handle[to.handler] ! msg.int; SIZE size.array
                                    int.msg.handle[to.handler] ! msg.str; ")]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: channel-ID of the relevant channel;
                            --           number of data-item NLCs in remaining CLCs;
                            --           number of channel-type-end NLCs in remaining CLCs;
                            --           data-array;
                            --           size-array
                            ctb.main.handle[to.handler] ! rest.clcs; chan.id;
                                                                     di.nlcs.rest; cte.nlcs.rest;
                                                                     data.array; size.array
                    --}}}
                    --{{{  In session: acknowledge CLC
                    PONYC.INT.TCPIP.LINKHEADER.INSESSION.ACK
                      INITIAL [BYTESIN (INT)]BYTE request.nct.id.array IS [header FROM 1 FOR BYTESIN (INT)]:
                      INT request.nct.id RETYPES request.nct.id.array:
                      INITIAL [BYTESIN (INT)]BYTE chan.id.array IS [header FROM (1 + BYTESIN (INT)) FOR BYTESIN (INT)]:
                      INT chan.id RETYPES chan.id.array:
                      SHARED PONY.INT.CTBMAINHANDLE! ctb.main.handle:
                      SEQ
                        -- Get CTB-main-handle from CTB-manager
                        CLAIM ctb.mgr.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.main.handle; "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID
                            ctb.mgr.handle[to.mgr] ! get.ctb.main.handle; request.nct.id
                            -- Get reply
                            -- Carrying: CTB-main-handle
                            ctb.mgr.handle[from.mgr] ? CASE get.ctb.main.handle.confirm;
                                                            ctb.main.handle
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.main.handle.confirm; [cli-end]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                        -- Pass message on to CTB-handler
                        CLAIM ctb.main.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmainh "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.str; " [to.handler]: ack; "
                                    int.msg.handle[to.handler] ! msg.int; chan.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: channel-ID of the relevant channel
                            ctb.main.handle[to.handler] ! ack; chan.id
                    --}}}
                    --{{{  In session: cancel CLC
                    PONYC.INT.TCPIP.LINKHEADER.INSESSION.CANCEL
                      INITIAL [BYTESIN (INT)]BYTE request.nct.id.array IS [header FROM 1 FOR BYTESIN (INT)]:
                      INT request.nct.id RETYPES request.nct.id.array:
                      INITIAL [BYTESIN (INT)]BYTE chan.id.array IS [header FROM (1 + BYTESIN (INT)) FOR BYTESIN (INT)]:
                      INT chan.id RETYPES chan.id.array:
                      SHARED PONY.INT.CTBMAINHANDLE! ctb.main.handle:
                      SEQ
                        -- Get CTB-main-handle from CTB-manager
                        CLAIM ctb.mgr.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.main.handle; "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID
                            ctb.mgr.handle[to.mgr] ! get.ctb.main.handle; request.nct.id
                            -- Get reply
                            -- Carrying: CTB-main-handle
                            ctb.mgr.handle[from.mgr] ? CASE get.ctb.main.handle.confirm;
                                                            ctb.main.handle
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.main.handle.confirm; [cli-end]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                        -- Pass message on to CTB-handler
                        CLAIM ctb.main.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmainh "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.str; " [to.handler]: cancel; "
                                    int.msg.handle[to.handler] ! msg.int; chan.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: channel-ID of the relevant channel
                            ctb.main.handle[to.handler] ! cancel; chan.id
                    --}}}
                    --{{{  In session: close session
                    PONYC.INT.TCPIP.LINKHEADER.INSESSION.CLOSESESSION
                      INITIAL [BYTESIN (INT)]BYTE request.nct.id.array IS [header FROM 1 FOR BYTESIN (INT)]:
                      INT request.nct.id RETYPES request.nct.id.array:
                      SHARED PONY.INT.CTBMAINHANDLE! ctb.main.handle:
                      SEQ
                        -- Get CTB-main-handle from CTB-manager
                        CLAIM ctb.mgr.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.main.handle; "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID
                            ctb.mgr.handle[to.mgr] ! get.ctb.main.handle; request.nct.id
                            -- Get reply
                            -- Carrying: CTB-main-handle
                            ctb.mgr.handle[from.mgr] ? CASE get.ctb.main.handle.confirm;
                                                            ctb.main.handle
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.main.handle.confirm; [cli-end]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                        -- Pass message on to CTB-handler
                        CLAIM ctb.main.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmainh "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.str; " [to.handler]: close.session"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            ctb.main.handle[to.handler] ! close.session
                    --}}}
                    --{{{  In session: suspend session
                    PONYC.INT.TCPIP.LINKHEADER.INSESSION.SUSPENDSESSION
                      INITIAL [BYTESIN (INT)]BYTE request.nct.id.array IS [header FROM 1 FOR BYTESIN (INT)]:
                      INT request.nct.id RETYPES request.nct.id.array:
                      SHARED PONY.INT.CTBMAINHANDLE! ctb.main.handle:
                      SEQ
                        -- Get CTB-main-handle from CTB-manager
                        CLAIM ctb.mgr.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.main.handle; "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID
                            ctb.mgr.handle[to.mgr] ! get.ctb.main.handle; request.nct.id
                            -- Get reply
                            -- Carrying: CTB-main-handle
                            ctb.mgr.handle[from.mgr] ? CASE get.ctb.main.handle.confirm;
                                                            ctb.main.handle
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.main.handle.confirm; [cli-end]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                        -- Pass message on to CTB-handler
                        CLAIM ctb.main.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmainh "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.str; " [to.handler]: suspend.session"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            ctb.main.handle[to.handler] ! suspend.session
                    --}}}
                    --{{{  In session: confirm `suspend.session'
                    PONYC.INT.TCPIP.LINKHEADER.INSESSION.SUSPENDSESSIONCONFIRM
                      INITIAL [BYTESIN (INT)]BYTE request.nct.id.array IS [header FROM 1 FOR BYTESIN (INT)]:
                      INT request.nct.id RETYPES request.nct.id.array:
                      SHARED PONY.INT.CTBMAINHANDLE! ctb.main.handle:
                      SEQ
                        -- Get CTB-main-handle from CTB-manager
                        CLAIM ctb.mgr.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.main.handle; "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID
                            ctb.mgr.handle[to.mgr] ! get.ctb.main.handle; request.nct.id
                            -- Get reply
                            -- Carrying: CTB-main-handle
                            ctb.mgr.handle[from.mgr] ? CASE get.ctb.main.handle.confirm;
                                                            ctb.main.handle
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.main.handle.confirm; [cli-end]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                        -- Pass message on to CTB-handler
                        CLAIM ctb.main.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmainh "
                                    int.msg.handle[to.handler] ! msg.int; request.nct.id
                                    int.msg.handle[to.handler] ! msg.str; " [to.handler]: suspend.session.confirm"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            ctb.main.handle[to.handler] ! suspend.session.confirm
                    --}}}
                    --{{{  Shutdown
                    ELSE
                      SEQ
                        --{{{  SOCKET message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": SOCKET: Message was `shutdown*'"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        running := FALSE
                        -- Regular shutdown (error-flag is FALSE)
                        remote.shutdown ! FALSE
                    --}}}
    --}}}
    --{{{  Writer
    SEQ
      FORKING
        PONY.INT.TCPIP.LINKOUTCHAINHANDLE! first.chain.handle:
        PONY.INT.TCPIP.LINKOUTCHAINHANDLE? last.chain.handle.svr:
        SEQ
          --{{{  Allocate first/last chain-handle on dummy link-handler
          IF
            (own.node.id = 0) AND (remote.node.id = 0)
              first.chain.handle, last.chain.handle.svr := MOBILE PONY.INT.TCPIP.LINKOUTCHAINHANDLE
            TRUE
              SKIP
          --}}}
          PAR
            --{{{  Initialise chain on dummy link-handler
            IF
              (own.node.id = 0) AND (remote.node.id = 0)
                SEQ
                  --{{{  OUT message
                  IF
                    output.msgs
                      CLAIM int.msg.handle
                        SEQ
                          int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                          int.msg.handle[to.handler] ! msg.int; remote.node.id
                          int.msg.handle[to.handler] ! msg.str; ": OUT first.chainh: TRUE"
                          int.msg.handle[to.handler] ! msg.end; FALSE
                    TRUE
                      SKIP
                  --}}}
                  first.chain.handle[ready] ! TRUE
              TRUE
                SKIP
            --}}}
            SEQ
              --{{{  Main writer loop
              [1 + ((6 * BYTESIN (INT)) + BYTESIN (BOOL))]BYTE header:
              INT sock.result:
              INITIAL BOOL got.remote.shutdown IS ((own.node.id = 0) AND (remote.node.id = 0)):
              INITIAL BOOL got.shutdown.from.mgr IS FALSE:
              INITIAL BOOL was.socket.error IS FALSE:
              INITIAL BOOL running IS TRUE:
              WHILE running
                ALT
                  --{{{  Remote shutdown message (not possible if dummy link-handler)
                  BOOL was.read.error:
                  remote.shutdown ? was.read.error
                    SEQ
                      got.remote.shutdown := TRUE
                      --{{{  Close socket if read-error and socket previously error-free
                      IF
                        (NOT was.socket.error) AND was.read.error
                          SEQ
                            was.socket.error := TRUE
                            --{{{  SOCKET message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; remote.node.id
                                    int.msg.handle[to.handler] ! msg.str; ": SOCKET: Close socket"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            socket.close (write.socket)
                        TRUE
                          SKIP
                      --}}}
                      IF
                        --{{{  Already got shutdown from link-manager (only possible if slave)
                        got.shutdown.from.mgr
                          SEQ
                            running := FALSE
                            --{{{  Close socket if error-free
                            IF
                              NOT was.socket.error
                                SEQ
                                  --{{{  SOCKET message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                          int.msg.handle[to.handler] ! msg.int; remote.node.id
                                          int.msg.handle[to.handler] ! msg.str; ": SOCKET: Close socket"
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                                  socket.close (write.socket)
                              TRUE
                                SKIP
                            --}}}
                        --}}}
                        --{{{  No shutdown signal from link-manager yet
                        TRUE
                          SEQ
                            --{{{  Send shutdown to remote node now
                            IF
                              NOT was.socket.error
                                SEQ
                                  -- Send shutdown message to remote node
                                  header[0] := PONYC.INT.TCPIP.LINKHEADER.SHUTDOWN
                                  --{{{  SOCKET message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                          int.msg.handle[to.handler] ! msg.int; remote.node.id
                                          int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write `shutdown*'"
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                                  INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                                  pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                         null.int.array, null.int.array,
                                                                         sock.result)
                                  IF
                                    sock.result = (-1)
                                      SEQ
                                        was.socket.error := TRUE
                                        --{{{  SOCKET error message
                                        IF
                                          output.err.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                                int.msg.handle[to.handler] ! msg.end; TRUE
                                          TRUE
                                            SKIP
                                        --}}}
                                        --{{{  Send error to error-handler
                                        IF
                                          output.errs
                                            PONY.ERROR err:
                                            SEQ
                                              err[ans.concerned] := FALSE
                                              err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                              err[remote.node.concerned] := TRUE
                                              err[remote.node.id] := remote.node.id
                                              err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                              CLAIM int.err.handle
                                                SEQ
                                                  --{{{  OUT message
                                                  IF
                                                    output.msgs
                                                      CLAIM int.msg.handle
                                                        SEQ
                                                          int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                          int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                          int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                          int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                          int.msg.handle[to.handler] ! msg.str; ", "
                                                          int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                          int.msg.handle[to.handler] ! msg.str; ", "
                                                          int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                          int.msg.handle[to.handler] ! msg.str; ", "
                                                          int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                          int.msg.handle[to.handler] ! msg.str; ", "
                                                          int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                          int.msg.handle[to.handler] ! msg.str; "]"
                                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                                    TRUE
                                                      SKIP
                                                  --}}}
                                                  -- Carrying: error
                                                  int.err.handle[to.handler] ! report.err; err
                                          TRUE
                                            SKIP
                                        --}}}
                                        --{{{  SOCKET message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        socket.close (write.socket)
                                    TRUE
                                      SKIP
                              TRUE
                                SKIP
                            --}}}
                            --{{{  No need to wait if this is master node
                            IF
                              own.node.id = 0
                                SEQ
                                  running := FALSE
                                  --{{{  Close socket if error-free
                                  IF
                                    NOT was.socket.error
                                      SEQ
                                        --{{{  SOCKET message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                int.msg.handle[to.handler] ! msg.str; ": SOCKET: Close socket"
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        socket.close (write.socket)
                                    TRUE
                                      SKIP
                                  --}}}
                              TRUE
                                SKIP
                            --}}}
                        --}}}
                  --}}}
                  link.handle.svr[to.handler] ? CASE
                    --{{{  For NCT-manager: explicit allocation
                    INT dir.type, share.type.alloc, share.type.opposite, type.hash:
                    MOBILE []BYTE nct.name:
                    -- Carrying: direction-type of the end to be allocated
                    --             (0 = client-end, 1 = server-end);
                    --           share-type of the end to be allocated
                    --             (1 = unshared, 2 = shared);
                    --           share-type of the opposite end
                    --             (0 = unknown, 1 = unshared, 2 = shared);
                    --           type-hash of the NCT to be allocated;
                    --           name of the NCT
                    fornctmgr.alloc; dir.type; share.type.alloc; share.type.opposite;
                                     type.hash; nct.name
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: fornctmgr.alloc; "
                                int.msg.handle[to.handler] ! msg.int; dir.type
                                int.msg.handle[to.handler] ! msg.str; "; "
                                int.msg.handle[to.handler] ! msg.int; share.type.alloc
                                int.msg.handle[to.handler] ! msg.str; "; "
                                int.msg.handle[to.handler] ! msg.int; share.type.opposite
                                int.msg.handle[to.handler] ! msg.str; "; "
                                int.msg.handle[to.handler] ! msg.hex; type.hash
                                int.msg.handle[to.handler] ! msg.str; "; *""
                                int.msg.handle[to.handler] ! msg.str; CLONE nct.name
                                int.msg.handle[to.handler] ! msg.str; "*""
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        IF
                          --{{{  Dummy link-handler
                          (own.node.id = 0) AND (remote.node.id = 0)
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle:
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE? next.chain.handle.svr:
                            SEQ
                              -- Allocate next chain-handle
                              next.chain.handle, next.chain.handle.svr := MOBILE PONY.INT.TCPIP.LINKOUTCHAINHANDLE
                              --{{{  FORK message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": FORK pony.int.link.out.fornctmgr.alloc ([svr-end], [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.bool; output.msgs
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; dir.type
                                      int.msg.handle[to.handler] ! msg.str; ", "
                                      int.msg.handle[to.handler] ! msg.int; share.type.alloc
                                      int.msg.handle[to.handler] ! msg.str; ", "
                                      int.msg.handle[to.handler] ! msg.int; share.type.opposite
                                      int.msg.handle[to.handler] ! msg.str; ", "
                                      int.msg.handle[to.handler] ! msg.hex; type.hash
                                      int.msg.handle[to.handler] ! msg.str; ", *""
                                      int.msg.handle[to.handler] ! msg.str; CLONE nct.name
                                      int.msg.handle[to.handler] ! msg.str; "*")"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              FORK pony.int.link.out.fornctmgr.alloc (last.chain.handle.svr,
                                                     next.chain.handle, remote.node.id,
                                                     nct.mgr.handle, output.msgs, int.msg.handle,
                                                     dir.type, share.type.alloc,
                                                     share.type.opposite, type.hash,
                                                     nct.name)
                              -- Swap last chain-handle
                              last.chain.handle.svr := next.chain.handle.svr
                          --}}}
                          --{{{  Normal link-handler, previously error-free
                          NOT was.socket.error
                            INT nct.name.addr, nct.name.size:
                            SEQ
                              -- Assemble header
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.FORNCTMGR.ALLOC
                              []BYTE dir.type.array RETYPES dir.type:
                              [header FROM 1 FOR BYTESIN (INT)] := dir.type.array
                              []BYTE share.type.alloc.array RETYPES share.type.alloc:
                              [header FROM (1 + BYTESIN (INT)) FOR BYTESIN (INT)] := share.type.alloc.array
                              []BYTE share.type.opposite.array RETYPES share.type.opposite:
                              [header FROM (1 + (2 * BYTESIN (INT))) FOR BYTESIN (INT)] := share.type.opposite.array
                              []BYTE type.hash.array RETYPES type.hash:
                              [header FROM (1 + (3 * BYTESIN (INT))) FOR BYTESIN (INT)] := type.hash.array
                              -- Get address/size of NCT-name
                              DECODE.DATA (nct.name, nct.name.addr, nct.name.size)
                              -- Send message to remote node
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write message"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     [nct.name.addr], [nct.name.size],
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                          --}}}
                          TRUE
                            SKIP
                    --}}}
                    --{{{  For main kernel: explicit allocation - error
                    INT result:
                    -- Carrying: result
                    formainkernel.alloc.error; result
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: formainkernel.alloc.error; "
                                int.msg.handle[to.handler] ! msg.int; result
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        IF
                          --{{{  Dummy link-handler
                          (own.node.id = 0) AND (remote.node.id = 0)
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle:
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE? next.chain.handle.svr:
                            SEQ
                              -- Allocate next chain-handle
                              next.chain.handle, next.chain.handle.svr := MOBILE PONY.INT.TCPIP.LINKOUTCHAINHANDLE
                              --{{{  FORK message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": FORK pony.int.link.out.formainkernel.alloc.error ([svr-end], [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.bool; output.msgs
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; result
                                      int.msg.handle[to.handler] ! msg.str; ")"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              FORK pony.int.link.out.formainkernel.alloc.error (last.chain.handle.svr,
                                                     next.chain.handle, remote.node.id,
                                                     kernel.reply.handle, output.msgs, int.msg.handle,
                                                     result)
                              -- Swap last chain-handle
                              last.chain.handle.svr := next.chain.handle.svr
                          --}}}
                          --{{{  Normal link-handler, previously error-free
                          NOT was.socket.error
                            SEQ
                              -- Assemble header
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.FORMAINKERNEL.ALLOCERROR
                              []BYTE result.array RETYPES result:
                              [header FROM 1 FOR BYTESIN (INT)] := result.array
                              -- Send message to remote node
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write message"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     null.int.array, null.int.array,
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                          --}}}
                          TRUE
                            SKIP
                    --}}}
                    --{{{  For main kernel: explicit allocation - confirm
                    INT nct.id:
                    -- Carrying: NCT-ID of the newly allocated end
                    formainkernel.alloc.confirm; nct.id
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: formainkernel.alloc.confirm; "
                                int.msg.handle[to.handler] ! msg.int; nct.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        IF
                          --{{{  Dummy link-handler
                          (own.node.id = 0) AND (remote.node.id = 0)
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle:
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE? next.chain.handle.svr:
                            SEQ
                              -- Allocate next chain-handle
                              next.chain.handle, next.chain.handle.svr := MOBILE PONY.INT.TCPIP.LINKOUTCHAINHANDLE
                              --{{{  FORK message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": FORK pony.int.link.out.formainkernel.alloc.confirm ([svr-end], [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.bool; output.msgs
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; nct.id
                                      int.msg.handle[to.handler] ! msg.str; ")"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              FORK pony.int.link.out.formainkernel.alloc.confirm (last.chain.handle.svr,
                                                     next.chain.handle, remote.node.id,
                                                     kernel.reply.handle, output.msgs, int.msg.handle,
                                                     nct.id)
                              -- Swap last chain-handle
                              last.chain.handle.svr := next.chain.handle.svr
                          --}}}
                          --{{{  Normal link-handler, previously error-free
                          NOT was.socket.error
                            SEQ
                              -- Assemble header
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.FORMAINKERNEL.ALLOCCONFIRM
                              []BYTE nct.id.array RETYPES nct.id:
                              [header FROM 1 FOR BYTESIN (INT)] := nct.id.array
                              -- Send message to remote node
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write message"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     null.int.array, null.int.array,
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                          --}}}
                          TRUE
                            SKIP
                    --}}}
                    --{{{  For NCT-manager: make CTB networked
                    INT  request.nct.id, request.chan.id:
                    BOOL initial.cli.claimed, initial.svr.claimed:
                    -- Carrying: NCT-ID of the decode-handler making the request;
                    --           channel-ID of the decode-handler making the request;
                    --           client-end initially claimed?;
                    --           server-end initially claimed?
                    fornctmgr.make.ctb.networked; request.nct.id; request.chan.id;
                                                  initial.cli.claimed; initial.svr.claimed
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: fornctmgr.make.ctb.networked; "
                                int.msg.handle[to.handler] ! msg.int; request.nct.id
                                int.msg.handle[to.handler] ! msg.str; "; "
                                int.msg.handle[to.handler] ! msg.int; request.chan.id
                                int.msg.handle[to.handler] ! msg.str; "; "
                                int.msg.handle[to.handler] ! msg.bool; initial.cli.claimed
                                int.msg.handle[to.handler] ! msg.str; "; "
                                int.msg.handle[to.handler] ! msg.bool; initial.svr.claimed
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        IF
                          --{{{  Dummy link-handler
                          (own.node.id = 0) AND (remote.node.id = 0)
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle:
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE? next.chain.handle.svr:
                            SEQ
                              -- Allocate next chain-handle
                              next.chain.handle, next.chain.handle.svr := MOBILE PONY.INT.TCPIP.LINKOUTCHAINHANDLE
                              --{{{  FORK message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": FORK pony.int.link.out.fornctmgr.make.ctb.networked ([svr-end], [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.bool; output.msgs
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; request.nct.id
                                      int.msg.handle[to.handler] ! msg.str; ", "
                                      int.msg.handle[to.handler] ! msg.int; request.chan.id
                                      int.msg.handle[to.handler] ! msg.str; ", "
                                      int.msg.handle[to.handler] ! msg.bool; initial.cli.claimed
                                      int.msg.handle[to.handler] ! msg.str; ", "
                                      int.msg.handle[to.handler] ! msg.bool; initial.svr.claimed
                                      int.msg.handle[to.handler] ! msg.str; ")"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              FORK pony.int.link.out.fornctmgr.make.ctb.networked (last.chain.handle.svr,
                                                     next.chain.handle, remote.node.id,
                                                     nct.mgr.handle, output.msgs, int.msg.handle,
                                                     request.nct.id, request.chan.id,
                                                     initial.cli.claimed, initial.svr.claimed)
                              -- Swap last chain-handle
                              last.chain.handle.svr := next.chain.handle.svr
                          --}}}
                          --{{{  Normal link-handler, previously error-free
                          NOT was.socket.error
                            SEQ
                              -- Assemble header
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.FORNCTMGR.MAKECTBNETWORKED
                              []BYTE request.nct.id.array RETYPES request.nct.id:
                              [header FROM 1 FOR BYTESIN (INT)] := request.nct.id.array
                              []BYTE request.chan.id.array RETYPES request.chan.id:
                              [header FROM (1 + BYTESIN (INT)) FOR BYTESIN (INT)] := request.chan.id.array
                              INITIAL INT i.initial.cli.claimed IS INT initial.cli.claimed:
                              []BYTE initial.cli.claimed.array RETYPES i.initial.cli.claimed:
                              [header FROM (1 + (2 * BYTESIN (INT))) FOR BYTESIN (INT)] := initial.cli.claimed.array
                              INITIAL INT i.initial.svr.claimed IS INT initial.svr.claimed:
                              []BYTE initial.svr.claimed.array RETYPES i.initial.svr.claimed:
                              [header FROM (1 + (3 * BYTESIN (INT))) FOR BYTESIN (INT)] := initial.svr.claimed.array
                              -- Send message to remote node
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write message"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     null.int.array, null.int.array,
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                          --}}}
                          TRUE
                            SKIP
                    --}}}
                    --{{{  For decode-handler: make CTB networked - confirm
                    INT recipient.nct.id, recipient.chan.id, nct.id:
                    -- Carrying: NCT-ID of the recipient decode-handler;
                    --           channel-ID of the recipient decode-handler;
                    --           NCT-ID of the newly allocated end
                    fordechandler.make.ctb.networked.confirm; recipient.nct.id;
                                                              recipient.chan.id; nct.id
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: fordechandler.make.ctb.networked.confirm; "
                                int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                int.msg.handle[to.handler] ! msg.str; "; "
                                int.msg.handle[to.handler] ! msg.int; recipient.chan.id
                                int.msg.handle[to.handler] ! msg.str; "; "
                                int.msg.handle[to.handler] ! msg.int; nct.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        IF
                          --{{{  Dummy link-handler
                          (own.node.id = 0) AND (remote.node.id = 0)
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle:
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE? next.chain.handle.svr:
                            SEQ
                              -- Allocate next chain-handle
                              next.chain.handle, next.chain.handle.svr := MOBILE PONY.INT.TCPIP.LINKOUTCHAINHANDLE
                              --{{{  FORK message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": FORK pony.int.link.out.fordechandler.make.ctb.networked.confirm ([svr-end], [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.bool; output.msgs
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                      int.msg.handle[to.handler] ! msg.str; ", "
                                      int.msg.handle[to.handler] ! msg.int; recipient.chan.id
                                      int.msg.handle[to.handler] ! msg.str; ", "
                                      int.msg.handle[to.handler] ! msg.int; nct.id
                                      int.msg.handle[to.handler] ! msg.str; ")"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              FORK pony.int.link.out.fordechandler.make.ctb.networked.confirm (last.chain.handle.svr,
                                                     next.chain.handle, remote.node.id,
                                                     ctb.mgr.handle, output.msgs, int.msg.handle,
                                                     recipient.nct.id, recipient.chan.id, nct.id)
                              -- Swap last chain-handle
                              last.chain.handle.svr := next.chain.handle.svr
                          --}}}
                          --{{{  Normal link-handler, previously error-free
                          NOT was.socket.error
                            SEQ
                              -- Assemble header
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.FORDECHANDLER.MAKECTBNETWORKEDCONFIRM
                              []BYTE recipient.nct.id.array RETYPES recipient.nct.id:
                              [header FROM 1 FOR BYTESIN (INT)] := recipient.nct.id.array
                              []BYTE recipient.chan.id.array RETYPES recipient.chan.id:
                              [header FROM (1 + BYTESIN (INT)) FOR BYTESIN (INT)] := recipient.chan.id.array
                              []BYTE nct.id.array RETYPES nct.id:
                              [header FROM (1 + (2 * BYTESIN (INT))) FOR BYTESIN (INT)] := nct.id.array
                              -- Send message to remote node
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write message"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     null.int.array, null.int.array,
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                          --}}}
                          TRUE
                            SKIP
                    --}}}
                    --{{{  For NCT-handler: claim client-end
                    INT request.nct.id:
                    -- Carrying: NCT-ID of the CTB-handler making the request
                    forncthandler.claim.cli; request.nct.id
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: forncthandler.claim.cli; "
                                int.msg.handle[to.handler] ! msg.int; request.nct.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        IF
                          --{{{  Dummy link-handler
                          (own.node.id = 0) AND (remote.node.id = 0)
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle:
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE? next.chain.handle.svr:
                            SEQ
                              -- Allocate next chain-handle
                              next.chain.handle, next.chain.handle.svr := MOBILE PONY.INT.TCPIP.LINKOUTCHAINHANDLE
                              --{{{  FORK message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": FORK pony.int.link.out.forncthandler.claim.cli ([svr-end], [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.bool; output.msgs
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; request.nct.id
                                      int.msg.handle[to.handler] ! msg.str; ")"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              FORK pony.int.link.out.forncthandler.claim.cli (last.chain.handle.svr,
                                                     next.chain.handle, remote.node.id,
                                                     nct.mgr.handle, output.msgs, int.msg.handle,
                                                     request.nct.id)
                              -- Swap last chain-handle
                              last.chain.handle.svr := next.chain.handle.svr
                          --}}}
                          --{{{  Normal link-handler, previously error-free
                          NOT was.socket.error
                            SEQ
                              -- Assemble header
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.FORNCTHANDLER.CLAIMCLI
                              []BYTE request.nct.id.array RETYPES request.nct.id:
                              [header FROM 1 FOR BYTESIN (INT)] := request.nct.id.array
                              -- Send message to remote node
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write message"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     null.int.array, null.int.array,
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                          --}}}
                          TRUE
                            SKIP
                    --}}}
                    --{{{  For NCT-handler: claim server-end
                    INT request.nct.id:
                    -- Carrying: NCT-ID of the CTB-handler making the request
                    forncthandler.claim.svr; request.nct.id
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: forncthandler.claim.svr; "
                                int.msg.handle[to.handler] ! msg.int; request.nct.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        IF
                          --{{{  Dummy link-handler
                          (own.node.id = 0) AND (remote.node.id = 0)
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle:
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE? next.chain.handle.svr:
                            SEQ
                              -- Allocate next chain-handle
                              next.chain.handle, next.chain.handle.svr := MOBILE PONY.INT.TCPIP.LINKOUTCHAINHANDLE
                              --{{{  FORK message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": FORK pony.int.link.out.forncthandler.claim.svr ([svr-end], [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.bool; output.msgs
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; request.nct.id
                                      int.msg.handle[to.handler] ! msg.str; ")"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              FORK pony.int.link.out.forncthandler.claim.svr (last.chain.handle.svr,
                                                     next.chain.handle, remote.node.id,
                                                     nct.mgr.handle, output.msgs, int.msg.handle,
                                                     request.nct.id)
                              -- Swap last chain-handle
                              last.chain.handle.svr := next.chain.handle.svr
                          --}}}
                          --{{{  Normal link-handler, previously error-free
                          NOT was.socket.error
                            SEQ
                              -- Assemble header
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.FORNCTHANDLER.CLAIMSVR
                              []BYTE request.nct.id.array RETYPES request.nct.id:
                              [header FROM 1 FOR BYTESIN (INT)] := request.nct.id.array
                              -- Send message to remote node
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write message"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     null.int.array, null.int.array,
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                          --}}}
                          TRUE
                            SKIP
                    --}}}
                    --{{{  For NCT-handler: confirm new-other-end
                    INT request.nct.id:
                    -- Carrying: NCT-ID of the CTB-handler making the request
                    forncthandler.new.other.end.confirm; request.nct.id
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: forncthandler.new.other.end.confirm; "
                                int.msg.handle[to.handler] ! msg.int; request.nct.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        IF
                          --{{{  Dummy link-handler
                          (own.node.id = 0) AND (remote.node.id = 0)
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle:
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE? next.chain.handle.svr:
                            SEQ
                              -- Allocate next chain-handle
                              next.chain.handle, next.chain.handle.svr := MOBILE PONY.INT.TCPIP.LINKOUTCHAINHANDLE
                              --{{{  FORK message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": FORK pony.int.link.out.forncthandler.new.other.end.confirm ([svr-end], [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.bool; output.msgs
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; request.nct.id
                                      int.msg.handle[to.handler] ! msg.str; ")"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              FORK pony.int.link.out.forncthandler.new.other.end.confirm (last.chain.handle.svr,
                                                     next.chain.handle, remote.node.id,
                                                     nct.mgr.handle, output.msgs, int.msg.handle,
                                                     request.nct.id)
                              -- Swap last chain-handle
                              last.chain.handle.svr := next.chain.handle.svr
                          --}}}
                          --{{{  Normal link-handler, previously error-free
                          NOT was.socket.error
                            SEQ
                              -- Assemble header
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.FORNCTHANDLER.NEWOTHERENDCONFIRM
                              []BYTE request.nct.id.array RETYPES request.nct.id:
                              [header FROM 1 FOR BYTESIN (INT)] := request.nct.id.array
                              -- Send message to remote node
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write message"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     null.int.array, null.int.array,
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                          --}}}
                          TRUE
                            SKIP
                    --}}}
                    --{{{  For NCT-handler: release client-end
                    INT request.nct.id:
                    -- Carrying: NCT-ID of the CTB-handler making the request
                    forncthandler.release.cli; request.nct.id
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: forncthandler.release.cli; "
                                int.msg.handle[to.handler] ! msg.int; request.nct.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        IF
                          --{{{  Dummy link-handler
                          (own.node.id = 0) AND (remote.node.id = 0)
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle:
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE? next.chain.handle.svr:
                            SEQ
                              -- Allocate next chain-handle
                              next.chain.handle, next.chain.handle.svr := MOBILE PONY.INT.TCPIP.LINKOUTCHAINHANDLE
                              --{{{  FORK message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": FORK pony.int.link.out.forncthandler.release.cli ([svr-end], [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.bool; output.msgs
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; request.nct.id
                                      int.msg.handle[to.handler] ! msg.str; ")"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              FORK pony.int.link.out.forncthandler.release.cli (last.chain.handle.svr,
                                                     next.chain.handle, remote.node.id,
                                                     nct.mgr.handle, output.msgs, int.msg.handle,
                                                     request.nct.id)
                              -- Swap last chain-handle
                              last.chain.handle.svr := next.chain.handle.svr
                          --}}}
                          --{{{  Normal link-handler, previously error-free
                          NOT was.socket.error
                            SEQ
                              -- Assemble header
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.FORNCTHANDLER.RELEASECLI
                              []BYTE request.nct.id.array RETYPES request.nct.id:
                              [header FROM 1 FOR BYTESIN (INT)] := request.nct.id.array
                              -- Send message to remote node
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write message"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     null.int.array, null.int.array,
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                          --}}}
                          TRUE
                            SKIP
                    --}}}
                    --{{{  For NCT-handler: release server-end
                    INT request.nct.id:
                    -- Carrying: NCT-ID of the CTB-handler making the request
                    forncthandler.release.svr; request.nct.id
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: forncthandler.release.svr; "
                                int.msg.handle[to.handler] ! msg.int; request.nct.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        IF
                          --{{{  Dummy link-handler
                          (own.node.id = 0) AND (remote.node.id = 0)
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle:
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE? next.chain.handle.svr:
                            SEQ
                              -- Allocate next chain-handle
                              next.chain.handle, next.chain.handle.svr := MOBILE PONY.INT.TCPIP.LINKOUTCHAINHANDLE
                              --{{{  FORK message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": FORK pony.int.link.out.forncthandler.release.svr ([svr-end], [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.bool; output.msgs
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; request.nct.id
                                      int.msg.handle[to.handler] ! msg.str; ")"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              FORK pony.int.link.out.forncthandler.release.svr (last.chain.handle.svr,
                                                     next.chain.handle, remote.node.id,
                                                     nct.mgr.handle, output.msgs, int.msg.handle,
                                                     request.nct.id)
                              -- Swap last chain-handle
                              last.chain.handle.svr := next.chain.handle.svr
                          --}}}
                          --{{{  Normal link-handler, previously error-free
                          NOT was.socket.error
                            SEQ
                              -- Assemble header
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.FORNCTHANDLER.RELEASESVR
                              []BYTE request.nct.id.array RETYPES request.nct.id:
                              [header FROM 1 FOR BYTESIN (INT)] := request.nct.id.array
                              -- Send message to remote node
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write message"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     null.int.array, null.int.array,
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                          --}}}
                          TRUE
                            SKIP
                    --}}}
                    --{{{  For NCT-handler: end-over-itself operation completed
                    INT request.nct.id:
                    -- Carrying: NCT-ID of the CTB-handler making the request
                    forncthandler.eoi.done; request.nct.id
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: forncthandler.eoi.done; "
                                int.msg.handle[to.handler] ! msg.int; request.nct.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        IF
                          --{{{  Dummy link-handler
                          (own.node.id = 0) AND (remote.node.id = 0)
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle:
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE? next.chain.handle.svr:
                            SEQ
                              -- Allocate next chain-handle
                              next.chain.handle, next.chain.handle.svr := MOBILE PONY.INT.TCPIP.LINKOUTCHAINHANDLE
                              --{{{  FORK message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": FORK pony.int.link.out.forncthandler.eoi.done ([svr-end], [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.bool; output.msgs
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; request.nct.id
                                      int.msg.handle[to.handler] ! msg.str; ")"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              FORK pony.int.link.out.forncthandler.eoi.done (last.chain.handle.svr,
                                                     next.chain.handle, remote.node.id,
                                                     nct.mgr.handle, output.msgs, int.msg.handle,
                                                     request.nct.id)
                              -- Swap last chain-handle
                              last.chain.handle.svr := next.chain.handle.svr
                          --}}}
                          --{{{  Normal link-handler, previously error-free
                          NOT was.socket.error
                            SEQ
                              -- Assemble header
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.FORNCTHANDLER.EOIDONE
                              []BYTE request.nct.id.array RETYPES request.nct.id:
                              [header FROM 1 FOR BYTESIN (INT)] := request.nct.id.array
                              -- Send message to remote node
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write message"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     null.int.array, null.int.array,
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                          --}}}
                          TRUE
                            SKIP
                    --}}}
                    --{{{  For CTB-handler regarding client-end: confirm claim - no other end
                    INT recipient.nct.id:
                    -- Carrying: NCT-ID of the recipient CTB-handler
                    forctbhandler.reclient.claim.confirm.nootherend; recipient.nct.id
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: forctbhandler.reclient.claim.confirm.nootherend; "
                                int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        IF
                          --{{{  Dummy link-handler
                          (own.node.id = 0) AND (remote.node.id = 0)
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle:
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE? next.chain.handle.svr:
                            SEQ
                              -- Allocate next chain-handle
                              next.chain.handle, next.chain.handle.svr := MOBILE PONY.INT.TCPIP.LINKOUTCHAINHANDLE
                              --{{{  FORK message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": FORK pony.int.link.out.forctbhandler.reclient.claim.confirm.nootherend ([svr-end], [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.bool; output.msgs
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                      int.msg.handle[to.handler] ! msg.str; ")"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              FORK pony.int.link.out.forctbhandler.reclient.claim.confirm.nootherend (last.chain.handle.svr,
                                                     next.chain.handle, remote.node.id,
                                                     ctb.mgr.handle, output.msgs, int.msg.handle,
                                                     recipient.nct.id)
                              -- Swap last chain-handle
                              last.chain.handle.svr := next.chain.handle.svr
                          --}}}
                          --{{{  Normal link-handler, previously error-free
                          NOT was.socket.error
                            SEQ
                              -- Assemble header
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.FORCTBHANDLER.RECLIENTCLAIMCONFIRMNOOTHEREND
                              []BYTE recipient.nct.id.array RETYPES recipient.nct.id:
                              [header FROM 1 FOR BYTESIN (INT)] := recipient.nct.id.array
                              -- Send message to remote node
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write message"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     null.int.array, null.int.array,
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                          --}}}
                          TRUE
                            SKIP
                    --}}}
                    --{{{  For CTB-handler regarding server-end: confirm claim - no other end
                    INT recipient.nct.id:
                    -- Carrying: NCT-ID of the recipient CTB-handler
                    forctbhandler.reserver.claim.confirm.nootherend; recipient.nct.id
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: forctbhandler.reserver.claim.confirm.nootherend; "
                                int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        IF
                          --{{{  Dummy link-handler
                          (own.node.id = 0) AND (remote.node.id = 0)
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle:
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE? next.chain.handle.svr:
                            SEQ
                              -- Allocate next chain-handle
                              next.chain.handle, next.chain.handle.svr := MOBILE PONY.INT.TCPIP.LINKOUTCHAINHANDLE
                              --{{{  FORK message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": FORK pony.int.link.out.forctbhandler.reserver.claim.confirm.nootherend ([svr-end], [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.bool; output.msgs
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                      int.msg.handle[to.handler] ! msg.str; ")"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              FORK pony.int.link.out.forctbhandler.reserver.claim.confirm.nootherend (last.chain.handle.svr,
                                                     next.chain.handle, remote.node.id,
                                                     ctb.mgr.handle, output.msgs, int.msg.handle,
                                                     recipient.nct.id)
                              -- Swap last chain-handle
                              last.chain.handle.svr := next.chain.handle.svr
                          --}}}
                          --{{{  Normal link-handler, previously error-free
                          NOT was.socket.error
                            SEQ
                              -- Assemble header
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.FORCTBHANDLER.RESERVERCLAIMCONFIRMNOOTHEREND
                              []BYTE recipient.nct.id.array RETYPES recipient.nct.id:
                              [header FROM 1 FOR BYTESIN (INT)] := recipient.nct.id.array
                              -- Send message to remote node
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write message"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     null.int.array, null.int.array,
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                          --}}}
                          TRUE
                            SKIP
                    --}}}
                    --{{{  For CTB-handler regarding client-end: confirm claim - other end claimed
                    INT recipient.nct.id, node.id:
                    -- Carrying: NCT-ID of the recipient CTB-handler;
                    --           node-ID of the other end's node
                    forctbhandler.reclient.claim.confirm.otherendclaimed; recipient.nct.id; node.id
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: forctbhandler.reclient.claim.confirm.otherendclaimed; "
                                int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                int.msg.handle[to.handler] ! msg.str; "; "
                                int.msg.handle[to.handler] ! msg.int; node.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        IF
                          --{{{  Dummy link-handler
                          (own.node.id = 0) AND (remote.node.id = 0)
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle:
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE? next.chain.handle.svr:
                            SEQ
                              -- Allocate next chain-handle
                              next.chain.handle, next.chain.handle.svr := MOBILE PONY.INT.TCPIP.LINKOUTCHAINHANDLE
                              --{{{  FORK message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": FORK pony.int.link.out.forctbhandler.reclient.claim.confirm.otherendclaimed ([svr-end], [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.bool; output.msgs
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                      int.msg.handle[to.handler] ! msg.str; ", "
                                      int.msg.handle[to.handler] ! msg.int; node.id
                                      int.msg.handle[to.handler] ! msg.str; ")"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              FORK pony.int.link.out.forctbhandler.reclient.claim.confirm.otherendclaimed (last.chain.handle.svr,
                                                     next.chain.handle, remote.node.id,
                                                     ctb.mgr.handle, output.msgs, int.msg.handle,
                                                     recipient.nct.id, node.id)
                              -- Swap last chain-handle
                              last.chain.handle.svr := next.chain.handle.svr
                          --}}}
                          --{{{  Normal link-handler, previously error-free
                          NOT was.socket.error
                            SEQ
                              -- Assemble header
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.FORCTBHANDLER.RECLIENTCLAIMCONFIRMOTHERENDCLAIMED
                              []BYTE recipient.nct.id.array RETYPES recipient.nct.id:
                              [header FROM 1 FOR BYTESIN (INT)] := recipient.nct.id.array
                              []BYTE node.id.array RETYPES node.id:
                              [header FROM (1 + BYTESIN (INT)) FOR BYTESIN (INT)] := node.id.array
                              --{{{  Get location of `other end's node' if applicable
                              IF
                                (node.id > 0) AND (node.id < remote.node.id)
                                  INT node.ip, node.port:
                                  SEQ
                                    CLAIM link.mgr.handle.tcpip
                                      SEQ
                                        --{{{  OUT message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                int.msg.handle[to.handler] ! msg.str; ": OUT linkmgrh.tcpip: get.location; "
                                                int.msg.handle[to.handler] ! msg.int; node.id
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        -- Carrying: node-ID
                                        link.mgr.handle.tcpip[to.mgr] ! get.location; node.id
                                        -- Get reply
                                        -- Carrying: IP address;
                                        --           port number
                                        link.mgr.handle.tcpip[from.mgr] ? CASE get.location.confirm;
                                                                               node.ip; node.port
                                        --{{{  IN message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                int.msg.handle[to.handler] ! msg.str; ": IN linkmgrh.tcpip: get.location.confirm; "
                                                int.msg.handle[to.handler] ! msg.hex; node.ip
                                                int.msg.handle[to.handler] ! msg.str; "; "
                                                int.msg.handle[to.handler] ! msg.int; node.port
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                    -- Save location in header
                                    []BYTE node.ip.array RETYPES node.ip:
                                    [header FROM (1 + (2 * BYTESIN (INT))) FOR BYTESIN (INT)] := node.ip.array
                                    []BYTE node.port.array RETYPES node.port:
                                    [header FROM (1 + (3 * BYTESIN (INT))) FOR BYTESIN (INT)] := node.port.array
                                TRUE
                                  SKIP
                              --}}}
                              -- Send message to remote node
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write message"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     null.int.array, null.int.array,
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                          --}}}
                          TRUE
                            SKIP
                    --}}}
                    --{{{  For CTB-handler regarding server-end: confirm claim - other end claimed
                    INT recipient.nct.id, node.id:
                    -- Carrying: NCT-ID of the recipient CTB-handler;
                    --           node-ID of the other end's node
                    forctbhandler.reserver.claim.confirm.otherendclaimed; recipient.nct.id; node.id
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: forctbhandler.reserver.claim.confirm.otherendclaimed; "
                                int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                int.msg.handle[to.handler] ! msg.str; "; "
                                int.msg.handle[to.handler] ! msg.int; node.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        IF
                          --{{{  Dummy link-handler
                          (own.node.id = 0) AND (remote.node.id = 0)
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle:
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE? next.chain.handle.svr:
                            SEQ
                              -- Allocate next chain-handle
                              next.chain.handle, next.chain.handle.svr := MOBILE PONY.INT.TCPIP.LINKOUTCHAINHANDLE
                              --{{{  FORK message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": FORK pony.int.link.out.forctbhandler.reserver.claim.confirm.otherendclaimed ([svr-end], [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.bool; output.msgs
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                      int.msg.handle[to.handler] ! msg.str; ", "
                                      int.msg.handle[to.handler] ! msg.int; node.id
                                      int.msg.handle[to.handler] ! msg.str; ")"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              FORK pony.int.link.out.forctbhandler.reserver.claim.confirm.otherendclaimed (last.chain.handle.svr,
                                                     next.chain.handle, remote.node.id,
                                                     ctb.mgr.handle, output.msgs, int.msg.handle,
                                                     recipient.nct.id, node.id)
                              -- Swap last chain-handle
                              last.chain.handle.svr := next.chain.handle.svr
                          --}}}
                          --{{{  Normal link-handler, previously error-free
                          NOT was.socket.error
                            SEQ
                              -- Assemble header
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.FORCTBHANDLER.RESERVERCLAIMCONFIRMOTHERENDCLAIMED
                              []BYTE recipient.nct.id.array RETYPES recipient.nct.id:
                              [header FROM 1 FOR BYTESIN (INT)] := recipient.nct.id.array
                              []BYTE node.id.array RETYPES node.id:
                              [header FROM (1 + BYTESIN (INT)) FOR BYTESIN (INT)] := node.id.array
                              --{{{  Get location of `other end's node' if applicable
                              IF
                                (node.id > 0) AND (node.id < remote.node.id)
                                  INT node.ip, node.port:
                                  SEQ
                                    CLAIM link.mgr.handle.tcpip
                                      SEQ
                                        --{{{  OUT message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                int.msg.handle[to.handler] ! msg.str; ": OUT linkmgrh.tcpip: get.location; "
                                                int.msg.handle[to.handler] ! msg.int; node.id
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        -- Carrying: node-ID
                                        link.mgr.handle.tcpip[to.mgr] ! get.location; node.id
                                        -- Get reply
                                        -- Carrying: IP address;
                                        --           port number
                                        link.mgr.handle.tcpip[from.mgr] ? CASE get.location.confirm;
                                                                               node.ip; node.port
                                        --{{{  IN message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                int.msg.handle[to.handler] ! msg.str; ": IN linkmgrh.tcpip: get.location.confirm; "
                                                int.msg.handle[to.handler] ! msg.hex; node.ip
                                                int.msg.handle[to.handler] ! msg.str; "; "
                                                int.msg.handle[to.handler] ! msg.int; node.port
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                    -- Save location in header
                                    []BYTE node.ip.array RETYPES node.ip:
                                    [header FROM (1 + (2 * BYTESIN (INT))) FOR BYTESIN (INT)] := node.ip.array
                                    []BYTE node.port.array RETYPES node.port:
                                    [header FROM (1 + (3 * BYTESIN (INT))) FOR BYTESIN (INT)] := node.port.array
                                TRUE
                                  SKIP
                              --}}}
                              -- Send message to remote node
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write message"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     null.int.array, null.int.array,
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                          --}}}
                          TRUE
                            SKIP
                    --}}}
                    --{{{  For CTB-handler regarding client-end: new other end
                    INT recipient.nct.id, node.id:
                    -- Carrying: NCT-ID of the recipient CTB-handler;
                    --           node-ID of the other end's node
                    forctbhandler.reclient.new.other.end; recipient.nct.id; node.id
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: forctbhandler.reclient.new.other.end; "
                                int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                int.msg.handle[to.handler] ! msg.str; "; "
                                int.msg.handle[to.handler] ! msg.int; node.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        IF
                          --{{{  Dummy link-handler
                          (own.node.id = 0) AND (remote.node.id = 0)
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle:
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE? next.chain.handle.svr:
                            SEQ
                              -- Allocate next chain-handle
                              next.chain.handle, next.chain.handle.svr := MOBILE PONY.INT.TCPIP.LINKOUTCHAINHANDLE
                              --{{{  FORK message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": FORK pony.int.link.out.forctbhandler.reclient.new.other.end ([svr-end], [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.bool; output.msgs
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                      int.msg.handle[to.handler] ! msg.str; ", "
                                      int.msg.handle[to.handler] ! msg.int; node.id
                                      int.msg.handle[to.handler] ! msg.str; ")"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              FORK pony.int.link.out.forctbhandler.reclient.new.other.end (last.chain.handle.svr,
                                                     next.chain.handle, remote.node.id,
                                                     ctb.mgr.handle, output.msgs, int.msg.handle,
                                                     recipient.nct.id, node.id)
                              -- Swap last chain-handle
                              last.chain.handle.svr := next.chain.handle.svr
                          --}}}
                          --{{{  Normal link-handler, previously error-free
                          NOT was.socket.error
                            SEQ
                              -- Assemble header
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.FORCTBHANDLER.RECLIENTNEWOTHEREND
                              []BYTE recipient.nct.id.array RETYPES recipient.nct.id:
                              [header FROM 1 FOR BYTESIN (INT)] := recipient.nct.id.array
                              []BYTE node.id.array RETYPES node.id:
                              [header FROM (1 + BYTESIN (INT)) FOR BYTESIN (INT)] := node.id.array
                              --{{{  Get location of `other end's node' if applicable
                              IF
                                (node.id > 0) AND (node.id < remote.node.id)
                                  INT node.ip, node.port:
                                  SEQ
                                    CLAIM link.mgr.handle.tcpip
                                      SEQ
                                        --{{{  OUT message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                int.msg.handle[to.handler] ! msg.str; ": OUT linkmgrh.tcpip: get.location; "
                                                int.msg.handle[to.handler] ! msg.int; node.id
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        -- Carrying: node-ID
                                        link.mgr.handle.tcpip[to.mgr] ! get.location; node.id
                                        -- Get reply
                                        -- Carrying: IP address;
                                        --           port number
                                        link.mgr.handle.tcpip[from.mgr] ? CASE get.location.confirm;
                                                                               node.ip; node.port
                                        --{{{  IN message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                int.msg.handle[to.handler] ! msg.str; ": IN linkmgrh.tcpip: get.location.confirm; "
                                                int.msg.handle[to.handler] ! msg.hex; node.ip
                                                int.msg.handle[to.handler] ! msg.str; "; "
                                                int.msg.handle[to.handler] ! msg.int; node.port
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                    -- Save location in header
                                    []BYTE node.ip.array RETYPES node.ip:
                                    [header FROM (1 + (2 * BYTESIN (INT))) FOR BYTESIN (INT)] := node.ip.array
                                    []BYTE node.port.array RETYPES node.port:
                                    [header FROM (1 + (3 * BYTESIN (INT))) FOR BYTESIN (INT)] := node.port.array
                                TRUE
                                  SKIP
                              --}}}
                              -- Send message to remote node
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write message"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     null.int.array, null.int.array,
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                          --}}}
                          TRUE
                            SKIP
                    --}}}
                    --{{{  For CTB-handler regarding server-end: new other end
                    INT recipient.nct.id, node.id:
                    -- Carrying: NCT-ID of the recipient CTB-handler;
                    --           node-ID of the other end's node
                    forctbhandler.reserver.new.other.end; recipient.nct.id; node.id
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: forctbhandler.reserver.new.other.end; "
                                int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                int.msg.handle[to.handler] ! msg.str; "; "
                                int.msg.handle[to.handler] ! msg.int; node.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        IF
                          --{{{  Dummy link-handler
                          (own.node.id = 0) AND (remote.node.id = 0)
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE! next.chain.handle:
                            PONY.INT.TCPIP.LINKOUTCHAINHANDLE? next.chain.handle.svr:
                            SEQ
                              -- Allocate next chain-handle
                              next.chain.handle, next.chain.handle.svr := MOBILE PONY.INT.TCPIP.LINKOUTCHAINHANDLE
                              --{{{  FORK message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": FORK pony.int.link.out.forctbhandler.reserver.new.other.end ([svr-end], [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.bool; output.msgs
                                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                      int.msg.handle[to.handler] ! msg.int; recipient.nct.id
                                      int.msg.handle[to.handler] ! msg.str; ", "
                                      int.msg.handle[to.handler] ! msg.int; node.id
                                      int.msg.handle[to.handler] ! msg.str; ")"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              FORK pony.int.link.out.forctbhandler.reserver.new.other.end (last.chain.handle.svr,
                                                     next.chain.handle, remote.node.id,
                                                     ctb.mgr.handle, output.msgs, int.msg.handle,
                                                     recipient.nct.id, node.id)
                              -- Swap last chain-handle
                              last.chain.handle.svr := next.chain.handle.svr
                          --}}}
                          --{{{  Normal link-handler, previously error-free
                          NOT was.socket.error
                            SEQ
                              -- Assemble header
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.FORCTBHANDLER.RESERVERNEWOTHEREND
                              []BYTE recipient.nct.id.array RETYPES recipient.nct.id:
                              [header FROM 1 FOR BYTESIN (INT)] := recipient.nct.id.array
                              []BYTE node.id.array RETYPES node.id:
                              [header FROM (1 + BYTESIN (INT)) FOR BYTESIN (INT)] := node.id.array
                              --{{{  Get location of `other end's node' if applicable
                              IF
                                (node.id > 0) AND (node.id < remote.node.id)
                                  INT node.ip, node.port:
                                  SEQ
                                    CLAIM link.mgr.handle.tcpip
                                      SEQ
                                        --{{{  OUT message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                int.msg.handle[to.handler] ! msg.str; ": OUT linkmgrh.tcpip: get.location; "
                                                int.msg.handle[to.handler] ! msg.int; node.id
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        -- Carrying: node-ID
                                        link.mgr.handle.tcpip[to.mgr] ! get.location; node.id
                                        -- Get reply
                                        -- Carrying: IP address;
                                        --           port number
                                        link.mgr.handle.tcpip[from.mgr] ? CASE get.location.confirm;
                                                                               node.ip; node.port
                                        --{{{  IN message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                int.msg.handle[to.handler] ! msg.str; ": IN linkmgrh.tcpip: get.location.confirm; "
                                                int.msg.handle[to.handler] ! msg.hex; node.ip
                                                int.msg.handle[to.handler] ! msg.str; "; "
                                                int.msg.handle[to.handler] ! msg.int; node.port
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                    -- Save location in header
                                    []BYTE node.ip.array RETYPES node.ip:
                                    [header FROM (1 + (2 * BYTESIN (INT))) FOR BYTESIN (INT)] := node.ip.array
                                    []BYTE node.port.array RETYPES node.port:
                                    [header FROM (1 + (3 * BYTESIN (INT))) FOR BYTESIN (INT)] := node.port.array
                                TRUE
                                  SKIP
                              --}}}
                              -- Send message to remote node
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write message"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     null.int.array, null.int.array,
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                          --}}}
                          TRUE
                            SKIP
                    --}}}
                    --{{{  In session (not possible for dummy link-handler): start session
                    INT request.nct.id:
                    -- Carrying: NCT-ID of the CTB-handler making the request
                    insession.start.session; request.nct.id
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: insession.start.session; "
                                int.msg.handle[to.handler] ! msg.int; request.nct.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        IF
                          --{{{  Previously error-free
                          NOT was.socket.error
                            SEQ
                              -- Assemble header
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.INSESSION.STARTSESSION
                              []BYTE request.nct.id.array RETYPES request.nct.id:
                              [header FROM 1 FOR BYTESIN (INT)] := request.nct.id.array
                              -- Send message to remote node
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write message"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     null.int.array, null.int.array,
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                          --}}}
                          TRUE
                            SKIP
                    --}}}
                    --{{{  In session (not possible for dummy link-handler): first CLC of a ULC
                    INT request.nct.id, chan.id, di.nlcs.first, cte.nlcs.first:
                    BOOL has.rest.clcs:
                    MOBILE []INT addr.array, size.array:
                    -- Carrying: NCT-ID of the CTB-handler making the request;
                    --           channel-ID of the relevant channel;
                    --           number of data-item NLCs in first CLC;
                    --           number of channel-type-end NLCs in first CLC;
                    --           are there remaining CLCs?;
                    --           address-array;
                    --           size-array
                    insession.first.clc; request.nct.id; chan.id;
                                         di.nlcs.first; cte.nlcs.first;
                                         has.rest.clcs;
                                         addr.array; size.array
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: insession.first.clc; "
                                int.msg.handle[to.handler] ! msg.int; request.nct.id
                                int.msg.handle[to.handler] ! msg.str; "; "
                                int.msg.handle[to.handler] ! msg.int; chan.id
                                int.msg.handle[to.handler] ! msg.str; "; "
                                int.msg.handle[to.handler] ! msg.int; di.nlcs.first
                                int.msg.handle[to.handler] ! msg.str; "; "
                                int.msg.handle[to.handler] ! msg.int; cte.nlcs.first
                                int.msg.handle[to.handler] ! msg.str; "; "
                                int.msg.handle[to.handler] ! msg.bool; has.rest.clcs
                                int.msg.handle[to.handler] ! msg.str; "; [array ("
                                int.msg.handle[to.handler] ! msg.int; SIZE addr.array
                                int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                                int.msg.handle[to.handler] ! msg.int; SIZE size.array
                                int.msg.handle[to.handler] ! msg.str; ")]"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        IF
                          --{{{  Previously error-free
                          NOT was.socket.error
                            SEQ
                              -- Assemble header
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.INSESSION.FIRSTCLC
                              []BYTE request.nct.id.array RETYPES request.nct.id:
                              [header FROM 1 FOR BYTESIN (INT)] := request.nct.id.array
                              []BYTE chan.id.array RETYPES chan.id:
                              [header FROM (1 + BYTESIN (INT)) FOR BYTESIN (INT)] := chan.id.array
                              []BYTE di.nlcs.first.array RETYPES di.nlcs.first:
                              [header FROM (1 + (2 * BYTESIN (INT))) FOR BYTESIN (INT)] := di.nlcs.first.array
                              []BYTE cte.nlcs.first.array RETYPES cte.nlcs.first:
                              [header FROM (1 + (3 * BYTESIN (INT))) FOR BYTESIN (INT)] := cte.nlcs.first.array
                              []BYTE has.rest.clcs.array RETYPES has.rest.clcs:
                              [header FROM (1 + (4 * BYTESIN (INT))) FOR BYTESIN (BOOL)] := has.rest.clcs.array
                              #IF DEFINED (BENCHMARK.PINGPONGTIME)
                              --{{{  Return ack straight to CTB-handler
                              SHARED PONY.INT.CTBMAINHANDLE! ctb.main.handle:
                              SEQ
                                -- Get CTB-main-handle from CTB-manager
                                CLAIM ctb.mgr.handle
                                  SEQ
                                    --{{{  OUT message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.main.handle; "
                                            int.msg.handle[to.handler] ! msg.int; request.nct.id
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    -- Carrying: NCT-ID
                                    ctb.mgr.handle[to.mgr] ! get.ctb.main.handle; request.nct.id
                                    -- Get reply
                                    -- Carrying: CTB-main-handle
                                    ctb.mgr.handle[from.mgr] ? CASE get.ctb.main.handle.confirm;
                                                                    ctb.main.handle
                                    --{{{  IN message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.main.handle.confirm; [cli-end]"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                -- Pass message on to CTB-handler
                                CLAIM ctb.main.handle
                                  SEQ
                                    --{{{  OUT message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": OUT ctbmainh "
                                            int.msg.handle[to.handler] ! msg.int; request.nct.id
                                            int.msg.handle[to.handler] ! msg.str; " [to.handler]: ack; "
                                            int.msg.handle[to.handler] ! msg.int; chan.id
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    -- Carrying: channel-ID of the relevant channel
                                    ctb.main.handle[to.handler] ! ack; chan.id
                              --}}}
                              #ELSE
                              -- Send message to remote node
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write message"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     addr.array, size.array,
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                              #ENDIF
                          --}}}
                          TRUE
                            SKIP
                    --}}}
                    --{{{  In session (not possible for dummy link-handler): remaining CLCs of a ULC
                    INT request.nct.id, chan.id, di.nlcs.rest, cte.nlcs.rest:
                    MOBILE []INT addr.array, size.array:
                    -- Carrying: NCT-ID of the CTB-handler making the request;
                    --           channel-ID of the relevant channel;
                    --           number of data-item NLCs in remaining CLCs;
                    --           number of channel-type-end NLCs in remaining CLCs;
                    --           address-array;
                    --           size-array
                    insession.rest.clcs; request.nct.id; chan.id;
                                         di.nlcs.rest; cte.nlcs.rest;
                                         addr.array; size.array
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: insession.rest.clcs; "
                                int.msg.handle[to.handler] ! msg.int; request.nct.id
                                int.msg.handle[to.handler] ! msg.str; "; "
                                int.msg.handle[to.handler] ! msg.int; chan.id
                                int.msg.handle[to.handler] ! msg.str; "; "
                                int.msg.handle[to.handler] ! msg.int; di.nlcs.rest
                                int.msg.handle[to.handler] ! msg.str; "; "
                                int.msg.handle[to.handler] ! msg.int; cte.nlcs.rest
                                int.msg.handle[to.handler] ! msg.str; "; [array ("
                                int.msg.handle[to.handler] ! msg.int; SIZE addr.array
                                int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                                int.msg.handle[to.handler] ! msg.int; SIZE size.array
                                int.msg.handle[to.handler] ! msg.str; ")]"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        IF
                          --{{{  Previously error-free
                          NOT was.socket.error
                            SEQ
                              -- Assemble header
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.INSESSION.RESTCLCS
                              []BYTE request.nct.id.array RETYPES request.nct.id:
                              [header FROM 1 FOR BYTESIN (INT)] := request.nct.id.array
                              []BYTE chan.id.array RETYPES chan.id:
                              [header FROM (1 + BYTESIN (INT)) FOR BYTESIN (INT)] := chan.id.array
                              []BYTE di.nlcs.rest.array RETYPES di.nlcs.rest:
                              [header FROM (1 + (2 * BYTESIN (INT))) FOR BYTESIN (INT)] := di.nlcs.rest.array
                              []BYTE cte.nlcs.rest.array RETYPES cte.nlcs.rest:
                              [header FROM (1 + (3 * BYTESIN (INT))) FOR BYTESIN (INT)] := cte.nlcs.rest.array
                              #IF DEFINED (BENCHMARK.PINGPONGTIME)
                              --{{{  Return ack straight to CTB-handler
                              SHARED PONY.INT.CTBMAINHANDLE! ctb.main.handle:
                              SEQ
                                -- Get CTB-main-handle from CTB-manager
                                CLAIM ctb.mgr.handle
                                  SEQ
                                    --{{{  OUT message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.main.handle; "
                                            int.msg.handle[to.handler] ! msg.int; request.nct.id
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    -- Carrying: NCT-ID
                                    ctb.mgr.handle[to.mgr] ! get.ctb.main.handle; request.nct.id
                                    -- Get reply
                                    -- Carrying: CTB-main-handle
                                    ctb.mgr.handle[from.mgr] ? CASE get.ctb.main.handle.confirm;
                                                                    ctb.main.handle
                                    --{{{  IN message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.main.handle.confirm; [cli-end]"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                -- Pass message on to CTB-handler
                                CLAIM ctb.main.handle
                                  SEQ
                                    --{{{  OUT message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": OUT ctbmainh "
                                            int.msg.handle[to.handler] ! msg.int; request.nct.id
                                            int.msg.handle[to.handler] ! msg.str; " [to.handler]: ack; "
                                            int.msg.handle[to.handler] ! msg.int; chan.id
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    -- Carrying: channel-ID of the relevant channel
                                    ctb.main.handle[to.handler] ! ack; chan.id
                              --}}}
                              #ELSE
                              -- Send message to remote node
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write message"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     addr.array, size.array,
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                              #ENDIF
                          --}}}
                          TRUE
                            SKIP
                    --}}}
                    --{{{  In session (not possible for dummy link-handler): acknowledge CLC
                    INT request.nct.id, chan.id:
                    -- Carrying: NCT-ID of the CTB-handler making the request;
                    --           channel-ID of the relevant channel
                    insession.ack; request.nct.id; chan.id
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: insession.ack; "
                                int.msg.handle[to.handler] ! msg.int; request.nct.id
                                int.msg.handle[to.handler] ! msg.str; "; "
                                int.msg.handle[to.handler] ! msg.int; chan.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        IF
                          --{{{  Previously error-free
                          NOT was.socket.error
                            SEQ
                              -- Assemble header
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.INSESSION.ACK
                              []BYTE request.nct.id.array RETYPES request.nct.id:
                              [header FROM 1 FOR BYTESIN (INT)] := request.nct.id.array
                              []BYTE chan.id.array RETYPES chan.id:
                              [header FROM (1 + BYTESIN (INT)) FOR BYTESIN (INT)] := chan.id.array
                              -- Send message to remote node
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write message"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     null.int.array, null.int.array,
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                          --}}}
                          TRUE
                            SKIP
                    --}}}
                    --{{{  In session (not possible for dummy link-handler): cancel CLC
                    INT request.nct.id, chan.id:
                    -- Carrying: NCT-ID of the CTB-handler making the request;
                    --           channel-ID of the relevant channel
                    insession.cancel; request.nct.id; chan.id
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: insession.cancel; "
                                int.msg.handle[to.handler] ! msg.int; request.nct.id
                                int.msg.handle[to.handler] ! msg.str; "; "
                                int.msg.handle[to.handler] ! msg.int; chan.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        IF
                          --{{{  Previously error-free
                          NOT was.socket.error
                            SEQ
                              -- Assemble header
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.INSESSION.CANCEL
                              []BYTE request.nct.id.array RETYPES request.nct.id:
                              [header FROM 1 FOR BYTESIN (INT)] := request.nct.id.array
                              []BYTE chan.id.array RETYPES chan.id:
                              [header FROM (1 + BYTESIN (INT)) FOR BYTESIN (INT)] := chan.id.array
                              -- Send message to remote node
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write message"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     null.int.array, null.int.array,
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                          --}}}
                          TRUE
                            SKIP
                    --}}}
                    --{{{  In session (not possible for dummy link-handler): close session
                    INT request.nct.id:
                    -- Carrying: NCT-ID of the CTB-handler making the request
                    insession.close.session; request.nct.id
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: insession.close.session; "
                                int.msg.handle[to.handler] ! msg.int; request.nct.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        IF
                          --{{{  Previously error-free
                          NOT was.socket.error
                            SEQ
                              -- Assemble header
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.INSESSION.CLOSESESSION
                              []BYTE request.nct.id.array RETYPES request.nct.id:
                              [header FROM 1 FOR BYTESIN (INT)] := request.nct.id.array
                              -- Send message to remote node
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write message"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     null.int.array, null.int.array,
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                          --}}}
                          TRUE
                            SKIP
                    --}}}
                    --{{{  In session (not possible for dummy link-handler): suspend session
                    INT request.nct.id:
                    -- Carrying: NCT-ID of the CTB-handler making the request
                    insession.suspend.session; request.nct.id
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: insession.suspend.session; "
                                int.msg.handle[to.handler] ! msg.int; request.nct.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        IF
                          --{{{  Previously error-free
                          NOT was.socket.error
                            SEQ
                              -- Assemble header
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.INSESSION.SUSPENDSESSION
                              []BYTE request.nct.id.array RETYPES request.nct.id:
                              [header FROM 1 FOR BYTESIN (INT)] := request.nct.id.array
                              -- Send message to remote node
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write message"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     null.int.array, null.int.array,
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                          --}}}
                          TRUE
                            SKIP
                    --}}}
                    --{{{  In session (not possible for dummy link-handler): confirm `suspend.session'
                    INT request.nct.id:
                    -- Carrying: NCT-ID of the CTB-handler making the request
                    insession.suspend.session.confirm; request.nct.id
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: insession.suspend.session.confirm; "
                                int.msg.handle[to.handler] ! msg.int; request.nct.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        IF
                          --{{{  Previously error-free
                          NOT was.socket.error
                            SEQ
                              -- Assemble header
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.INSESSION.SUSPENDSESSIONCONFIRM
                              []BYTE request.nct.id.array RETYPES request.nct.id:
                              [header FROM 1 FOR BYTESIN (INT)] := request.nct.id.array
                              -- Send message to remote node
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write message"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     null.int.array, null.int.array,
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                          --}}}
                          TRUE
                            SKIP
                    --}}}
                    --{{{  Shutdown (only possible for slave or for dummy link-handler)
                    shutdown
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                int.msg.handle[to.handler] ! msg.int; remote.node.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkh: shutdown"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        got.shutdown.from.mgr := TRUE
                        IF
                          --{{{  Already got remote shutdown (TRUE by default for dummy link-handler)
                          got.remote.shutdown
                            SEQ
                              running := FALSE
                              --{{{  Close socket if error-free (not for dummy link-handler)
                              IF
                                (own.node.id <> 0) AND (NOT was.socket.error)
                                  SEQ
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                              --}}}
                          --}}}
                          --{{{  No remote shutdown yet, send shutdown to remote node now
                          NOT was.socket.error
                            SEQ
                              -- Send shutdown message to remote node
                              header[0] := PONYC.INT.TCPIP.LINKHEADER.SHUTDOWN
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                      int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write `shutdown*'"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                              pony.int.tcpip.socket.fullwrite.multi (write.socket, header,
                                                                     null.int.array, null.int.array,
                                                                     sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    was.socket.error := TRUE
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                                            int.msg.handle[to.handler] ! msg.str; ": SOCKET: Write operation failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := (own.node.id = 0) OR (remote.node.id = 0)
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := remote.node.id
                                          err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; remote.node.id
                                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.close (write.socket)
                                TRUE
                                  SKIP
                          TRUE
                            SKIP
                          --}}}
                    --}}}
              --}}}
              --{{{  Get last signal from chain on dummy link-handler
              IF
                (own.node.id = 0) AND (remote.node.id = 0)
                  SEQ
                    BOOL any:
                    last.chain.handle.svr[ready] ? any
                    --{{{  IN message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                            int.msg.handle[to.handler] ! msg.int; remote.node.id
                            int.msg.handle[to.handler] ! msg.str; ": IN last.chainh: [any-int]"
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                TRUE
                  SKIP
              --}}}
      --{{{  Send shutdown confirm message to link-manager
      CLAIM link.mgr.handle
        SEQ
          --{{{  OUT message
          IF
            output.msgs
              CLAIM int.msg.handle
                SEQ
                  int.msg.handle[to.handler] ! msg.str; "link.hdlr "
                  int.msg.handle[to.handler] ! msg.int; remote.node.id
                  int.msg.handle[to.handler] ! msg.str; ": OUT linkmgrh: link.handler.shutdown; "
                  int.msg.handle[to.handler] ! msg.int; remote.node.id
                  int.msg.handle[to.handler] ! msg.end; FALSE
            TRUE
              SKIP
          --}}}
          -- Carrying: remote node-ID of the link-handler
          link.mgr.handle[to.mgr] ! link.handler.shutdown; remote.node.id
      --}}}
    --}}}
:
--}}}
--{{{  PROC pony.int.link.mgr.tcpip
-- Parameters: own.node.id         | VAL: own node-ID
--             ans.ip              | VAL: IP address of ANS
--                                          (only relevant for master)
--             ans.port            | VAL: port number of ANS
--                                          (only relevant for master)
--             app.index           | VAL: application-index in ANS
--                                          (only relevant for master)
--             app.code            | VAL: application-code in ANS
--                                          (only relevant for master)
--             listen.socket       | VAL: own listening socket
--             master.socket       | VAL: socket to master
--                                     (only relevant for slaves)
--             link.mgr.handle.svr | server-end of link-manager-handle
--             link.mgr.handle     | link-manager-handle (client-end)
--             ctb.mgr.handle      | CTB-manager-handle (client-end)
--             nct.mgr.handle      | NCT-manager-handle (client-end)
--             kernel.reply.handle | kernel-reply-handle (client-end)
--             output.errs         | VAL: output errors?
--             int.err.handle      | internal error-handle (client-end)
--             msg.type            | VAL: message-type
--             int.msg.handle      | internal message-handle (client-end)
PROC pony.int.link.mgr.tcpip (VAL INT own.node.id, ans.ip, ans.port,
                                      app.index, app.code,
                              VAL SOCKET listen.socket, master.socket,
                              PONY.INT.LINKMGRHANDLE? link.mgr.handle.svr,
                              SHARED PONY.INT.LINKMGRHANDLE! link.mgr.handle,
                              SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle,
                              SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle,
                              SHARED PONY.INT.KERNELREPLYHANDLE! kernel.reply.handle,
                              VAL BOOL output.errs,
                              SHARED PONY.INT.ERRHANDLE! int.err.handle,
                              VAL INT msg.type,
                              SHARED PONY.INT.MSGHANDLE! int.msg.handle)
  VAL BOOL output.msgs IS ((msg.type = PONYC.MSGTYPE.STATUS) OR (msg.type = PONYC.MSGTYPE.STATUSERR)):
  VAL BOOL output.err.msgs IS ((msg.type = PONYC.MSGTYPE.ERR) OR (msg.type = PONYC.MSGTYPE.STATUSERR)):
  --{{{  DATA TYPE LINK.DATA
  DATA TYPE LINK.DATA
    RECORD
      -- Link-state
      INT state:
      -- Location of remote node
      --   (only relevant for master, or for slave if link is not yet active
      --   and if own node-ID > remote node-ID)
      INT ip, port:
  :
  --}}}
  --{{{  Constants
  -- Link-states
  VAL INT LINKSTATE.NONE IS 0:
  VAL INT LINKSTATE.ACTIVE IS 1:
  VAL INT LINKSTATE.PENDING IS 2:
  --}}}
  --{{{  Arrays and variables
  -- Link-data-array
  INITIAL MOBILE []LINK.DATA link.data.array IS MOBILE [500]LINK.DATA:
  -- Link-handle-array
  INITIAL MOBILE []SHARED PONY.INT.LINKHANDLE! link.handle.array IS MOBILE [500]SHARED PONY.INT.LINKHANDLE!:
  -- Link-handle-server-array (used for pending links)
  INITIAL MOBILE []PONY.INT.LINKHANDLE? link.handle.svr.array IS MOBILE [500]PONY.INT.LINKHANDLE?:
  -- Next free index in link-arrays (only relevant for master)
  INITIAL INT next.link.index IS 1:
  -- Shutting down?
  INITIAL BOOL shutting.down IS FALSE:
  -- Number of active links (relevant during shutdown)
  INITIAL INT num.active.links IS 1:
  -- Number of slave requests
  --   (only relevant for master (during shutdown))
  INITIAL INT num.slave.reqs IS 0:
  -- Target number of slave requests
  --   (only relevant for master (during shutdown))
  INT target.num.slave.reqs:
  -- Get listening socket from parameters
  INITIAL SOCKET listen.socket IS listen.socket:
  -- TCP/IP link-manager-handle
  SHARED PONY.INT.LINKMGRHANDLE.TCPIP! link.mgr.handle.tcpip:
  -- TCP/IP link-manager-handle server-end
  PONY.INT.LINKMGRHANDLE.TCPIP? link.mgr.handle.tcpip.svr:
  --}}}
  --{{{  Channels
  CHAN INT new.link, new.node.id:
  CHAN SOCKET new.socket:
  CHAN BYTE new.link.reply:
  CHAN BOOL new.link.error, stop.acceptor:
  --}}}
  PAR
    --{{{  Acceptor
    INITIAL BOOL running IS TRUE:
    WHILE running
      INITIAL BOOL got.socket.during.kill IS FALSE:
      SOCKET socket:
      INT sock.result:
      SEQ
        --{{{  Accept incoming connection or stop signal
        CHAN BOOL kill:
        CHAN INT kill.response:
        PAR
          socket.altable.accept (kill, kill.response, listen.socket, socket, sock.result)
          PRI ALT
            --{{{  accept has terminated
            INT n:
            kill.response ? n
              kill ! TRUE
            --}}}
            --{{{  Get stop signal
            BOOL any:
            stop.acceptor ? any
              INT kill.result:
              SEQ
                running := FALSE
                -- Kill accept
                kill ! TRUE
                kill.response ? kill.result
                CASE kill.result
                  -- `BX.sl.accept' has terminated normally
                  1, 2
                    got.socket.during.kill := TRUE
                  ELSE
                    SKIP
            --}}}
        --}}}
        IF
          --{{{  Stop signal was received
          NOT running
            SEQ
              -- Close listening socket
              --{{{  SOCKET message
              IF
                output.msgs
                  CLAIM int.msg.handle
                    SEQ
                      int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close listening socket"
                      int.msg.handle[to.handler] ! msg.end; FALSE
                TRUE
                  SKIP
              --}}}
              socket.close (listen.socket)
              -- Send dummy `new.link' as confirmation
              new.link ! -1
              IF
                got.socket.during.kill
                  IF
                    sock.result = (-1)
                      SEQ
                        --{{{  SOCKET error message
                        IF
                          output.err.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Accepting new connection failed"
                                int.msg.handle[to.handler] ! msg.end; TRUE
                          TRUE
                            SKIP
                        --}}}
                        --{{{  Send error to error-handler
                        IF
                          output.errs
                            PONY.ERROR err:
                            SEQ
                              err[ans.concerned] := FALSE
                              err[master.concerned] := (own.node.id = 0)
                              err[remote.node.concerned] := TRUE
                              err[remote.node.id] := -1
                              err[err.code] := PONYC.ERRCODE.TCPIP.ACCEPTFAILURE
                              CLAIM int.err.handle
                                SEQ
                                  --{{{  OUT message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "link.mgr: OUT int.errh: report.err; ["
                                          int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                          int.msg.handle[to.handler] ! msg.str; ", "
                                          int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                          int.msg.handle[to.handler] ! msg.str; ", "
                                          int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                          int.msg.handle[to.handler] ! msg.str; ", "
                                          int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                          int.msg.handle[to.handler] ! msg.str; ", "
                                          int.msg.handle[to.handler] ! msg.int; err[err.code]
                                          int.msg.handle[to.handler] ! msg.str; "]"
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                                  -- Carrying: error
                                  int.err.handle[to.handler] ! report.err; err
                          TRUE
                            SKIP
                        --}}}
                    TRUE
                      SEQ
                        --{{{  SOCKET message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: New socket accepted"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        --{{{  Reply `shutting down' if this node is the master
                        IF
                          own.node.id = 0
                            SEQ
                              -- Force immediate socket writes
                              --{{{  SOCKET message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Set no-delay option"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              socket.setsockopt (socket, SOL.TCP, TCP.NODELAY, OPTION.ON, sock.result)
                              IF
                                sock.result = (-1)
                                  SEQ
                                    --{{{  SOCKET error message
                                    IF
                                      output.err.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Setting no-delay option failed"
                                            int.msg.handle[to.handler] ! msg.end; TRUE
                                      TRUE
                                        SKIP
                                    --}}}
                                    --{{{  Send error to error-handler
                                    IF
                                      output.errs
                                        PONY.ERROR err:
                                        SEQ
                                          err[ans.concerned] := FALSE
                                          err[master.concerned] := TRUE
                                          err[remote.node.concerned] := TRUE
                                          err[remote.node.id] := -1
                                          err[err.code] := PONYC.ERRCODE.TCPIP.SETNODELAYFAILURE
                                          CLAIM int.err.handle
                                            SEQ
                                              --{{{  OUT message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.mgr: OUT int.errh: report.err; ["
                                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                      int.msg.handle[to.handler] ! msg.str; ", "
                                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                      int.msg.handle[to.handler] ! msg.str; "]"
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              -- Carrying: error
                                              int.err.handle[to.handler] ! report.err; err
                                      TRUE
                                        SKIP
                                    --}}}
                                --{{{  No-delay successfully set, can start operation
                                TRUE
                                  INITIAL MOBILE []BYTE header IS MOBILE [2 * BYTESIN (INT)]BYTE:
                                  SEQ
                                    -- Get location of remote node
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Read remote location"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    socket.fullread (socket, header, SIZE header, sock.result)
                                    IF
                                      sock.result <> (SIZE header)
                                        SEQ
                                          --{{{  SOCKET error message
                                          IF
                                            output.err.msgs
                                              CLAIM int.msg.handle
                                                SEQ
                                                  int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Read operation failed"
                                                  int.msg.handle[to.handler] ! msg.end; TRUE
                                            TRUE
                                              SKIP
                                          --}}}
                                          --{{{  Send error to error-handler
                                          IF
                                            output.errs
                                              PONY.ERROR err:
                                              SEQ
                                                err[ans.concerned] := FALSE
                                                err[master.concerned] := TRUE
                                                err[remote.node.concerned] := TRUE
                                                err[remote.node.id] := -1
                                                err[err.code] := PONYC.ERRCODE.TCPIP.READFAILURE
                                                CLAIM int.err.handle
                                                  SEQ
                                                    --{{{  OUT message
                                                    IF
                                                      output.msgs
                                                        CLAIM int.msg.handle
                                                          SEQ
                                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: OUT int.errh: report.err; ["
                                                            int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                            int.msg.handle[to.handler] ! msg.str; ", "
                                                            int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                            int.msg.handle[to.handler] ! msg.str; ", "
                                                            int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                            int.msg.handle[to.handler] ! msg.str; ", "
                                                            int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                            int.msg.handle[to.handler] ! msg.str; ", "
                                                            int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                            int.msg.handle[to.handler] ! msg.str; "]"
                                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                                      TRUE
                                                        SKIP
                                                    --}}}
                                                    -- Carrying: error
                                                    int.err.handle[to.handler] ! report.err; err
                                            TRUE
                                              SKIP
                                          --}}}
                                      --{{{  Message received successfully
                                      TRUE
                                        INITIAL [BYTESIN (INT)]BYTE node.ip.array IS [header FOR BYTESIN (INT)]:
                                        INT node.ip RETYPES node.ip.array:
                                        INITIAL [BYTESIN (INT)]BYTE node.port.array IS [header FROM BYTESIN (INT) FOR BYTESIN (INT)]:
                                        INT node.port RETYPES node.port.array:
                                        SEQ
                                          --{{{  SOCKET message
                                          IF
                                            output.msgs
                                              CLAIM int.msg.handle
                                                SEQ
                                                  int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Remote location is "
                                                  int.msg.handle[to.handler] ! msg.hex; node.ip
                                                  int.msg.handle[to.handler] ! msg.str; "/"
                                                  int.msg.handle[to.handler] ! msg.int; node.port
                                                  int.msg.handle[to.handler] ! msg.end; FALSE
                                            TRUE
                                              SKIP
                                          --}}}
                                          -- Allocate header
                                          header := MOBILE [1 + BYTESIN (INT)]BYTE
                                          header[0] := PONYC.INT.TCPIP.MASTERHEADER.SHUTTINGDOWN
                                          -- Send reply to remote node
                                          --{{{  SOCKET message
                                          IF
                                            output.msgs
                                              CLAIM int.msg.handle
                                                SEQ
                                                  int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Write `shutting down*'"
                                                  int.msg.handle[to.handler] ! msg.end; FALSE
                                            TRUE
                                              SKIP
                                          --}}}
                                          socket.fullwrite (socket, header, sock.result)
                                          IF
                                            sock.result <> (SIZE header)
                                              SEQ
                                                --{{{  SOCKET error message
                                                IF
                                                  output.err.msgs
                                                    CLAIM int.msg.handle
                                                      SEQ
                                                        int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Write operation failed"
                                                        int.msg.handle[to.handler] ! msg.end; TRUE
                                                  TRUE
                                                    SKIP
                                                --}}}
                                                --{{{  Send error to error-handler
                                                IF
                                                  output.errs
                                                    PONY.ERROR err:
                                                    SEQ
                                                      err[ans.concerned] := FALSE
                                                      err[master.concerned] := TRUE
                                                      err[remote.node.concerned] := TRUE
                                                      err[remote.node.id] := -1
                                                      err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                                      CLAIM int.err.handle
                                                        SEQ
                                                          --{{{  OUT message
                                                          IF
                                                            output.msgs
                                                              CLAIM int.msg.handle
                                                                SEQ
                                                                  int.msg.handle[to.handler] ! msg.str; "link.mgr: OUT int.errh: report.err; ["
                                                                  int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                                  int.msg.handle[to.handler] ! msg.str; ", "
                                                                  int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                                  int.msg.handle[to.handler] ! msg.str; ", "
                                                                  int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                                  int.msg.handle[to.handler] ! msg.str; ", "
                                                                  int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                                  int.msg.handle[to.handler] ! msg.str; ", "
                                                                  int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                                  int.msg.handle[to.handler] ! msg.str; "]"
                                                                  int.msg.handle[to.handler] ! msg.end; FALSE
                                                            TRUE
                                                              SKIP
                                                          --}}}
                                                          -- Carrying: error
                                                          int.err.handle[to.handler] ! report.err; err
                                                  TRUE
                                                    SKIP
                                                --}}}
                                            TRUE
                                              SKIP
                                      --}}}
                                --}}}
                          TRUE
                            SKIP
                        --}}}
                        -- Close socket
                        --{{{  SOCKET message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        socket.close (socket)
                TRUE
                  SKIP
          --}}}
          --{{{  accept terminated, but error occured
          sock.result = (-1)
            SEQ
              --{{{  SOCKET error message
              IF
                output.err.msgs
                  CLAIM int.msg.handle
                    SEQ
                      int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Accepting new connection failed"
                      int.msg.handle[to.handler] ! msg.end; TRUE
                TRUE
                  SKIP
              --}}}
              --{{{  Send error to error-handler
              IF
                output.errs
                  PONY.ERROR err:
                  SEQ
                    err[ans.concerned] := FALSE
                    err[master.concerned] := (own.node.id = 0)
                    err[remote.node.concerned] := TRUE
                    err[remote.node.id] := -1
                    err[err.code] := PONYC.ERRCODE.TCPIP.ACCEPTFAILURE
                    CLAIM int.err.handle
                      SEQ
                        --{{{  OUT message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "link.mgr: OUT int.errh: report.err; ["
                                int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                int.msg.handle[to.handler] ! msg.str; ", "
                                int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                int.msg.handle[to.handler] ! msg.str; ", "
                                int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                int.msg.handle[to.handler] ! msg.str; ", "
                                int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                int.msg.handle[to.handler] ! msg.str; ", "
                                int.msg.handle[to.handler] ! msg.int; err[err.code]
                                int.msg.handle[to.handler] ! msg.str; "]"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        -- Carrying: error
                        int.err.handle[to.handler] ! report.err; err
                TRUE
                  SKIP
              --}}}
              running := FALSE
              -- Close listening socket
              --{{{  SOCKET message
              IF
                output.msgs
                  CLAIM int.msg.handle
                    SEQ
                      int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close listening socket"
                      int.msg.handle[to.handler] ! msg.end; FALSE
                TRUE
                  SKIP
              --}}}
              socket.close (listen.socket)
              -- Wait for stop signal
              BOOL any:
              stop.acceptor ? any
              -- Send dummy `new.link' as confirmation
              new.link ! -1
          --}}}
          --{{{  New socket is valid
          TRUE
            SEQ
              --{{{  SOCKET message
              IF
                output.msgs
                  CLAIM int.msg.handle
                    SEQ
                      int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: New socket accepted"
                      int.msg.handle[to.handler] ! msg.end; FALSE
                TRUE
                  SKIP
              --}}}
              -- Force immediate socket writes
              --{{{  SOCKET message
              IF
                output.msgs
                  CLAIM int.msg.handle
                    SEQ
                      int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Set no-delay option"
                      int.msg.handle[to.handler] ! msg.end; FALSE
                TRUE
                  SKIP
              --}}}
              socket.setsockopt (socket, SOL.TCP, TCP.NODELAY, OPTION.ON, sock.result)
              IF
                sock.result = (-1)
                  SEQ
                    --{{{  SOCKET error message
                    IF
                      output.err.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Setting no-delay option failed"
                            int.msg.handle[to.handler] ! msg.end; TRUE
                      TRUE
                        SKIP
                    --}}}
                    --{{{  Send error to error-handler
                    IF
                      output.errs
                        PONY.ERROR err:
                        SEQ
                          err[ans.concerned] := FALSE
                          err[master.concerned] := (own.node.id = 0)
                          err[remote.node.concerned] := TRUE
                          err[remote.node.id] := -1
                          err[err.code] := PONYC.ERRCODE.TCPIP.SETNODELAYFAILURE
                          CLAIM int.err.handle
                            SEQ
                              --{{{  OUT message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.mgr: OUT int.errh: report.err; ["
                                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                      int.msg.handle[to.handler] ! msg.str; ", "
                                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                      int.msg.handle[to.handler] ! msg.str; ", "
                                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                      int.msg.handle[to.handler] ! msg.str; ", "
                                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                      int.msg.handle[to.handler] ! msg.str; ", "
                                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                                      int.msg.handle[to.handler] ! msg.str; "]"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              -- Carrying: error
                              int.err.handle[to.handler] ! report.err; err
                      TRUE
                        SKIP
                    --}}}
                    --{{{  SOCKET message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                    socket.close (socket)
                --{{{  This node is the master
                own.node.id = 0
                  INITIAL MOBILE []BYTE header IS MOBILE [2 * BYTESIN (INT)]BYTE:
                  SEQ
                    -- Get location of remote node
                    --{{{  SOCKET message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Read remote location"
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                    socket.fullread (socket, header, SIZE header, sock.result)
                    IF
                      sock.result <> (SIZE header)
                        SEQ
                          --{{{  SOCKET error message
                          IF
                            output.err.msgs
                              CLAIM int.msg.handle
                                SEQ
                                  int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Read operation failed"
                                  int.msg.handle[to.handler] ! msg.end; TRUE
                            TRUE
                              SKIP
                          --}}}
                          --{{{  Send error to error-handler
                          IF
                            output.errs
                              PONY.ERROR err:
                              SEQ
                                err[ans.concerned] := FALSE
                                err[master.concerned] := TRUE
                                err[remote.node.concerned] := TRUE
                                err[remote.node.id] := -1
                                err[err.code] := PONYC.ERRCODE.TCPIP.READFAILURE
                                CLAIM int.err.handle
                                  SEQ
                                    --{{{  OUT message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: OUT int.errh: report.err; ["
                                            int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                            int.msg.handle[to.handler] ! msg.str; ", "
                                            int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                            int.msg.handle[to.handler] ! msg.str; ", "
                                            int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                            int.msg.handle[to.handler] ! msg.str; ", "
                                            int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                            int.msg.handle[to.handler] ! msg.str; ", "
                                            int.msg.handle[to.handler] ! msg.int; err[err.code]
                                            int.msg.handle[to.handler] ! msg.str; "]"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    -- Carrying: error
                                    int.err.handle[to.handler] ! report.err; err
                            TRUE
                              SKIP
                          --}}}
                          --{{{  SOCKET message
                          IF
                            output.msgs
                              CLAIM int.msg.handle
                                SEQ
                                  int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                  int.msg.handle[to.handler] ! msg.end; FALSE
                            TRUE
                              SKIP
                          --}}}
                          socket.close (socket)
                      --{{{  Message received successfully
                      TRUE
                        INITIAL [BYTESIN (INT)]BYTE node.ip.array IS [header FOR BYTESIN (INT)]:
                        INT node.ip RETYPES node.ip.array:
                        INITIAL [BYTESIN (INT)]BYTE node.port.array IS [header FROM BYTESIN (INT) FOR BYTESIN (INT)]:
                        INT node.port RETYPES node.port.array:
                        BOOL was.stopped:
                        SEQ
                          --{{{  SOCKET message
                          IF
                            output.msgs
                              CLAIM int.msg.handle
                                SEQ
                                  int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Remote location is "
                                  int.msg.handle[to.handler] ! msg.hex; node.ip
                                  int.msg.handle[to.handler] ! msg.str; "/"
                                  int.msg.handle[to.handler] ! msg.int; node.port
                                  int.msg.handle[to.handler] ! msg.end; FALSE
                            TRUE
                              SKIP
                          --}}}
                          --{{{  Try to output `node.ip'
                          CHAN BOOL stop.sync:
                          PAR
                            SEQ
                              new.link ! node.ip
                              stop.sync ! TRUE
                            BOOL any:
                            ALT
                              stop.acceptor ? any
                                SEQ
                                  stop.sync ? any
                                  was.stopped := TRUE
                              stop.sync ? any
                                was.stopped := FALSE
                          --}}}
                          IF
                            --{{{  Stop signal was received
                            was.stopped
                              SEQ
                                running := FALSE
                                -- Close listening socket
                                --{{{  SOCKET message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close listening socket"
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                                socket.close (listen.socket)
                                -- Allocate header
                                header := MOBILE [1 + BYTESIN (INT)]BYTE
                                header[0] := PONYC.INT.TCPIP.MASTERHEADER.SHUTTINGDOWN
                                -- Send reply to remote node
                                --{{{  SOCKET message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Write `shutting down*'"
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                                socket.fullwrite (socket, header, sock.result)
                                IF
                                  sock.result <> (SIZE header)
                                    SEQ
                                      --{{{  SOCKET error message
                                      IF
                                        output.err.msgs
                                          CLAIM int.msg.handle
                                            SEQ
                                              int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Write operation failed"
                                              int.msg.handle[to.handler] ! msg.end; TRUE
                                        TRUE
                                          SKIP
                                      --}}}
                                      --{{{  Send error to error-handler
                                      IF
                                        output.errs
                                          PONY.ERROR err:
                                          SEQ
                                            err[ans.concerned] := FALSE
                                            err[master.concerned] := TRUE
                                            err[remote.node.concerned] := TRUE
                                            err[remote.node.id] := -1
                                            err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                            CLAIM int.err.handle
                                              SEQ
                                                --{{{  OUT message
                                                IF
                                                  output.msgs
                                                    CLAIM int.msg.handle
                                                      SEQ
                                                        int.msg.handle[to.handler] ! msg.str; "link.mgr: OUT int.errh: report.err; ["
                                                        int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                        int.msg.handle[to.handler] ! msg.str; ", "
                                                        int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                        int.msg.handle[to.handler] ! msg.str; ", "
                                                        int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                        int.msg.handle[to.handler] ! msg.str; ", "
                                                        int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                        int.msg.handle[to.handler] ! msg.str; ", "
                                                        int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                        int.msg.handle[to.handler] ! msg.str; "]"
                                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                                  TRUE
                                                    SKIP
                                                --}}}
                                                -- Carrying: error
                                                int.err.handle[to.handler] ! report.err; err
                                        TRUE
                                          SKIP
                                      --}}}
                                  TRUE
                                    SKIP
                                -- Close socket
                                --{{{  SOCKET message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                                socket.close (socket)
                            --}}}
                            --{{{  No stop signal received
                            TRUE
                              INT node.id:
                              SEQ
                                new.link ! node.port
                                -- Allocate correct header size
                                header := MOBILE [1 + BYTESIN (INT)]BYTE
                                -- Get reply
                                new.link.reply ? header[0]
                                CASE header[0]
                                  PONYC.INT.TCPIP.MASTERHEADER.OK
                                    SEQ
                                      new.node.id ? node.id
                                      --{{{  SOCKET message
                                      IF
                                        output.msgs
                                          CLAIM int.msg.handle
                                            SEQ
                                              int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Write new node-ID: "
                                              int.msg.handle[to.handler] ! msg.int; node.id
                                              int.msg.handle[to.handler] ! msg.end; FALSE
                                        TRUE
                                          SKIP
                                      --}}}
                                      []BYTE node.id.array RETYPES node.id:
                                      [header FROM 1 FOR BYTESIN (INT)] := node.id.array
                                  PONYC.INT.TCPIP.MASTERHEADER.DUPLICATESLAVE
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Write `duplicate slave*'"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                  ELSE
                                    --{{{  SOCKET message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Write `shutting down*'"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                -- Send reply to remote node
                                socket.fullwrite (socket, header, sock.result)
                                IF
                                  sock.result <> (SIZE header)
                                    SEQ
                                      --{{{  SOCKET error message
                                      IF
                                        output.err.msgs
                                          CLAIM int.msg.handle
                                            SEQ
                                              int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Write operation failed"
                                              int.msg.handle[to.handler] ! msg.end; TRUE
                                        TRUE
                                          SKIP
                                      --}}}
                                      --{{{  Send error to error-handler
                                      IF
                                        output.errs
                                          PONY.ERROR err:
                                          SEQ
                                            err[ans.concerned] := FALSE
                                            err[master.concerned] := TRUE
                                            err[remote.node.concerned] := TRUE
                                            CASE header[0]
                                              PONYC.INT.TCPIP.MASTERHEADER.OK
                                                err[remote.node.id] := node.id
                                              ELSE
                                                err[remote.node.id] := -1
                                            err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                            CLAIM int.err.handle
                                              SEQ
                                                --{{{  OUT message
                                                IF
                                                  output.msgs
                                                    CLAIM int.msg.handle
                                                      SEQ
                                                        int.msg.handle[to.handler] ! msg.str; "link.mgr: OUT int.errh: report.err; ["
                                                        int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                        int.msg.handle[to.handler] ! msg.str; ", "
                                                        int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                        int.msg.handle[to.handler] ! msg.str; ", "
                                                        int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                        int.msg.handle[to.handler] ! msg.str; ", "
                                                        int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                        int.msg.handle[to.handler] ! msg.str; ", "
                                                        int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                        int.msg.handle[to.handler] ! msg.str; "]"
                                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                                  TRUE
                                                    SKIP
                                                --}}}
                                                -- Carrying: error
                                                int.err.handle[to.handler] ! report.err; err
                                        TRUE
                                          SKIP
                                      --}}}
                                      --{{{  SOCKET message
                                      IF
                                        output.msgs
                                          CLAIM int.msg.handle
                                            SEQ
                                              int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                              int.msg.handle[to.handler] ! msg.end; FALSE
                                        TRUE
                                          SKIP
                                      --}}}
                                      socket.close (socket)
                                      IF
                                        header[0] = PONYC.INT.TCPIP.MASTERHEADER.OK
                                          new.link.error ! TRUE
                                        TRUE
                                          SKIP
                                  header[0] = PONYC.INT.TCPIP.MASTERHEADER.OK
                                    new.socket ! socket
                                  TRUE
                                    SEQ
                                      --{{{  SOCKET message
                                      IF
                                        output.msgs
                                          CLAIM int.msg.handle
                                            SEQ
                                              int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                              int.msg.handle[to.handler] ! msg.end; FALSE
                                        TRUE
                                          SKIP
                                      --}}}
                                      socket.close (socket)
                            --}}}
                      --}}}
                --}}}
                --{{{  This node is a slave
                TRUE
                  INITIAL MOBILE []BYTE header IS MOBILE [BYTESIN (INT)]BYTE:
                  SEQ
                    -- Get remote node-ID
                    --{{{  SOCKET message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Read remote node-ID"
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                    socket.fullread (socket, header, SIZE header, sock.result)
                    IF
                      sock.result <> (SIZE header)
                        SEQ
                          --{{{  SOCKET error message
                          IF
                            output.err.msgs
                              CLAIM int.msg.handle
                                SEQ
                                  int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Read operation failed"
                                  int.msg.handle[to.handler] ! msg.end; TRUE
                            TRUE
                              SKIP
                          --}}}
                          --{{{  Send error to error-handler
                          IF
                            output.errs
                              PONY.ERROR err:
                              SEQ
                                err[ans.concerned] := FALSE
                                err[master.concerned] := FALSE
                                err[remote.node.concerned] := TRUE
                                err[remote.node.id] := -1
                                err[err.code] := PONYC.ERRCODE.TCPIP.READFAILURE
                                CLAIM int.err.handle
                                  SEQ
                                    --{{{  OUT message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: OUT int.errh: report.err; ["
                                            int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                            int.msg.handle[to.handler] ! msg.str; ", "
                                            int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                            int.msg.handle[to.handler] ! msg.str; ", "
                                            int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                            int.msg.handle[to.handler] ! msg.str; ", "
                                            int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                            int.msg.handle[to.handler] ! msg.str; ", "
                                            int.msg.handle[to.handler] ! msg.int; err[err.code]
                                            int.msg.handle[to.handler] ! msg.str; "]"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    -- Carrying: error
                                    int.err.handle[to.handler] ! report.err; err
                            TRUE
                              SKIP
                          --}}}
                          --{{{  SOCKET message
                          IF
                            output.msgs
                              CLAIM int.msg.handle
                                SEQ
                                  int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                  int.msg.handle[to.handler] ! msg.end; FALSE
                            TRUE
                              SKIP
                          --}}}
                          socket.close (socket)
                      --{{{  Message received successfully
                      TRUE
                        INITIAL [BYTESIN (INT)]BYTE node.id.array IS [header FOR BYTESIN (INT)]:
                        INT node.id RETYPES node.id.array:
                        BOOL was.stopped:
                        SEQ
                          --{{{  SOCKET message
                          IF
                            output.msgs
                              CLAIM int.msg.handle
                                SEQ
                                  int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Remote node-ID is "
                                  int.msg.handle[to.handler] ! msg.int; node.id
                                  int.msg.handle[to.handler] ! msg.end; FALSE
                            TRUE
                              SKIP
                          --}}}
                          --{{{  Try to output `node.id'
                          CHAN BOOL stop.sync:
                          PAR
                            SEQ
                              new.link ! node.id
                              stop.sync ! TRUE
                            BOOL any:
                            ALT
                              stop.acceptor ? any
                                SEQ
                                  stop.sync ? any
                                  was.stopped := TRUE
                              stop.sync ? any
                                was.stopped := FALSE
                          --}}}
                          IF
                            --{{{  Stop signal was received
                            was.stopped
                              SEQ
                                running := FALSE
                                -- Close listening socket
                                --{{{  SOCKET message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close listening socket"
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                                socket.close (listen.socket)
                                -- Close socket
                                --{{{  SOCKET message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                                socket.close (socket)
                            --}}}
                            --{{{  No stop signal received
                            TRUE
                              new.socket ! socket
                            --}}}
                      --}}}
                --}}}
          --}}}
    --}}}
    SEQ
      --{{{  Initialise link-data-array
      SEQ i = 0 FOR (SIZE link.data.array)
        link.data.array[i][state] := LINKSTATE.NONE
      --}}}
      --{{{  Allocate TCP/IP link-manager-handle
      link.mgr.handle.tcpip, link.mgr.handle.tcpip.svr := MOBILE PONY.INT.LINKMGRHANDLE.TCPIP
      --}}}
      --{{{  Fork off master-link-handler
      link.data.array[0][state] := LINKSTATE.ACTIVE
      link.handle.array[0], link.handle.svr.array[0] := MOBILE PONY.INT.LINKHANDLE
      --{{{  FORK message
      IF
        output.msgs
          CLAIM int.msg.handle
            SEQ
              int.msg.handle[to.handler] ! msg.str; "link.mgr: FORK link.hdlr ("
              int.msg.handle[to.handler] ! msg.int; own.node.id
              int.msg.handle[to.handler] ! msg.str; ", 0, [sock], [svr-end], [cli-end], [cli-end], [cli-end], [cli-end], [cli-end], "
              int.msg.handle[to.handler] ! msg.bool; output.errs
              int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
              int.msg.handle[to.handler] ! msg.bool; output.msgs
              int.msg.handle[to.handler] ! msg.str; ", [cli-end])"
              int.msg.handle[to.handler] ! msg.end; FALSE
        TRUE
          SKIP
      --}}}
      FORK pony.int.link.handler.tcpip (own.node.id, 0,
                                        master.socket, link.handle.svr.array[0],
                                        link.mgr.handle, link.mgr.handle.tcpip,
                                        ctb.mgr.handle, nct.mgr.handle,
                                        kernel.reply.handle,
                                        output.errs, int.err.handle,
                                        msg.type, int.msg.handle)
      --}}}
      INITIAL BOOL running IS TRUE:
      WHILE running
        ALT
          --{{{  Get new link from acceptor (on master node)
          INT node.ip, node.port:
          (own.node.id = 0) & new.link ? node.ip
            SEQ
              new.link ? node.port
              -- Update number of slave-requests
              num.slave.reqs := num.slave.reqs + 1
              IF
                shutting.down
                  SEQ
                    new.link.reply ! PONYC.INT.TCPIP.MASTERHEADER.SHUTTINGDOWN
                    --{{{  Stop acceptor if conditions are met
                    IF
                      (num.slave.reqs = target.num.slave.reqs)
                        SEQ
                          stop.acceptor ! TRUE
                          INT any:
                          new.link ? any
                      TRUE
                        SKIP
                    --}}}
                    --{{{  Shut down if conditions (master) are met
                    IF
                      (num.slave.reqs = target.num.slave.reqs) AND (num.active.links = 0)
                        SEQ
                          running := FALSE
                          -- Confirm shutdown
                          CLAIM kernel.reply.handle
                            SEQ
                              --{{{  OUT message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "link.mgr: OUT kernelreplyh: fromlinkmgr.shutdown.confirm"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              kernel.reply.handle[to.kernel] ! fromlinkmgr.shutdown.confirm
                      TRUE
                        SKIP
                    --}}}
                TRUE
                  INITIAL BOOL found.dup.loc IS FALSE:
                  SEQ
                    --{{{  Check for duplicate slave locations
                    INITIAL INT i IS 1:
                    WHILE (NOT found.dup.loc) AND (i < next.link.index)
                      SEQ
                        IF
                          (link.data.array[i][state] = LINKSTATE.ACTIVE) AND
                              ((node.ip = link.data.array[i][ip]) AND
                              (node.port = link.data.array[i][port]))
                            found.dup.loc := TRUE
                          TRUE
                            SKIP
                        i := i + 1
                    --}}}
                    IF
                      found.dup.loc
                        new.link.reply ! PONYC.INT.TCPIP.MASTERHEADER.DUPLICATESLAVE
                      TRUE
                        SEQ
                          new.link.reply ! PONYC.INT.TCPIP.MASTERHEADER.OK
                          new.node.id ! next.link.index
                          --{{{  Double size of arrays if necessary
                          IF
                            next.link.index = (SIZE link.data.array)
                              -- New arrays
                              INITIAL MOBILE []LINK.DATA new.link.data.array IS MOBILE [2 * next.link.index]LINK.DATA:
                              INITIAL MOBILE []SHARED PONY.INT.LINKHANDLE! new.link.handle.array IS MOBILE [2 * next.link.index]SHARED PONY.INT.LINKHANDLE!:
                              INITIAL MOBILE []PONY.INT.LINKHANDLE? new.link.handle.svr.array IS MOBILE [2 * next.link.index]PONY.INT.LINKHANDLE?:
                              SEQ
                                -- Set existing elements in new arrays
                                SEQ i = 0 FOR next.link.index
                                  IF
                                    link.data.array[i][state] = LINKSTATE.ACTIVE
                                      new.link.handle.array[i] := link.handle.array[i]
                                    TRUE
                                      SKIP
                                [new.link.data.array FOR next.link.index] := link.data.array
                                -- Initialise new fields of new link-data-array
                                SEQ i = next.link.index FOR next.link.index
                                  new.link.data.array[i][state] := LINKSTATE.NONE
                                -- Use new arrays
                                link.data.array := new.link.data.array
                                link.handle.array := new.link.handle.array
                                link.handle.svr.array := new.link.handle.svr.array
                            TRUE
                              SKIP
                          --}}}
                          -- Get reply
                          ALT
                            --{{{  Error
                            BOOL any:
                            new.link.error ? any
                              SEQ
                                -- Increase index just in case
                                next.link.index := next.link.index + 1
                            --}}}
                            --{{{  Get socket
                            SOCKET socket:
                            new.socket ? socket
                              SEQ
                                link.data.array[next.link.index][state] := LINKSTATE.ACTIVE
                                link.data.array[next.link.index][ip] := node.ip
                                link.data.array[next.link.index][port] := node.port
                                -- Fork off link-handler
                                link.handle.array[next.link.index], link.handle.svr.array[next.link.index] := MOBILE PONY.INT.LINKHANDLE
                                --{{{  FORK message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "link.mgr: FORK link.hdlr ("
                                        int.msg.handle[to.handler] ! msg.int; own.node.id
                                        int.msg.handle[to.handler] ! msg.str; ", "
                                        int.msg.handle[to.handler] ! msg.int; next.link.index
                                        int.msg.handle[to.handler] ! msg.str; ", [sock], [svr-end], [cli-end], [cli-end], [cli-end], [cli-end], [cli-end], "
                                        int.msg.handle[to.handler] ! msg.bool; output.errs
                                        int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                        int.msg.handle[to.handler] ! msg.bool; output.msgs
                                        int.msg.handle[to.handler] ! msg.str; ", [cli-end])"
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                                FORK pony.int.link.handler.tcpip (own.node.id, next.link.index,
                                                                  socket, link.handle.svr.array[next.link.index],
                                                                  link.mgr.handle, link.mgr.handle.tcpip,
                                                                  ctb.mgr.handle, nct.mgr.handle,
                                                                  kernel.reply.handle,
                                                                  output.errs, int.err.handle,
                                                                  msg.type, int.msg.handle)
                                -- Increase number of active links
                                num.active.links := num.active.links + 1
                                -- Increase index
                                next.link.index := next.link.index + 1
                            --}}}
          --}}}
          --{{{  Get new link from acceptor (on slave node)
          INT node.id:
          (own.node.id <> 0) & new.link ? node.id
            SOCKET socket:
            SEQ
              new.socket ? socket
              --{{{  Adapt size of arrays if necessary
              IF
                node.id >= (SIZE link.data.array)
                  INITIAL INT old.size IS SIZE link.data.array:
                  INITIAL INT new.size IS 2 * (SIZE link.data.array):
                  MOBILE []LINK.DATA new.link.data.array:
                  MOBILE []SHARED PONY.INT.LINKHANDLE! new.link.handle.array:
                  MOBILE []PONY.INT.LINKHANDLE? new.link.handle.svr.array:
                  SEQ
                    -- Double size until it fits
                    WHILE node.id >= new.size
                      new.size := 2 * new.size
                    -- Allocate new arrays
                    new.link.data.array := MOBILE [new.size]LINK.DATA
                    new.link.handle.array := MOBILE [new.size]SHARED PONY.INT.LINKHANDLE!
                    new.link.handle.svr.array := MOBILE [new.size]PONY.INT.LINKHANDLE?
                    -- Set existing elements in new arrays
                    SEQ i = 0 FOR old.size
                      SEQ
                        IF
                          link.data.array[i][state] <> LINKSTATE.NONE
                            new.link.handle.array[i] := link.handle.array[i]
                          TRUE
                            SKIP
                        IF
                          link.data.array[i][state] = LINKSTATE.PENDING
                            new.link.handle.svr.array[i] := link.handle.svr.array[i]
                          TRUE
                            SKIP
                    [new.link.data.array FOR old.size] := link.data.array
                    -- Initialise new fields of new link-data-array
                    SEQ i = old.size FOR (new.size - old.size)
                      new.link.data.array[i][state] := LINKSTATE.NONE
                    -- Use new arrays
                    link.data.array := new.link.data.array
                    link.handle.array := new.link.handle.array
                    link.handle.svr.array := new.link.handle.svr.array
                TRUE
                  SKIP
              --}}}
              -- Fork off link-handler
              IF
                link.data.array[node.id][state] <> LINKSTATE.PENDING
                  link.handle.array[node.id], link.handle.svr.array[node.id] := MOBILE PONY.INT.LINKHANDLE
                TRUE
                  SKIP
              --{{{  FORK message
              IF
                output.msgs
                  CLAIM int.msg.handle
                    SEQ
                      int.msg.handle[to.handler] ! msg.str; "link.mgr: FORK link.hdlr ("
                      int.msg.handle[to.handler] ! msg.int; own.node.id
                      int.msg.handle[to.handler] ! msg.str; ", "
                      int.msg.handle[to.handler] ! msg.int; node.id
                      int.msg.handle[to.handler] ! msg.str; ", [sock], [svr-end], [cli-end], [cli-end], [cli-end], [cli-end], [cli-end], "
                      int.msg.handle[to.handler] ! msg.bool; output.errs
                      int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                      int.msg.handle[to.handler] ! msg.bool; output.msgs
                      int.msg.handle[to.handler] ! msg.str; ", [cli-end])"
                      int.msg.handle[to.handler] ! msg.end; FALSE
                TRUE
                  SKIP
              --}}}
              FORK pony.int.link.handler.tcpip (own.node.id, node.id,
                                                socket, link.handle.svr.array[node.id],
                                                link.mgr.handle, link.mgr.handle.tcpip,
                                                ctb.mgr.handle, nct.mgr.handle,
                                                kernel.reply.handle,
                                                output.errs, int.err.handle,
                                                msg.type, int.msg.handle)
              link.data.array[node.id][state] := LINKSTATE.ACTIVE
              -- Increase number of active links
              num.active.links := num.active.links + 1
          --}}}
          link.mgr.handle.svr[to.mgr] ? CASE
            --{{{  Get link-handle for a given node-ID
            INT node.id:
            -- Carrying: node-ID
            get.link.handle; node.id
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "link.mgr: IN linkmgrh: get.link.handle; "
                        int.msg.handle[to.handler] ! msg.int; node.id
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                IF
                  --{{{  This node is the master
                  own.node.id = 0
                    SKIP
                  --}}}
                  --{{{  Slave, has been or will be contacted by remote node
                  own.node.id < node.id
                    SEQ
                      --{{{  Adapt size of arrays if necessary
                      IF
                        node.id >= (SIZE link.data.array)
                          INITIAL INT old.size IS SIZE link.data.array:
                          INITIAL INT new.size IS 2 * (SIZE link.data.array):
                          MOBILE []LINK.DATA new.link.data.array:
                          MOBILE []SHARED PONY.INT.LINKHANDLE! new.link.handle.array:
                          MOBILE []PONY.INT.LINKHANDLE? new.link.handle.svr.array:
                          SEQ
                            -- Double size until it fits
                            WHILE node.id >= new.size
                              new.size := 2 * new.size
                            -- Allocate new arrays
                            new.link.data.array := MOBILE [new.size]LINK.DATA
                            new.link.handle.array := MOBILE [new.size]SHARED PONY.INT.LINKHANDLE!
                            new.link.handle.svr.array := MOBILE [new.size]PONY.INT.LINKHANDLE?
                            -- Set existing elements in new arrays
                            SEQ i = 0 FOR old.size
                              SEQ
                                IF
                                  link.data.array[i][state] <> LINKSTATE.NONE
                                    new.link.handle.array[i] := link.handle.array[i]
                                  TRUE
                                    SKIP
                                IF
                                  link.data.array[i][state] = LINKSTATE.PENDING
                                    new.link.handle.svr.array[i] := link.handle.svr.array[i]
                                  TRUE
                                    SKIP
                            [new.link.data.array FOR old.size] := link.data.array
                            -- Initialise new fields of new link-data-array
                            SEQ i = old.size FOR (new.size - old.size)
                              new.link.data.array[i][state] := LINKSTATE.NONE
                            -- Use new arrays
                            link.data.array := new.link.data.array
                            link.handle.array := new.link.handle.array
                            link.handle.svr.array := new.link.handle.svr.array
                        TRUE
                          SKIP
                      --}}}
                      IF
                        link.data.array[node.id][state] = LINKSTATE.NONE
                          SEQ
                            link.data.array[node.id][state] := LINKSTATE.PENDING
                            -- Allocate link-handle
                            link.handle.array[node.id], link.handle.svr.array[node.id] := MOBILE PONY.INT.LINKHANDLE
                        TRUE
                          SKIP
                  --}}}
                  --{{{  Slave, must contact remote node now
                  link.data.array[node.id][state] = LINKSTATE.NONE
                    SOCKET socket:
                    INT sock.result:
                    SEQ
                      -- Allocate link-handle
                      link.handle.array[node.id], link.handle.svr.array[node.id] := MOBILE PONY.INT.LINKHANDLE
                      -- Connact to remote node
                      --{{{  SOCKET message
                      IF
                        output.msgs
                          CLAIM int.msg.handle
                            SEQ
                              int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Connect to remote node at location "
                              int.msg.handle[to.handler] ! msg.hex; link.data.array[node.id][ip]
                              int.msg.handle[to.handler] ! msg.str; "/"
                              int.msg.handle[to.handler] ! msg.int; link.data.array[node.id][port]
                              int.msg.handle[to.handler] ! msg.end; FALSE
                        TRUE
                          SKIP
                      --}}}
                      socket.create.connect.tcp (socket,
                                                 link.data.array[node.id][ip],
                                                 link.data.array[node.id][port],
                                                 sock.result)
                      IF
                        sock.result = (-1)
                          SEQ
                            --{{{  SOCKET error message
                            IF
                              output.err.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Could not connect to remote node"
                                    int.msg.handle[to.handler] ! msg.end; TRUE
                              TRUE
                                SKIP
                            --}}}
                            --{{{  Send error to error-handler
                            IF
                              output.errs
                                PONY.ERROR err:
                                SEQ
                                  err[ans.concerned] := FALSE
                                  err[master.concerned] := FALSE
                                  err[remote.node.concerned] := TRUE
                                  err[remote.node.id] := node.id
                                  err[err.code] := PONYC.ERRCODE.TCPIP.CONNECTFAILURE
                                  CLAIM int.err.handle
                                    SEQ
                                      --{{{  OUT message
                                      IF
                                        output.msgs
                                          CLAIM int.msg.handle
                                            SEQ
                                              int.msg.handle[to.handler] ! msg.str; "link.mgr: OUT int.errh: report.err; ["
                                              int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                              int.msg.handle[to.handler] ! msg.str; ", "
                                              int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                              int.msg.handle[to.handler] ! msg.str; ", "
                                              int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                              int.msg.handle[to.handler] ! msg.str; ", "
                                              int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                              int.msg.handle[to.handler] ! msg.str; ", "
                                              int.msg.handle[to.handler] ! msg.int; err[err.code]
                                              int.msg.handle[to.handler] ! msg.str; "]"
                                              int.msg.handle[to.handler] ! msg.end; FALSE
                                        TRUE
                                          SKIP
                                      --}}}
                                      -- Carrying: error
                                      int.err.handle[to.handler] ! report.err; err
                              TRUE
                                SKIP
                            --}}}
                        --{{{  Could connect to remote node
                        TRUE
                          SEQ
                            -- Force immediate socket writes
                            --{{{  SOCKET message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Set no-delay option"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            socket.setsockopt (socket, SOL.TCP, TCP.NODELAY, OPTION.ON, sock.result)
                            IF
                              sock.result = (-1)
                                SEQ
                                  --{{{  SOCKET error message
                                  IF
                                    output.err.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Setting no-delay option failed"
                                          int.msg.handle[to.handler] ! msg.end; TRUE
                                    TRUE
                                      SKIP
                                  --}}}
                                  --{{{  Send error to error-handler
                                  IF
                                    output.errs
                                      PONY.ERROR err:
                                      SEQ
                                        err[ans.concerned] := FALSE
                                        err[master.concerned] := FALSE
                                        err[remote.node.concerned] := TRUE
                                        err[remote.node.id] := node.id
                                        err[err.code] := PONYC.ERRCODE.TCPIP.SETNODELAYFAILURE
                                        CLAIM int.err.handle
                                          SEQ
                                            --{{{  OUT message
                                            IF
                                              output.msgs
                                                CLAIM int.msg.handle
                                                  SEQ
                                                    int.msg.handle[to.handler] ! msg.str; "link.mgr: OUT int.errh: report.err; ["
                                                    int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                    int.msg.handle[to.handler] ! msg.str; ", "
                                                    int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                    int.msg.handle[to.handler] ! msg.str; ", "
                                                    int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                    int.msg.handle[to.handler] ! msg.str; ", "
                                                    int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                    int.msg.handle[to.handler] ! msg.str; ", "
                                                    int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                    int.msg.handle[to.handler] ! msg.str; "]"
                                                    int.msg.handle[to.handler] ! msg.end; FALSE
                                              TRUE
                                                SKIP
                                            --}}}
                                            -- Carrying: error
                                            int.err.handle[to.handler] ! report.err; err
                                    TRUE
                                      SKIP
                                  --}}}
                                  --{{{  SOCKET message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                                  socket.close (socket)
                              --{{{  No-delay successfully set, can start operation
                              TRUE
                                INITIAL MOBILE []BYTE header IS MOBILE [BYTESIN (INT)]BYTE:
                                SEQ
                                  INITIAL INT h.own.node.id IS own.node.id:
                                  []BYTE own.node.id.array RETYPES h.own.node.id:
                                  [header FOR BYTESIN (INT)] := own.node.id.array
                                  -- Send own node-ID
                                  --{{{  SOCKET message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Write own node-ID: "
                                          int.msg.handle[to.handler] ! msg.int; own.node.id
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                                  socket.fullwrite (socket, header, sock.result)
                                  IF
                                    sock.result <> (SIZE header)
                                      SEQ
                                        --{{{  SOCKET error message
                                        IF
                                          output.err.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Write operation failed"
                                                int.msg.handle[to.handler] ! msg.end; TRUE
                                          TRUE
                                            SKIP
                                        --}}}
                                        --{{{  Send error to error-handler
                                        IF
                                          output.errs
                                            PONY.ERROR err:
                                            SEQ
                                              err[ans.concerned] := FALSE
                                              err[master.concerned] := FALSE
                                              err[remote.node.concerned] := TRUE
                                              err[remote.node.id] := node.id
                                              err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                              CLAIM int.err.handle
                                                SEQ
                                                  --{{{  OUT message
                                                  IF
                                                    output.msgs
                                                      CLAIM int.msg.handle
                                                        SEQ
                                                          int.msg.handle[to.handler] ! msg.str; "link.mgr: OUT int.errh: report.err; ["
                                                          int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                          int.msg.handle[to.handler] ! msg.str; ", "
                                                          int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                          int.msg.handle[to.handler] ! msg.str; ", "
                                                          int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                          int.msg.handle[to.handler] ! msg.str; ", "
                                                          int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                          int.msg.handle[to.handler] ! msg.str; ", "
                                                          int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                          int.msg.handle[to.handler] ! msg.str; "]"
                                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                                    TRUE
                                                      SKIP
                                                  --}}}
                                                  -- Carrying: error
                                                  int.err.handle[to.handler] ! report.err; err
                                          TRUE
                                            SKIP
                                        --}}}
                                        --{{{  SOCKET message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close socket"
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        socket.close (socket)
                                    --{{{  Request sent successfully
                                    TRUE
                                      SEQ
                                        --{{{  FORK message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "link.mgr: FORK link.hdlr ("
                                                int.msg.handle[to.handler] ! msg.int; own.node.id
                                                int.msg.handle[to.handler] ! msg.str; ", "
                                                int.msg.handle[to.handler] ! msg.int; node.id
                                                int.msg.handle[to.handler] ! msg.str; ", [sock], [svr-end], [cli-end], [cli-end], [cli-end], [cli-end], [cli-end], "
                                                int.msg.handle[to.handler] ! msg.bool; output.errs
                                                int.msg.handle[to.handler] ! msg.str; ", [cli-end], "
                                                int.msg.handle[to.handler] ! msg.bool; output.msgs
                                                int.msg.handle[to.handler] ! msg.str; ", [cli-end])"
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        FORK pony.int.link.handler.tcpip (own.node.id, node.id,
                                                                          socket, link.handle.svr.array[node.id],
                                                                          link.mgr.handle, link.mgr.handle.tcpip,
                                                                          ctb.mgr.handle, nct.mgr.handle,
                                                                          kernel.reply.handle,
                                                                          output.errs, int.err.handle,
                                                                          msg.type, int.msg.handle)
                                        link.data.array[node.id][state] := LINKSTATE.ACTIVE
                                        -- Increase number of active links
                                        num.active.links := num.active.links + 1
                                    --}}}
                              --}}}
                        --}}}
                  --}}}
                  TRUE
                    SKIP
                -- Return handle
                --{{{  OUT message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "link.mgr: OUT linkmgrh: get.link.handle.confirm; [cli-end]"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                -- Carrying: link-handle
                link.mgr.handle.svr[from.mgr] ! get.link.handle.confirm; link.handle.array[node.id]
            --}}}
            --{{{  A link-handler was shut down
            INT remote.node.id:
            -- Carrying: remote node-ID of the link-handler
            link.handler.shutdown; remote.node.id
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "link.mgr: IN linkmgrh: link.handler.shutdown; "
                        int.msg.handle[to.handler] ! msg.int; remote.node.id
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                -- Update state
                link.data.array[remote.node.id][state] := LINKSTATE.NONE
                -- Decrease number of active links
                num.active.links := num.active.links - 1
                --{{{  Shut down if conditions are met
                IF
                  shutting.down AND
                      (((own.node.id <> 0) OR (num.slave.reqs = target.num.slave.reqs)) AND
                      (num.active.links = 0))
                    SEQ
                      running := FALSE
                      -- Confirm shutdown
                      CLAIM kernel.reply.handle
                        SEQ
                          --{{{  OUT message
                          IF
                            output.msgs
                              CLAIM int.msg.handle
                                SEQ
                                  int.msg.handle[to.handler] ! msg.str; "link.mgr: OUT kernelreplyh: fromlinkmgr.shutdown.confirm"
                                  int.msg.handle[to.handler] ! msg.end; FALSE
                            TRUE
                              SKIP
                          --}}}
                          kernel.reply.handle[to.kernel] ! fromlinkmgr.shutdown.confirm
                  TRUE
                    SKIP
                --}}}
            --}}}
            --{{{  Shutdown
            shutdown
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "link.mgr: IN linkmgrh: shutdown"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                shutting.down := TRUE
                IF
                  --{{{  This node is the master
                  own.node.id = 0
                    SOCKET ans.socket:
                    INT sock.result:
                    SEQ
                      --{{{  Notify ANS and get `target.num.slave.reqs'
                      -- Set target to current value in case connection to ANS fails
                      target.num.slave.reqs := num.slave.reqs
                      -- Connect to ANS
                      --{{{  SOCKET message
                      IF
                        output.msgs
                          CLAIM int.msg.handle
                            SEQ
                              int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Connect to ANS"
                              int.msg.handle[to.handler] ! msg.end; FALSE
                        TRUE
                          SKIP
                      --}}}
                      socket.create.connect.tcp (ans.socket, ans.ip, ans.port, sock.result)
                      IF
                        sock.result = (-1)
                          SEQ
                            --{{{  SOCKET error message
                            IF
                              output.err.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Could not connect to ANS"
                                    int.msg.handle[to.handler] ! msg.end; TRUE
                              TRUE
                                SKIP
                            --}}}
                            --{{{  Send error to error-handler
                            IF
                              output.errs
                                PONY.ERROR err:
                                SEQ
                                  err[ans.concerned] := TRUE
                                  err[master.concerned] := TRUE
                                  err[remote.node.concerned] := FALSE
                                  err[remote.node.id] := -1
                                  err[err.code] := PONYC.ERRCODE.TCPIP.CONNECTFAILURE
                                  CLAIM int.err.handle
                                    SEQ
                                      --{{{  OUT message
                                      IF
                                        output.msgs
                                          CLAIM int.msg.handle
                                            SEQ
                                              int.msg.handle[to.handler] ! msg.str; "link.mgr: OUT int.errh: report.err; ["
                                              int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                              int.msg.handle[to.handler] ! msg.str; ", "
                                              int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                              int.msg.handle[to.handler] ! msg.str; ", "
                                              int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                              int.msg.handle[to.handler] ! msg.str; ", "
                                              int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                              int.msg.handle[to.handler] ! msg.str; ", "
                                              int.msg.handle[to.handler] ! msg.int; err[err.code]
                                              int.msg.handle[to.handler] ! msg.str; "]"
                                              int.msg.handle[to.handler] ! msg.end; FALSE
                                        TRUE
                                          SKIP
                                      --}}}
                                      -- Carrying: error
                                      int.err.handle[to.handler] ! report.err; err
                              TRUE
                                SKIP
                            --}}}
                        --{{{  Could connect to ANS
                        TRUE
                          SEQ
                            -- Force immediate socket writes
                            --{{{  SOCKET message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Set no-delay option on ANS-socket"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            socket.setsockopt (ans.socket, SOL.TCP, TCP.NODELAY, OPTION.ON, sock.result)
                            IF
                              sock.result = (-1)
                                SEQ
                                  --{{{  SOCKET error message
                                  IF
                                    output.err.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Setting no-delay option failed"
                                          int.msg.handle[to.handler] ! msg.end; TRUE
                                    TRUE
                                      SKIP
                                  --}}}
                                  --{{{  Send error to error-handler
                                  IF
                                    output.errs
                                      PONY.ERROR err:
                                      SEQ
                                        err[ans.concerned] := TRUE
                                        err[master.concerned] := TRUE
                                        err[remote.node.concerned] := FALSE
                                        err[remote.node.id] := -1
                                        err[err.code] := PONYC.ERRCODE.TCPIP.SETNODELAYFAILURE
                                        CLAIM int.err.handle
                                          SEQ
                                            --{{{  OUT message
                                            IF
                                              output.msgs
                                                CLAIM int.msg.handle
                                                  SEQ
                                                    int.msg.handle[to.handler] ! msg.str; "link.mgr: OUT int.errh: report.err; ["
                                                    int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                    int.msg.handle[to.handler] ! msg.str; ", "
                                                    int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                    int.msg.handle[to.handler] ! msg.str; ", "
                                                    int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                    int.msg.handle[to.handler] ! msg.str; ", "
                                                    int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                    int.msg.handle[to.handler] ! msg.str; ", "
                                                    int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                    int.msg.handle[to.handler] ! msg.str; "]"
                                                    int.msg.handle[to.handler] ! msg.end; FALSE
                                              TRUE
                                                SKIP
                                            --}}}
                                            -- Carrying: error
                                            int.err.handle[to.handler] ! report.err; err
                                    TRUE
                                      SKIP
                                  --}}}
                              --{{{  No-delay successfully set, can start operation
                              TRUE
                                INITIAL MOBILE []BYTE header IS MOBILE [1 + (4 * BYTESIN (INT))]BYTE:
                                SEQ
                                  -- Assemble header
                                  header[0] := PONYC.INT.TCPIP.ANSHEADER.MASTERSHUTDOWN
                                  INITIAL INT h.app.index IS app.index:
                                  []BYTE app.index.array RETYPES h.app.index:
                                  [header FROM 1 FOR BYTESIN (INT)] := app.index.array
                                  INITIAL INT h.app.code IS app.code:
                                  []BYTE app.code.array RETYPES h.app.code:
                                  [header FROM (1 + BYTESIN (INT)) FOR BYTESIN (INT)] := app.code.array
                                  -- Send request
                                  --{{{  SOCKET message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Write `master shutdown*' to ANS-socket"
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                                  INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                                  pony.int.tcpip.socket.fullwrite.multi (ans.socket, header,
                                                                         null.int.array, null.int.array,
                                                                         sock.result)
                                  IF
                                    sock.result = (-1)
                                      SEQ
                                        --{{{  SOCKET error message
                                        IF
                                          output.err.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Write operation failed"
                                                int.msg.handle[to.handler] ! msg.end; TRUE
                                          TRUE
                                            SKIP
                                        --}}}
                                        --{{{  Send error to error-handler
                                        IF
                                          output.errs
                                            PONY.ERROR err:
                                            SEQ
                                              err[ans.concerned] := TRUE
                                              err[master.concerned] := TRUE
                                              err[remote.node.concerned] := FALSE
                                              err[remote.node.id] := -1
                                              err[err.code] := PONYC.ERRCODE.TCPIP.WRITEFAILURE
                                              CLAIM int.err.handle
                                                SEQ
                                                  --{{{  OUT message
                                                  IF
                                                    output.msgs
                                                      CLAIM int.msg.handle
                                                        SEQ
                                                          int.msg.handle[to.handler] ! msg.str; "link.mgr: OUT int.errh: report.err; ["
                                                          int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                          int.msg.handle[to.handler] ! msg.str; ", "
                                                          int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                          int.msg.handle[to.handler] ! msg.str; ", "
                                                          int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                          int.msg.handle[to.handler] ! msg.str; ", "
                                                          int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                          int.msg.handle[to.handler] ! msg.str; ", "
                                                          int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                          int.msg.handle[to.handler] ! msg.str; "]"
                                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                                    TRUE
                                                      SKIP
                                                  --}}}
                                                  -- Carrying: error
                                                  int.err.handle[to.handler] ! report.err; err
                                          TRUE
                                            SKIP
                                        --}}}
                                    --{{{  Request sent successfully
                                    TRUE
                                      SEQ
                                        -- Allocate correct header size
                                        header := MOBILE [BYTESIN (INT)]BYTE
                                        -- Get reply from ANS
                                        --{{{  SOCKET message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Read number of slave requests from ANS-socket"
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        socket.fullread (ans.socket, header, SIZE header, sock.result)
                                        IF
                                          sock.result <> (SIZE header)
                                            SEQ
                                              --{{{  SOCKET error message
                                              IF
                                                output.err.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Read operation failed"
                                                      int.msg.handle[to.handler] ! msg.end; TRUE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              --{{{  Send error to error-handler
                                              IF
                                                output.errs
                                                  PONY.ERROR err:
                                                  SEQ
                                                    err[ans.concerned] := TRUE
                                                    err[master.concerned] := TRUE
                                                    err[remote.node.concerned] := FALSE
                                                    err[remote.node.id] := -1
                                                    err[err.code] := PONYC.ERRCODE.TCPIP.READFAILURE
                                                    CLAIM int.err.handle
                                                      SEQ
                                                        --{{{  OUT message
                                                        IF
                                                          output.msgs
                                                            CLAIM int.msg.handle
                                                              SEQ
                                                                int.msg.handle[to.handler] ! msg.str; "link.mgr: OUT int.errh: report.err; ["
                                                                int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                                                                int.msg.handle[to.handler] ! msg.str; ", "
                                                                int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                                                                int.msg.handle[to.handler] ! msg.str; ", "
                                                                int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                                                                int.msg.handle[to.handler] ! msg.str; ", "
                                                                int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                                                                int.msg.handle[to.handler] ! msg.str; ", "
                                                                int.msg.handle[to.handler] ! msg.int; err[err.code]
                                                                int.msg.handle[to.handler] ! msg.str; "]"
                                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                                          TRUE
                                                            SKIP
                                                        --}}}
                                                        -- Carrying: error
                                                        int.err.handle[to.handler] ! report.err; err
                                                TRUE
                                                  SKIP
                                              --}}}
                                          TRUE
                                            SEQ
                                              INITIAL [BYTESIN (INT)]BYTE target.num.slave.reqs.array IS [header FOR BYTESIN (INT)]:
                                              INT h.target.num.slave.reqs RETYPES target.num.slave.reqs.array:
                                              target.num.slave.reqs := h.target.num.slave.reqs
                                              IF
                                                target.num.slave.reqs = (-1)
                                                  SEQ
                                                    --{{{  SOCKET message
                                                    IF
                                                      output.msgs
                                                        CLAIM int.msg.handle
                                                          SEQ
                                                            int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: ANS returned `invalid application-code*' error"
                                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                                      TRUE
                                                        SKIP
                                                    --}}}
                                                    -- Set target to current value
                                                    target.num.slave.reqs := num.slave.reqs
                                                TRUE
                                                  --{{{  SOCKET message
                                                  IF
                                                    output.msgs
                                                      CLAIM int.msg.handle
                                                        SEQ
                                                          int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Number of slave requests is "
                                                          int.msg.handle[to.handler] ! msg.int; target.num.slave.reqs
                                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                                    TRUE
                                                      SKIP
                                                  --}}}
                                    --}}}
                              --}}}
                            -- Close ANS-socket
                            --{{{  SOCKET message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "link.mgr: SOCKET: Close ANS-socket"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            socket.close (ans.socket)
                        --}}}
                      --}}}
                      --{{{  Stop acceptor if conditions are met
                      IF
                        (num.slave.reqs = target.num.slave.reqs)
                          SEQ
                            stop.acceptor ! TRUE
                            INT any:
                            new.link ? any
                        TRUE
                          SKIP
                      --}}}
                      -- Send shutdown signal to dummy link-handler
                      CLAIM link.handle.array[0]
                        SEQ
                          --{{{  OUT message
                          IF
                            output.msgs
                              CLAIM int.msg.handle
                                SEQ
                                  int.msg.handle[to.handler] ! msg.str; "link.mgr: OUT linkh 0: shutdown"
                                  int.msg.handle[to.handler] ! msg.end; FALSE
                            TRUE
                              SKIP
                          --}}}
                          link.handle.array[0][to.handler] ! shutdown
                  --}}}
                  --{{{  This node is a slave
                  TRUE
                    SEQ
                      -- Stop acceptor
                      stop.acceptor ! TRUE
                      INT any:
                      new.link ? any
                      -- Send shutdown signal to all active link-handlers
                      SEQ i = 0 FOR (SIZE link.data.array)
                        IF
                          link.data.array[i][state] = LINKSTATE.ACTIVE
                            CLAIM link.handle.array[i]
                              SEQ
                                --{{{  OUT message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "link.mgr: OUT linkh "
                                        int.msg.handle[to.handler] ! msg.int; i
                                        int.msg.handle[to.handler] ! msg.str; ": shutdown"
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                                link.handle.array[i][to.handler] ! shutdown
                          TRUE
                            SKIP
                  --}}}
            --}}}
          link.mgr.handle.tcpip.svr[to.mgr] ? CASE
            --{{{  Get network-location (only possible on master node)
            INT node.id:
            -- Carrying: node-ID
            get.location; node.id
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "link.mgr: IN linkmgrh.tcpip: get.location; "
                        int.msg.handle[to.handler] ! msg.int; node.id
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                -- Return location
                --{{{  OUT message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "link.mgr: OUT linkmgrh.tcpip: get.location.confirm; "
                        int.msg.handle[to.handler] ! msg.hex; link.data.array[node.id][ip]
                        int.msg.handle[to.handler] ! msg.str; "; "
                        int.msg.handle[to.handler] ! msg.int; link.data.array[node.id][port]
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                -- Carrying: IP address;
                --           port number
                link.mgr.handle.tcpip.svr[from.mgr] ! get.location.confirm;
                                                      link.data.array[node.id][ip];
                                                      link.data.array[node.id][port]
            --}}}
            --{{{  Store network-location (only possible on slave node)
            INT node.id, ip, port:
            -- Carrying: node-ID;
            --           IP address;
            --           port number
            store.location; node.id; ip; port
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "link.mgr: IN linkmgrh.tcpip: store.location; "
                        int.msg.handle[to.handler] ! msg.int; node.id
                        int.msg.handle[to.handler] ! msg.str; "; "
                        int.msg.handle[to.handler] ! msg.hex; ip
                        int.msg.handle[to.handler] ! msg.str; "; "
                        int.msg.handle[to.handler] ! msg.int; port
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                --{{{  Adapt size of arrays if necessary
                IF
                  node.id >= (SIZE link.data.array)
                    INITIAL INT old.size IS SIZE link.data.array:
                    INITIAL INT new.size IS 2 * (SIZE link.data.array):
                    MOBILE []LINK.DATA new.link.data.array:
                    MOBILE []SHARED PONY.INT.LINKHANDLE! new.link.handle.array:
                    MOBILE []PONY.INT.LINKHANDLE? new.link.handle.svr.array:
                    SEQ
                      -- Double size until it fits
                      WHILE node.id >= new.size
                        new.size := 2 * new.size
                      -- Allocate new arrays
                      new.link.data.array := MOBILE [new.size]LINK.DATA
                      new.link.handle.array := MOBILE [new.size]SHARED PONY.INT.LINKHANDLE!
                      new.link.handle.svr.array := MOBILE [new.size]PONY.INT.LINKHANDLE?
                      -- Set existing elements in new arrays
                      SEQ i = 0 FOR old.size
                        SEQ
                          IF
                            link.data.array[i][state] <> LINKSTATE.NONE
                              new.link.handle.array[i] := link.handle.array[i]
                            TRUE
                              SKIP
                          IF
                            link.data.array[i][state] = LINKSTATE.PENDING
                              new.link.handle.svr.array[i] := link.handle.svr.array[i]
                            TRUE
                              SKIP
                      [new.link.data.array FOR old.size] := link.data.array
                      -- Initialise new fields of new link-data-array
                      SEQ i = old.size FOR (new.size - old.size)
                        new.link.data.array[i][state] := LINKSTATE.NONE
                      -- Use new arrays
                      link.data.array := new.link.data.array
                      link.handle.array := new.link.handle.array
                      link.handle.svr.array := new.link.handle.svr.array
                  TRUE
                    SKIP
                --}}}
                link.data.array[node.id][ip] := ip
                link.data.array[node.id][port] := port
            --}}}
:
--}}}

--}}}

