-- Copyright: Mario Schweigler (C) 2005-2006
-- Institution: Computing Laboratory, University of Kent, Canterbury, UK
-- Description: pony internal code file 1

-- This program is free software; you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 2 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program; if not, write to the Free Software
-- Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
-- MA 02110-1301, USA.

--{{{  Compiler declarations
#INCLUDE "ponylib.inc"
#INCLUDE "ponyint.inc"
#USE "ponyintaux.tce"
--}}}

--{{{  Processes

--{{{  PROC pony.int.err.handler
-- Error-handler
-- Parameters: initial.err.point  | VAL: initial error-point?
--             err.handle.svr     | server-end of error-handle
--             int.err.handle.svr | server-end of internal error-handle
--             ctb.mgr.handle     | CTB-manager-handle (client-end)
--             msg.type           | VAL: message-type
--             int.msg.handle     | internal message-handle (client-end)
PROC pony.int.err.handler (VAL BOOL initial.err.point,
                           PONY.ERRHANDLE? err.handle.svr,
                           PONY.INT.ERRHANDLE? int.err.handle.svr,
                           SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle,
                           VAL INT msg.type,
                           SHARED PONY.INT.MSGHANDLE! int.msg.handle)
  VAL BOOL output.msgs IS ((msg.type = PONYC.MSGTYPE.STATUS) OR (msg.type = PONYC.MSGTYPE.STATUSERR)):
  --{{{  DATA TYPE ERROR.DATA
  DATA TYPE ERROR.DATA
    RECORD
      PONY.ERROR err:
      INT num.err.points:
  :
  --}}}
  --{{{  Initialisations
  -- Array of error-data records
  INITIAL MOBILE []ERROR.DATA err.data.array IS MOBILE [500]ERROR.DATA:
  -- Index of the first element
  --   (if buffer empty, it equals `end.ptr')
  INITIAL INT start.ptr IS 0:
  -- Index of next element to be added
  --   ((end.ptr + (SIZE err.data.array)) - start.ptr) \ (SIZE err.data.array)
  --   is the number of elements stored in the buffer
  INITIAL INT end.ptr IS 0:
  -- Running number of the first element
  --   (if buffer empty, it equals `next.running.num')
  INITIAL INT first.running.num IS PONYC.INT.INITIALERRPOINT:
  -- Running number of the next element to be added
  INITIAL INT next.running.num IS PONYC.INT.INITIALERRPOINT:
  -- Number of pending error-points
  INT pending.err.points:
  -- Internal shutdown signal has been received
  INITIAL BOOL int.shutdown IS FALSE:
  -- External shutdown signal has been received
  INITIAL BOOL ext.shutdown IS FALSE:
  --}}}
  SEQ
    --{{{  Initialise `pending.err.points'
    IF
      initial.err.point
        pending.err.points := 1
      TRUE
        pending.err.points := 0
    --}}}
    INITIAL BOOL running IS TRUE:
    WHILE running
      ALT
        (NOT ext.shutdown) & err.handle.svr[to.handler] ? CASE
          --{{{  Get ID of current remote node for a given NCT
          INT nct.id:
          -- Carrying: NCT-ID
          get.current.remote.node; nct.id
            SHARED PONY.INT.CTBINSTANTHANDLE! ctb.instant.handle:
            INITIAL BOOL ctb.instant.handle.found IS FALSE:
            SEQ
              --{{{  IN message
              IF
                output.msgs
                  CLAIM int.msg.handle
                    SEQ
                      int.msg.handle[to.handler] ! msg.str; "err.hdlr: IN ext.errh: get.current.remote.node; "
                      int.msg.handle[to.handler] ! msg.int; nct.id
                      int.msg.handle[to.handler] ! msg.end; FALSE
                TRUE
                  SKIP
              --}}}
              -- Get CTB-instant-handle from CTB-manager
              CLAIM ctb.mgr.handle
                SEQ
                  --{{{  OUT message
                  IF
                    output.msgs
                      CLAIM int.msg.handle
                        SEQ
                          int.msg.handle[to.handler] ! msg.str; "err.hdlr: OUT ctbmgrh: get.ctb.instant.handle; "
                          int.msg.handle[to.handler] ! msg.int; nct.id
                          int.msg.handle[to.handler] ! msg.end; FALSE
                    TRUE
                      SKIP
                  --}}}
                  -- Carrying: NCT-ID
                  ctb.mgr.handle[to.mgr] ! get.ctb.instant.handle; nct.id
                  -- Get reply
                  ctb.mgr.handle[from.mgr] ? CASE
                    --{{{  Invalid NCT-ID
                    -- Carrying: NCT-ID
                    get.ctb.instant.handle.invalidnctid
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "err.hdlr: IN ctbmgrh: get.ctb.instant.handle.invalidnctid"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        --{{{  OUT message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "err.hdlr: OUT ext.errh: get.current.remote.node.confirm; -1; "
                                int.msg.handle[to.handler] ! msg.int; PONYC.RESULT.ERR.GCRN.INVALIDNCTID
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        -- Return error
                        -- Carrying: ID of remote node;
                        --           result
                        err.handle.svr[from.handler] ! get.current.remote.node.confirm;
                                                       -1; PONYC.RESULT.ERR.GCRN.INVALIDNCTID
                    --}}}
                    --{{{  NCT-ID was valid
                    -- Carrying: CTB-instant-handle
                    get.ctb.instant.handle.confirm; ctb.instant.handle
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "err.hdlr: IN ctbmgrh: get.ctb.instant.handle.confirm; [cli-end]"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        ctb.instant.handle.found := TRUE
                    --}}}
              IF
                ctb.instant.handle.found
                  CLAIM ctb.instant.handle
                    SEQ
                      -- Get current remote node
                      --{{{  OUT message
                      IF
                        output.msgs
                          CLAIM int.msg.handle
                            SEQ
                              int.msg.handle[to.handler] ! msg.str; "err.hdlr: OUT ctbinsth "
                              int.msg.handle[to.handler] ! msg.int; nct.id
                              int.msg.handle[to.handler] ! msg.str; ": get.current.remote.node"
                              int.msg.handle[to.handler] ! msg.end; FALSE
                        TRUE
                          SKIP
                      --}}}
                      ctb.instant.handle[to.handler] ! get.current.remote.node
                      -- Get reply
                      ctb.instant.handle[from.handler] ? CASE
                        --{{{  Currently no session
                        get.current.remote.node.nosession
                          SEQ
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "err.hdlr: IN ctbinsth "
                                    int.msg.handle[to.handler] ! msg.int; nct.id
                                    int.msg.handle[to.handler] ! msg.str; ": get.current.remote.node.nosession"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "err.hdlr: OUT ext.errh: get.current.remote.node.confirm; -1; "
                                    int.msg.handle[to.handler] ! msg.int; PONYC.RESULT.ERR.GCRN.NOSESSION
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Return error
                            -- Carrying: ID of remote node;
                            --           result
                            err.handle.svr[from.handler] ! get.current.remote.node.confirm;
                                                           -1; PONYC.RESULT.ERR.GCRN.NOSESSION
                        --}}}
                        --{{{  Both ends on same node
                        get.current.remote.node.samenode
                          SEQ
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "err.hdlr: IN ctbinsth "
                                    int.msg.handle[to.handler] ! msg.int; nct.id
                                    int.msg.handle[to.handler] ! msg.str; ": get.current.remote.node.samenode"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "err.hdlr: OUT ext.errh: get.current.remote.node.confirm; -1; "
                                    int.msg.handle[to.handler] ! msg.int; PONYC.RESULT.ERR.GCRN.SAMENODE
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Return error
                            -- Carrying: ID of remote node;
                            --           result
                            err.handle.svr[from.handler] ! get.current.remote.node.confirm;
                                                           -1; PONYC.RESULT.ERR.GCRN.SAMENODE
                        --}}}
                        --{{{  Session involving remote node
                        INT node.id:
                        -- Carrying: ID of remote node
                        get.current.remote.node.confirm; node.id
                          SEQ
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "err.hdlr: IN ctbinsth "
                                    int.msg.handle[to.handler] ! msg.int; nct.id
                                    int.msg.handle[to.handler] ! msg.str; ": get.current.remote.node.confirm; "
                                    int.msg.handle[to.handler] ! msg.int; node.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "err.hdlr: OUT ext.errh: get.current.remote.node.confirm; "
                                    int.msg.handle[to.handler] ! msg.int; node.id
                                    int.msg.handle[to.handler] ! msg.str; "; "
                                    int.msg.handle[to.handler] ! msg.int; PONYC.RESULT.ERR.GCRN.NOSESSION
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Return error
                            -- Carrying: ID of remote node;
                            --           result
                            err.handle.svr[from.handler] ! get.current.remote.node.confirm;
                                                           node.id; PONYC.RESULT.ERR.GCRN.OK
                        --}}}
                TRUE
                  SKIP
          --}}}
          --{{{  Get new error-point
          new.err.point
            SEQ
              --{{{  IN message
              IF
                output.msgs
                  CLAIM int.msg.handle
                    SEQ
                      int.msg.handle[to.handler] ! msg.str; "err.hdlr: IN ext.errh: new.err.point"
                      int.msg.handle[to.handler] ! msg.end; FALSE
                TRUE
                  SKIP
              --}}}
              pending.err.points := pending.err.points + 1
              --{{{  OUT message
              IF
                output.msgs
                  CLAIM int.msg.handle
                    SEQ
                      int.msg.handle[to.handler] ! msg.str; "err.hdlr: OUT ext.errh: new.err.point.confirm; "
                      int.msg.handle[to.handler] ! msg.int; next.running.num
                      int.msg.handle[to.handler] ! msg.end; FALSE
                TRUE
                  SKIP
              --}}}
              -- Return error-point
              -- Carrying: error-point
              err.handle.svr[from.handler] ! new.err.point.confirm; next.running.num
          --}}}
          --{{{  Delete error-point
          INT err.point:
          -- Carrying: error-point
          delete.err.point; err.point
            INITIAL INT rel.err.point IS ((err.point - first.running.num) + start.ptr) \ (SIZE err.data.array):
            SEQ
              --{{{  IN message
              IF
                output.msgs
                  CLAIM int.msg.handle
                    SEQ
                      int.msg.handle[to.handler] ! msg.str; "err.hdlr: IN ext.errh: delete.err.point; "
                      int.msg.handle[to.handler] ! msg.int; err.point
                      int.msg.handle[to.handler] ! msg.end; FALSE
                TRUE
                  SKIP
              --}}}
              IF
                --{{{  Error-point at `pending' position
                (err.point = next.running.num) AND (pending.err.points > 0)
                  SEQ
                    -- Delete error-point
                    pending.err.points := pending.err.points - 1
                    --{{{  OUT message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "err.hdlr: OUT ext.errh: delete.err.point.confirm; "
                            int.msg.handle[to.handler] ! msg.int; PONYC.RESULT.ERR.DEP.OK
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                    -- Return OK
                    -- Carrying: result
                    err.handle.svr[from.handler] ! delete.err.point.confirm; PONYC.RESULT.ERR.DEP.OK
                --}}}
                --{{{  Error-point out of range
                (err.point < first.running.num) OR (err.point >= next.running.num)
                  SEQ
                    --{{{  OUT message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "err.hdlr: OUT ext.errh: delete.err.point.confirm; "
                            int.msg.handle[to.handler] ! msg.int; PONYC.RESULT.ERR.DEP.INVALIDERRPOINT
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                    -- Return error
                    -- Carrying: result
                    err.handle.svr[from.handler] ! delete.err.point.confirm;
                                                   PONYC.RESULT.ERR.DEP.INVALIDERRPOINT
                --}}}
                --{{{  No error-point at given position
                err.data.array[rel.err.point][num.err.points] = 0
                  SEQ
                    --{{{  OUT message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "err.hdlr: OUT ext.errh: delete.err.point.confirm; "
                            int.msg.handle[to.handler] ! msg.int; PONYC.RESULT.ERR.DEP.INVALIDERRPOINT
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                    -- Return error
                    -- Carrying: result
                    err.handle.svr[from.handler] ! delete.err.point.confirm;
                                                   PONYC.RESULT.ERR.DEP.INVALIDERRPOINT
                --}}}
                --{{{  Else
                TRUE
                  SEQ
                    -- Delete error-point
                    err.data.array[rel.err.point][num.err.points] := err.data.array[rel.err.point][num.err.points] - 1
                    IF
                      -- Deleted error-point was at start of buffer and was the
                      --   last one there
                      (err.point = first.running.num) AND (err.data.array[rel.err.point][num.err.points] = 0)
                        --{{{  Move start of buffer to first element with error-point
                        INITIAL BOOL found IS FALSE:
                        -- Go through all elements in the buffer
                        SEQ i = rel.err.point FOR ((end.ptr + (SIZE err.data.array)) - rel.err.point) \ (SIZE err.data.array)
                          VAL i.mod.size IS i \ (SIZE err.data.array):
                          IF
                            (NOT found) AND (err.data.array[i.mod.size][num.err.points] = 0)
                              SEQ
                                start.ptr := (start.ptr + 1) \ (SIZE err.data.array)
                                first.running.num := first.running.num + 1
                            TRUE
                              found := TRUE
                        --}}}
                      TRUE
                        SKIP
                    --{{{  OUT message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "err.hdlr: OUT ext.errh: delete.err.point.confirm; "
                            int.msg.handle[to.handler] ! msg.int; PONYC.RESULT.ERR.DEP.OK
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                    -- Return OK
                    -- Carrying: result
                    err.handle.svr[from.handler] ! delete.err.point.confirm; PONYC.RESULT.ERR.DEP.OK
                --}}}
          --}}}
          --{{{  Get errors after a given error-point
          INT err.point:
          BOOL check.ans, check.master, check.all.nodes:
          MOBILE []INT nodes.to.check:
          -- Carrying: error-point;
          --           check ANS?;
          --           check master?;
          --           check all nodes?;
          --           array of nodes to check
          get.errs.after; err.point;
                          check.ans; check.master; check.all.nodes; nodes.to.check
            INITIAL INT rel.err.point IS ((err.point - first.running.num) + start.ptr) \ (SIZE err.data.array):
            INITIAL MOBILE []PONY.ERROR err.array IS MOBILE [0]PONY.ERROR:
            SEQ
              --{{{  IN message
              IF
                output.msgs
                  CLAIM int.msg.handle
                    SEQ
                      int.msg.handle[to.handler] ! msg.str; "err.hdlr: IN ext.errh: get.errs.after; "
                      int.msg.handle[to.handler] ! msg.int; err.point
                      int.msg.handle[to.handler] ! msg.str; "; "
                      int.msg.handle[to.handler] ! msg.bool; check.ans
                      int.msg.handle[to.handler] ! msg.str; "; "
                      int.msg.handle[to.handler] ! msg.bool; check.master
                      int.msg.handle[to.handler] ! msg.str; "; "
                      int.msg.handle[to.handler] ! msg.bool; check.all.nodes
                      int.msg.handle[to.handler] ! msg.str; "; [array ("
                      int.msg.handle[to.handler] ! msg.int; SIZE nodes.to.check
                      int.msg.handle[to.handler] ! msg.str; ")]"
                      int.msg.handle[to.handler] ! msg.end; FALSE
                TRUE
                  SKIP
              --}}}
              IF
                --{{{  Error-point at `pending' position
                (err.point = next.running.num) AND (pending.err.points > 0)
                  SEQ
                    --{{{  OUT message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "err.hdlr: OUT ext.errh: get.errs.after.confirm; [array (0)]; "
                            int.msg.handle[to.handler] ! msg.int; err.point
                            int.msg.handle[to.handler] ! msg.str; "; "
                            int.msg.handle[to.handler] ! msg.int; PONYC.RESULT.ERR.GEA.OK
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                    -- Return OK with empty array
                    -- Carrying: array of errors;
                    --           new error-point;
                    --           result
                    err.handle.svr[from.handler] ! get.errs.after.confirm;
                                                   err.array; err.point; PONYC.RESULT.ERR.GEA.OK
                --}}}
                --{{{  Error-point out of range
                (err.point < first.running.num) OR (err.point >= next.running.num)
                  SEQ
                    --{{{  OUT message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "err.hdlr: OUT ext.errh: get.errs.after.confirm; [array (0)]; "
                            int.msg.handle[to.handler] ! msg.int; err.point
                            int.msg.handle[to.handler] ! msg.str; "; "
                            int.msg.handle[to.handler] ! msg.int; PONYC.RESULT.ERR.GEA.INVALIDERRPOINT
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                    -- Return error
                    -- Carrying: result
                    err.handle.svr[from.handler] ! get.errs.after.confirm;
                                                   err.array; err.point; PONYC.RESULT.ERR.GEA.INVALIDERRPOINT
                --}}}
                --{{{  No error-point at given position
                err.data.array[rel.err.point][num.err.points] = 0
                  SEQ
                    --{{{  OUT message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "err.hdlr: OUT ext.errh: get.errs.after.confirm; [array (0)]; "
                            int.msg.handle[to.handler] ! msg.int; err.point
                            int.msg.handle[to.handler] ! msg.str; "; "
                            int.msg.handle[to.handler] ! msg.int; PONYC.RESULT.ERR.GEA.INVALIDERRPOINT
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                    -- Return error
                    -- Carrying: result
                    err.handle.svr[from.handler] ! get.errs.after.confirm;
                                                   err.array; err.point; PONYC.RESULT.ERR.GEA.INVALIDERRPOINT
                --}}}
                --{{{  Else
                TRUE
                  INITIAL INT num.errs.found IS 0:
                  SEQ
                    -- Initialise error array with maximum size
                    --   (i.e. number of elements starting at error-point)
                    err.array := MOBILE [((end.ptr + (SIZE err.data.array)) - rel.err.point) \ (SIZE err.data.array)]PONY.ERROR
                    -- Go through all elements in the buffer
                    SEQ i = rel.err.point FOR ((end.ptr + (SIZE err.data.array)) - rel.err.point) \ (SIZE err.data.array)
                      VAL i.mod.size IS i \ (SIZE err.data.array):
                      INITIAL BOOL match IS FALSE:
                      SEQ
                        --{{{  Look for match
                        match := match OR (check.ans AND
                          err.data.array[i.mod.size][err][ans.concerned])
                        match := match OR (check.master AND
                          err.data.array[i.mod.size][err][master.concerned])
                        match := match OR (check.all.nodes AND
                          err.data.array[i.mod.size][err][remote.node.concerned])
                        SEQ j = 0 FOR (SIZE nodes.to.check)
                          match := match OR
                            (err.data.array[i.mod.size][err][remote.node.concerned] AND
                            (nodes.to.check[j] = err.data.array[i.mod.size][err][remote.node.id]))
                        --}}}
                        IF
                          match
                            SEQ
                              err.array[num.errs.found] := err.data.array[i.mod.size][err]
                              num.errs.found := num.errs.found + 1
                          TRUE
                            SKIP
                    -- Shrink error array to `actual' size
                    INITIAL MOBILE []PONY.ERROR new.err.array IS MOBILE [num.errs.found]PONY.ERROR:
                    SEQ
                      [new.err.array FOR num.errs.found] := [err.array FOR num.errs.found]
                      err.array := new.err.array
                    --{{{  Delete error-point (just like for `delete.err.point')
                    err.data.array[rel.err.point][num.err.points] := err.data.array[rel.err.point][num.err.points] - 1
                    IF
                      -- Deleted error-point was at start of buffer and was the
                      --   last one there
                      (err.point = first.running.num) AND (err.data.array[rel.err.point][num.err.points] = 0)
                        --{{{  Move start of buffer to first element with error-point
                        INITIAL BOOL found IS FALSE:
                        -- Go through all elements in the buffer
                        SEQ i = rel.err.point FOR ((end.ptr + (SIZE err.data.array)) - rel.err.point) \ (SIZE err.data.array)
                          VAL i.mod.size IS i \ (SIZE err.data.array):
                          IF
                            (NOT found) AND (err.data.array[i.mod.size][num.err.points] = 0)
                              SEQ
                                start.ptr := (start.ptr + 1) \ (SIZE err.data.array)
                                first.running.num := first.running.num + 1
                            TRUE
                              found := TRUE
                        --}}}
                      TRUE
                        SKIP
                    --}}}
                    -- Add new pending error-point
                    pending.err.points := pending.err.points + 1
                    --{{{  OUT message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "err.hdlr: OUT ext.errh: get.errs.after.confirm; [array ("
                            int.msg.handle[to.handler] ! msg.int; SIZE err.array
                            int.msg.handle[to.handler] ! msg.str; ")]; "
                            int.msg.handle[to.handler] ! msg.int; next.running.num
                            int.msg.handle[to.handler] ! msg.str; "; "
                            int.msg.handle[to.handler] ! msg.int; PONYC.RESULT.ERR.GEA.OK
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                    -- Return array of errors
                    -- Carrying: array of errors;
                    --           new error-point;
                    --           result
                    err.handle.svr[from.handler] ! get.errs.after.confirm;
                                                   err.array; next.running.num; PONYC.RESULT.ERR.GEA.OK
                --}}}
          --}}}
          --{{{  External shutdown signal
          shutdown
            SEQ
              --{{{  IN message
              IF
                output.msgs
                  CLAIM int.msg.handle
                    SEQ
                      int.msg.handle[to.handler] ! msg.str; "err.hdlr: IN ext.errh: shutdown"
                      int.msg.handle[to.handler] ! msg.end; FALSE
                TRUE
                  SKIP
              --}}}
              IF
                int.shutdown
                  SEQ
                    -- Leave main loop
                    running := FALSE
                    --{{{  SHUTDOWN message
                    IF
                      msg.type <> (-1)
                        CLAIM int.msg.handle
                          SEQ
                            IF
                              output.msgs
                                SEQ
                                  int.msg.handle[to.handler] ! msg.str; "err.hdlr: OUT int.msgh: shutdown"
                                  int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            int.msg.handle[to.handler] ! shutdown
                      TRUE
                        SKIP
                    --}}}
                TRUE
                  ext.shutdown := TRUE
          --}}}
        (NOT int.shutdown) & int.err.handle.svr[to.handler] ? CASE
          --{{{  Report error
          PONY.ERROR err:
          -- Carrying: error
          report.err; err
            SEQ
              --{{{  IN message
              IF
                output.msgs
                  CLAIM int.msg.handle
                    SEQ
                      int.msg.handle[to.handler] ! msg.str; "err.hdlr: IN int.errh: report.err; ["
                      int.msg.handle[to.handler] ! msg.bool; err[ans.concerned]
                      int.msg.handle[to.handler] ! msg.str; ", "
                      int.msg.handle[to.handler] ! msg.bool; err[master.concerned]
                      int.msg.handle[to.handler] ! msg.str; ", "
                      int.msg.handle[to.handler] ! msg.bool; err[remote.node.concerned]
                      int.msg.handle[to.handler] ! msg.str; ", "
                      int.msg.handle[to.handler] ! msg.int; err[remote.node.id]
                      int.msg.handle[to.handler] ! msg.str; ", "
                      int.msg.handle[to.handler] ! msg.int; err[err.code]
                      int.msg.handle[to.handler] ! msg.str; "]"
                      int.msg.handle[to.handler] ! msg.end; FALSE
                TRUE
                  SKIP
              --}}}
              IF
                --{{{  External shutdown was received earlier
                ext.shutdown
                  -- Discard error
                  SKIP
                --}}}
                --{{{  Buffer empty and no pending error-points
                (end.ptr = start.ptr) AND (pending.err.points = 0)
                  -- Discard error
                  SKIP
                --}}}
                --{{{  Else
                TRUE
                  SEQ
                    --{{{  Double buffer size if buffer full
                    --       (full means there are ((SIZE err.data.array) - 1) elements)
                    IF
                      (((end.ptr + (SIZE err.data.array)) - start.ptr) \ (SIZE err.data.array)) = ((SIZE err.data.array) - 1)
                        -- New array
                        INITIAL MOBILE []ERROR.DATA new.err.data.array IS MOBILE [2 * (SIZE err.data.array)]ERROR.DATA:
                        SEQ
                          -- Copy elements into new array
                          IF
                            start.ptr = 0
                              [new.err.data.array FOR end.ptr] := [err.data.array FOR end.ptr]
                            TRUE
                              SEQ
                                [new.err.data.array FOR ((SIZE err.data.array) - start.ptr)] :=
                                  [err.data.array FROM start.ptr FOR ((SIZE err.data.array) - start.ptr)]
                                [new.err.data.array FROM ((SIZE err.data.array) - start.ptr) FOR end.ptr] :=
                                  [err.data.array FOR end.ptr]
                          -- Adapt pointers
                          start.ptr := 0
                          end.ptr := (SIZE err.data.array) - 1
                          -- Use new array
                          err.data.array := new.err.data.array
                      TRUE
                        SKIP
                    --}}}
                    -- Update buffer element
                    err.data.array[end.ptr][err] := err
                    err.data.array[end.ptr][num.err.points] := pending.err.points
                    -- Adapt counters
                    end.ptr := (end.ptr + 1) \ (SIZE err.data.array)
                    next.running.num := next.running.num + 1
                    -- Clear pending error-points
                    pending.err.points := 0
                --}}}
          --}}}
          --{{{  Internal shutdown signal
          shutdown
            SEQ
              --{{{  IN message
              IF
                output.msgs
                  CLAIM int.msg.handle
                    SEQ
                      int.msg.handle[to.handler] ! msg.str; "err.hdlr: IN int.errh: shutdown"
                      int.msg.handle[to.handler] ! msg.end; FALSE
                TRUE
                  SKIP
              --}}}
              IF
                ext.shutdown
                  SEQ
                    -- Leave main loop
                    running := FALSE
                    --{{{  SHUTDOWN message
                    IF
                      msg.type <> (-1)
                        CLAIM int.msg.handle
                          SEQ
                            IF
                              output.msgs
                                SEQ
                                  int.msg.handle[to.handler] ! msg.str; "err.hdlr: OUT int.msgh: shutdown"
                                  int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            int.msg.handle[to.handler] ! shutdown
                      TRUE
                        SKIP
                    --}}}
                TRUE
                  int.shutdown := TRUE
          --}}}
:
--}}}
--{{{  PROC pony.int.msg.handler
-- Message-handler
-- Parameters: own.node.id        | VAL: own node-ID
--             msg.type           | VAL: message-type
--             msg.handle.svr     | server-end of message-handle
--             int.msg.handle.svr | server-end of internal message-handle
PROC pony.int.msg.handler (VAL INT own.node.id, msg.type,
                           PONY.MSGHANDLE? msg.handle.svr,
                           PONY.INT.MSGHANDLE? int.msg.handle.svr)
  --{{{  Initialisations
  -- Shutdown signal received?
  INITIAL BOOL init.needed IS TRUE:
  -- Message string
  INITIAL MOBILE []BYTE the.msg IS "":
  -- Array of messages
  INITIAL MOBILE []MOBILE []BYTE msg.array IS MOBILE [500]MOBILE []BYTE:
  -- Array of error-flags
  INITIAL MOBILE []BOOL err.flag.array IS MOBILE [500]BOOL:
  -- Index of the first element
  --   (if buffer empty, it equals `end.ptr')
  INITIAL INT start.ptr IS 0:
  -- Index of next element to be added
  --   ((end.ptr + (SIZE msg.array)) - start.ptr) \ (SIZE msg.array)
  --   is the number of elements stored in the buffer
  INITIAL INT end.ptr IS 0:
  -- Shutdown signal received?
  INITIAL BOOL shutdown IS FALSE:
  --}}}
  INITIAL BOOL running IS TRUE:
  WHILE running
    ALT
      (init.needed OR ((end.ptr <> start.ptr) OR shutdown)) & msg.handle.svr[to.handler] ? CASE
        --{{{  Request initialisation
        init
          SEQ
            init.needed := FALSE
            -- Send reply
            -- Carrying: own node-ID;
            --           message-type
            msg.handle.svr[from.handler] ! init.confirm; own.node.id; msg.type
        --}}}
        --{{{  Get next message
        get.msg
          IF
            end.ptr <> start.ptr
              MOBILE []BYTE tmp:
              SEQ
                -- Send message
                -- Carrying: message;
                --           error-flag
                -- XXX This uses a temporary as a workaround for an occ21 bug
                -- -- communicating straight out of the array doesn't work.
                tmp := msg.array[start.ptr]
                msg.handle.svr[from.handler] ! get.msg.confirm;
                                               tmp;
                                               err.flag.array[start.ptr]
                -- Move start-pointer
                start.ptr := (start.ptr + 1) \ (SIZE msg.array)
            TRUE
              SEQ
                -- Leave main loop
                running := FALSE
                -- Send reply
                msg.handle.svr[from.handler] ! shutdown
        --}}}
      (NOT shutdown) & int.msg.handle.svr[to.handler] ? CASE
        --{{{  Part of message - string
        MOBILE []BYTE str:
        -- Carrying: string
        msg.str; str
          pony.int.append.str (the.msg, str)
        --}}}
        --{{{  Part of message - integer
        INT int:
        -- Carrying: integer
        msg.int; int
          pony.int.append.int (the.msg, int)
        --}}}
        --{{{  Part of message - integer (hex format)
        INT int:
        -- Carrying: integer
        msg.hex; int
          pony.int.append.hex (the.msg, int)
        --}}}
        --{{{  Part of message - boolean
        BOOL bool:
        -- Carrying: boolean
        msg.bool; bool
          pony.int.append.bool (the.msg, bool)
        --}}}
        --{{{  End of message
        BOOL err.flag:
        -- Carrying: error-flag
        msg.end; err.flag
          SEQ
            --{{{  Double buffer size if buffer full
            --       (full means there are ((SIZE msg.array) - 1) elements)
            IF
              (((end.ptr + (SIZE msg.array)) - start.ptr) \ (SIZE msg.array)) = ((SIZE msg.array) - 1)
                -- New arrays
                INITIAL MOBILE []MOBILE []BYTE new.msg.array IS MOBILE [2 * (SIZE msg.array)]MOBILE []BYTE:
                INITIAL MOBILE []BOOL new.err.flag.array IS MOBILE [2 * (SIZE msg.array)]BOOL:
                SEQ
                  -- Copy elements into new array
                  IF
                    start.ptr = 0
                      SEQ
                        SEQ i = 0 FOR end.ptr
                          new.msg.array[i] := msg.array[i]
                        [new.err.flag.array FOR end.ptr] := [err.flag.array FOR end.ptr]
                    TRUE
                      SEQ
                        SEQ i = 0 FOR (SIZE msg.array) - start.ptr
                          new.msg.array[i] := msg.array[i + start.ptr]
                        SEQ i = 0 FOR end.ptr
                          new.msg.array[i + ((SIZE msg.array) - start.ptr)] := msg.array[i]
                        [new.err.flag.array FOR ((SIZE err.flag.array) - start.ptr)] :=
                          [err.flag.array FROM start.ptr FOR ((SIZE err.flag.array) - start.ptr)]
                        [new.err.flag.array FROM ((SIZE err.flag.array) - start.ptr) FOR end.ptr] :=
                          [err.flag.array FOR end.ptr]
                  -- Adapt pointers
                  start.ptr := 0
                  end.ptr := (SIZE msg.array) - 1
                  -- Use new arrays
                  msg.array := new.msg.array
                  err.flag.array := new.err.flag.array
              TRUE
                SKIP
            --}}}
            -- Update buffer elements
            msg.array[end.ptr] := the.msg
            err.flag.array[end.ptr] := err.flag
            -- Move end-pointer
            end.ptr := (end.ptr + 1) \ (SIZE msg.array)
            -- Reset `the.msg'
            the.msg := ""
        --}}}
        --{{{  Shutdown signal
        shutdown
          shutdown := TRUE
        --}}}
:
--}}}

----------------------------------------------------------------------

--{{{  PROC pony.int.dec.handler
-- Decode-handler
-- Parameters: own.nct.id           | VAL: own NCT-ID
--             own.chan.id          | VAL: index of own channel-word
--             dec.handle.svr       | server-end of decode-handle
--             int.dec.handle.svr   | server-end of internal decode-handle
--             dec.reply.handle.svr | server-end of decode-reply-handle
--             ctb.mgr.handle       | CTB-manager-handle (client-end)
--             master.link.handle   | link-handle for master node (client-end)
--             output.msgs          | VAL: output messages?
--             int.msg.handle       | internal message-handle (client-end)
PROC pony.int.dec.handler (VAL INT own.nct.id, own.chan.id,
                           PONY.DECODEHANDLE? dec.handle.svr,
                           PONY.INT.DECODEHANDLE? int.dec.handle.svr,
                           PONY.INT.DECODEREPLYHANDLE? dec.reply.handle.svr,
                           SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle,
                           SHARED PONY.INT.LINKHANDLE! master.link.handle,
                           VAL BOOL output.msgs,
                           SHARED PONY.INT.MSGHANDLE! int.msg.handle)
  INITIAL BOOL running IS TRUE:
  WHILE running
    int.dec.handle.svr[to.handler] ? CASE
      --{{{  Start session
      start.session
        SEQ
          --{{{  IN message
          IF
            output.msgs
              CLAIM int.msg.handle
                SEQ
                  int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                  int.msg.handle[to.handler] ! msg.str; "/"
                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                  int.msg.handle[to.handler] ! msg.str; ": IN int.dech: start.session"
                  int.msg.handle[to.handler] ! msg.end; FALSE
            TRUE
              SKIP
          --}}}
          -- Activate decoder
          --{{{  OUT message
          IF
            output.msgs
              CLAIM int.msg.handle
                SEQ
                  int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                  int.msg.handle[to.handler] ! msg.str; "/"
                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                  int.msg.handle[to.handler] ! msg.str; ": OUT ext.dech: activate"
                  int.msg.handle[to.handler] ! msg.end; FALSE
            TRUE
              SKIP
          --}}}
          dec.handle.svr[to.decoder] ! activate
          INITIAL BOOL in.session IS TRUE:
          WHILE in.session
            ALT
              --{{{  Get `cancel.session' from CTB-handler (while no ULC pending)
              int.dec.handle.svr[to.handler] ? CASE cancel.session
                SEQ
                  --{{{  IN message
                  IF
                    output.msgs
                      CLAIM int.msg.handle
                        SEQ
                          int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                          int.msg.handle[to.handler] ! msg.str; "/"
                          int.msg.handle[to.handler] ! msg.int; own.chan.id
                          int.msg.handle[to.handler] ! msg.str; ": IN int.dech: cancel.session"
                          int.msg.handle[to.handler] ! msg.end; FALSE
                    TRUE
                      SKIP
                  --}}}
                  -- Deactivate decoder
                  --{{{  OUT message
                  IF
                    output.msgs
                      CLAIM int.msg.handle
                        SEQ
                          int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                          int.msg.handle[to.handler] ! msg.str; "/"
                          int.msg.handle[to.handler] ! msg.int; own.chan.id
                          int.msg.handle[to.handler] ! msg.str; ": OUT ext.dech: cancel"
                          int.msg.handle[to.handler] ! msg.end; FALSE
                    TRUE
                      SKIP
                  --}}}
                  dec.handle.svr[to.decoder] ! cancel
                  --{{{  Get confirmation
                  dec.handle.svr[from.decoder] ? CASE
                    -- Confirmation
                    cancel.confirm
                      --{{{  IN message
                      IF
                        output.msgs
                          CLAIM int.msg.handle
                            SEQ
                              int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                              int.msg.handle[to.handler] ! msg.str; "/"
                              int.msg.handle[to.handler] ! msg.int; own.chan.id
                              int.msg.handle[to.handler] ! msg.str; ": IN ext.dech: cancel.confirm"
                              int.msg.handle[to.handler] ! msg.end; FALSE
                        TRUE
                          SKIP
                      --}}}
                    -- Attempted new ULC - ignore
                    INT di.nlcs.first, cte.nlcs.first:
                    BOOL has.rest.clcs:
                    -- Carrying: number of data-item NLCs in first CLC;
                    --           number of channel-type-end NLCs in first CLC;
                    --           are there remaining CLCs?
                    first.clc; di.nlcs.first; cte.nlcs.first; has.rest.clcs
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; "/"
                                int.msg.handle[to.handler] ! msg.int; own.chan.id
                                int.msg.handle[to.handler] ! msg.str; ": IN ext.dech: first.clc; "
                                int.msg.handle[to.handler] ! msg.int; di.nlcs.first
                                int.msg.handle[to.handler] ! msg.str; "; "
                                int.msg.handle[to.handler] ! msg.int; cte.nlcs.first
                                int.msg.handle[to.handler] ! msg.str; "; "
                                int.msg.handle[to.handler] ! msg.bool; has.rest.clcs
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        -- Get `real' confirmation
                        dec.handle.svr[from.decoder] ? CASE cancel.confirm
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; "/"
                                int.msg.handle[to.handler] ! msg.int; own.chan.id
                                int.msg.handle[to.handler] ! msg.str; ": IN ext.dech: cancel.confirm"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                  --}}}
                  -- Deactivate handler
                  in.session := FALSE
                  -- Confirm `cancel.session'
                  --{{{  OUT message
                  IF
                    output.msgs
                      CLAIM int.msg.handle
                        SEQ
                          int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                          int.msg.handle[to.handler] ! msg.str; "/"
                          int.msg.handle[to.handler] ! msg.int; own.chan.id
                          int.msg.handle[to.handler] ! msg.str; ": OUT int.dech: cancel.confirm"
                          int.msg.handle[to.handler] ! msg.end; FALSE
                    TRUE
                      SKIP
                  --}}}
                  int.dec.handle.svr[from.handler] ! cancel.confirm
              --}}}
              --{{{  Get first CLC of next ULC from decoder
              INT di.nlcs.first, cte.nlcs.first:
              BOOL has.rest.clcs:
              -- Carrying: number of data-item NLCs in first CLC;
              --           number of channel-type-end NLCs in first CLC;
              --           are there remaining CLCs?
              dec.handle.svr[from.decoder] ? CASE first.clc;
                                                  di.nlcs.first; cte.nlcs.first;
                                                  has.rest.clcs
                INITIAL BOOL sending.end.over.itself IS FALSE:
                MOBILE []INT addr.array, size.array:
                MOBILE []BYTE clc.desc:
                BOOL was.cancelled:
                SEQ
                  --{{{  IN message
                  IF
                    output.msgs
                      CLAIM int.msg.handle
                        SEQ
                          int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                          int.msg.handle[to.handler] ! msg.str; "/"
                          int.msg.handle[to.handler] ! msg.int; own.chan.id
                          int.msg.handle[to.handler] ! msg.str; ": IN ext.dech: first.clc; "
                          int.msg.handle[to.handler] ! msg.int; di.nlcs.first
                          int.msg.handle[to.handler] ! msg.str; "; "
                          int.msg.handle[to.handler] ! msg.int; cte.nlcs.first
                          int.msg.handle[to.handler] ! msg.str; "; "
                          int.msg.handle[to.handler] ! msg.bool; has.rest.clcs
                          int.msg.handle[to.handler] ! msg.end; FALSE
                    TRUE
                      SKIP
                  --}}}
                  IF
                    --{{{  No channel-type-end NLCs in first CLC
                    cte.nlcs.first = 0
                      SEQ
                        -- Initialise address/size-arrays
                        addr.array := MOBILE [di.nlcs.first]INT
                        size.array := MOBILE [di.nlcs.first]INT
                        -- Get all NLCs of first CLC from decoder
                        INT addr, size:
                        SEQ i = 0 FOR di.nlcs.first
                          SEQ
                            -- Data-item NLC
                            -- Carrying: address;
                            --           size
                            dec.handle.svr[from.decoder] ? CASE data.item.nlc; addr; size
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                    int.msg.handle[to.handler] ! msg.str; "/"
                                    int.msg.handle[to.handler] ! msg.int; own.chan.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN ext.dech: data.item.nlc; "
                                    int.msg.handle[to.handler] ! msg.hex; addr
                                    int.msg.handle[to.handler] ! msg.str; "; "
                                    int.msg.handle[to.handler] ! msg.int; size
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            addr.array[i] := addr
                            size.array[i] := size
                    --}}}
                    --{{{  There are channel-type-end NLCs in first CLC
                    TRUE
                      INT clc.desc.addr, clc.desc.size:
                      SEQ
                        -- Initialise address/size-arrays
                        addr.array := MOBILE [di.nlcs.first + 1]INT
                        size.array := MOBILE [di.nlcs.first + 1]INT
                        -- Initialise CLC-descriptor
                        clc.desc := MOBILE [di.nlcs.first + ((1 + BYTESIN (INT)) * cte.nlcs.first)]BYTE
                        -- Store CLC-descriptor's address/size as last item in address/size-arrays
                        DECODE.DATA (clc.desc, clc.desc.addr, clc.desc.size)
                        addr.array[di.nlcs.first] := clc.desc.addr
                        size.array[di.nlcs.first] := clc.desc.size
                        -- Get all NLCs of first CLC from decoder
                        INITIAL INT current.as.index IS 0:
                        INITIAL INT current.clc.desc.index IS 0:
                        INITIAL INT i IS 0:
                        WHILE i < (di.nlcs.first + cte.nlcs.first)
                          dec.handle.svr[from.decoder] ? CASE
                            --{{{  Data-item NLC
                            INT addr, size:
                            -- Carrying: address;
                            --           size
                            data.item.nlc; addr; size
                              SEQ
                                --{{{  IN message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                                        int.msg.handle[to.handler] ! msg.str; "/"
                                        int.msg.handle[to.handler] ! msg.int; own.chan.id
                                        int.msg.handle[to.handler] ! msg.str; ": IN ext.dech: data.item.nlc; "
                                        int.msg.handle[to.handler] ! msg.hex; addr
                                        int.msg.handle[to.handler] ! msg.str; "; "
                                        int.msg.handle[to.handler] ! msg.int; size
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                                -- Store address/size
                                addr.array[current.as.index] := addr
                                size.array[current.as.index] := size
                                current.as.index := current.as.index + 1
                                -- Update CLC-descriptor
                                clc.desc[current.clc.desc.index] := 0
                                current.clc.desc.index := current.clc.desc.index + 1
                                i := i + 1
                            --}}}
                            --{{{  Make CTB networked
                            INT ctb.ptr, cli.state, svr.state, num.chans, num.readers.in.svr:
                            -- Carrying: CTB-pointer;
                            --           client-state (1 = unshared,
                            --                         2 = shared/unclaimed, 3 = shared/claimed);
                            --           server-state (1 = unshared,
                            --                         2 = shared/unclaimed, 3 = shared/claimed);
                            --           number of channel-words;
                            --           number of reading-ends in server-end
                            make.ctb.networked; ctb.ptr; cli.state; svr.state;
                                                num.chans; num.readers.in.svr
                              INT nct.id:
                              INITIAL BOOL initial.cli.claimed IS NOT (cli.state = PONYC.SHARETYPE.SHARED):
                              INITIAL BOOL initial.svr.claimed IS NOT (svr.state = PONYC.SHARETYPE.SHARED):
                              PONY.NETHOOKHANDLE! net.hook.handle:
                              MOBILE []PONY.DECODEHANDLE! dec.handle.array:
                              MOBILE []PONY.ENCODEHANDLE! enc.handle.array:
                              SEQ
                                --{{{  IN message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                                        int.msg.handle[to.handler] ! msg.str; "/"
                                        int.msg.handle[to.handler] ! msg.int; own.chan.id
                                        int.msg.handle[to.handler] ! msg.str; ": IN ext.dech: make.ctb.networked; "
                                        int.msg.handle[to.handler] ! msg.hex; ctb.ptr
                                        int.msg.handle[to.handler] ! msg.str; "; "
                                        int.msg.handle[to.handler] ! msg.int; cli.state
                                        int.msg.handle[to.handler] ! msg.str; "; "
                                        int.msg.handle[to.handler] ! msg.int; svr.state
                                        int.msg.handle[to.handler] ! msg.str; "; "
                                        int.msg.handle[to.handler] ! msg.int; num.chans
                                        int.msg.handle[to.handler] ! msg.str; "; "
                                        int.msg.handle[to.handler] ! msg.int; num.readers.in.svr
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                                -- Send request to NCT-manager (via master-link-handle)
                                CLAIM master.link.handle
                                  SEQ
                                    --{{{  OUT message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                                            int.msg.handle[to.handler] ! msg.str; "/"
                                            int.msg.handle[to.handler] ! msg.int; own.chan.id
                                            int.msg.handle[to.handler] ! msg.str; ": OUT linkh 0: fornctmgr.make.ctb.networked; "
                                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                                            int.msg.handle[to.handler] ! msg.str; "; "
                                            int.msg.handle[to.handler] ! msg.int; own.chan.id
                                            int.msg.handle[to.handler] ! msg.str; "; "
                                            int.msg.handle[to.handler] ! msg.bool; initial.cli.claimed
                                            int.msg.handle[to.handler] ! msg.str; "; "
                                            int.msg.handle[to.handler] ! msg.bool; initial.svr.claimed
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    -- Carrying: NCT-ID of the decode-handler making the request
                                    --           channel-ID of the decode-handler making the request
                                    --           client-end initially claimed?;
                                    --           server-end initially claimed?
                                    master.link.handle[to.handler] ! fornctmgr.make.ctb.networked;
                                                                     own.nct.id; own.chan.id;
                                                                     initial.cli.claimed; initial.svr.claimed
                                -- Wait for reply (via decode-reply-handle)
                                -- Carrying: NCT-ID
                                dec.reply.handle.svr[to.handler] ? CASE make.ctb.networked.confirm; nct.id
                                --{{{  IN message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                                        int.msg.handle[to.handler] ! msg.str; "/"
                                        int.msg.handle[to.handler] ! msg.int; own.chan.id
                                        int.msg.handle[to.handler] ! msg.str; ": IN decreplyh: make.ctb.networked.confirm; "
                                        int.msg.handle[to.handler] ! msg.int; nct.id
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                                -- Send request to CTB-manager
                                CLAIM ctb.mgr.handle
                                  SEQ
                                    --{{{  OUT message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                                            int.msg.handle[to.handler] ! msg.str; "/"
                                            int.msg.handle[to.handler] ! msg.int; own.chan.id
                                            int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: make.ctb.networked; "
                                            int.msg.handle[to.handler] ! msg.int; nct.id
                                            int.msg.handle[to.handler] ! msg.str; "; "
                                            int.msg.handle[to.handler] ! msg.hex; ctb.ptr
                                            int.msg.handle[to.handler] ! msg.str; "; "
                                            int.msg.handle[to.handler] ! msg.bool; initial.cli.claimed
                                            int.msg.handle[to.handler] ! msg.str; "; "
                                            int.msg.handle[to.handler] ! msg.bool; initial.svr.claimed
                                            int.msg.handle[to.handler] ! msg.str; "; "
                                            int.msg.handle[to.handler] ! msg.int; num.chans
                                            int.msg.handle[to.handler] ! msg.str; "; "
                                            int.msg.handle[to.handler] ! msg.int; num.readers.in.svr
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    -- Carrying: NCT-ID;
                                    --           CTB-pointer;
                                    --           client-end initially claimed?;
                                    --           server-end initially claimed?;
                                    --           number of channel-words;
                                    --           number of reading-ends in server-end
                                    ctb.mgr.handle[to.mgr] ! make.ctb.networked; nct.id; ctb.ptr;
                                                                                 initial.cli.claimed; initial.svr.claimed;
                                                                                 num.chans; num.readers.in.svr
                                    -- Wait for reply
                                    -- Carrying: network-hook-handle;
                                    --           array of decode-handles;
                                    --           array of encode-handles
                                    ctb.mgr.handle[from.mgr] ? CASE make.ctb.networked.confirm;
                                                                    net.hook.handle;
                                                                    dec.handle.array; enc.handle.array
                                    --{{{  IN message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                                            int.msg.handle[to.handler] ! msg.str; "/"
                                            int.msg.handle[to.handler] ! msg.int; own.chan.id
                                            int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: make.ctb.networked.confirm; [cli-end]; [array ("
                                            int.msg.handle[to.handler] ! msg.int; SIZE dec.handle.array
                                            int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                                            int.msg.handle[to.handler] ! msg.int; SIZE enc.handle.array
                                            int.msg.handle[to.handler] ! msg.str; ")]"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                -- Pass message on to decoder
                                --{{{  OUT message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                                        int.msg.handle[to.handler] ! msg.str; "/"
                                        int.msg.handle[to.handler] ! msg.int; own.chan.id
                                        int.msg.handle[to.handler] ! msg.str; ": OUT ext.dech: make.ctb.networked.confirm; "
                                        int.msg.handle[to.handler] ! msg.int; nct.id
                                        int.msg.handle[to.handler] ! msg.str; "; [cli-end]; [array ("
                                        int.msg.handle[to.handler] ! msg.int; SIZE dec.handle.array
                                        int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                                        int.msg.handle[to.handler] ! msg.int; SIZE enc.handle.array
                                        int.msg.handle[to.handler] ! msg.str; ")]"
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                                -- Carrying: NCT-ID;
                                --           network-hook-handle;
                                --           array of decode-handles;
                                --           array of encode-handles
                                dec.handle.svr[to.decoder] ! make.ctb.networked.confirm;
                                                             nct.id; net.hook.handle;
                                                             dec.handle.array; enc.handle.array
                            --}}}
                            --{{{  Channel-type-end NLC
                            INT nct.id, dir.type, share.type:
                            -- Carrying: NCT-ID;
                            --           direction-type of the end to be sent
                            --             (0 = client-end, 1 = server-end);
                            --           share-type of the end to be sent
                            --             (1 = unshared, 2 = shared)
                            ct.end.nlc; nct.id; dir.type; share.type
                              SEQ
                                --{{{  IN message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                                        int.msg.handle[to.handler] ! msg.str; "/"
                                        int.msg.handle[to.handler] ! msg.int; own.chan.id
                                        int.msg.handle[to.handler] ! msg.str; ": IN ext.dech: ct.end.nlc; "
                                        int.msg.handle[to.handler] ! msg.int; nct.id
                                        int.msg.handle[to.handler] ! msg.str; "; "
                                        int.msg.handle[to.handler] ! msg.int; dir.type
                                        int.msg.handle[to.handler] ! msg.str; "; "
                                        int.msg.handle[to.handler] ! msg.int; share.type
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                                --{{{  Internal-release preparations
                                IF
                                  -- Shared end
                                  share.type = PONYC.SHARETYPE.SHARED
                                    SKIP
                                  -- Unshared end of own CTB
                                  nct.id = own.nct.id
                                    sending.end.over.itself := TRUE
                                  -- Unshared end of other CTB
                                  TRUE
                                    -- Internal-release the end
                                    SHARED PONY.INT.CTBCLAIMHANDLE! ctb.claim.handle:
                                    SEQ
                                      CLAIM ctb.mgr.handle
                                        SEQ
                                          -- Get CTB-claim-handle from CTB-manager
                                          --{{{  OUT message
                                          IF
                                            output.msgs
                                              CLAIM int.msg.handle
                                                SEQ
                                                  int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                  int.msg.handle[to.handler] ! msg.str; "/"
                                                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                  int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.claim.handle; "
                                                  int.msg.handle[to.handler] ! msg.int; nct.id
                                                  int.msg.handle[to.handler] ! msg.str; "; "
                                                  int.msg.handle[to.handler] ! msg.int; dir.type
                                                  int.msg.handle[to.handler] ! msg.end; FALSE
                                            TRUE
                                              SKIP
                                          --}}}
                                          -- Carrying: NCT-ID;
                                          --           direction-type of the end to be claimed/released
                                          --             (0 = client-end, 1 = server-end)
                                          ctb.mgr.handle[to.mgr] ! get.ctb.claim.handle; nct.id; dir.type
                                          -- Get reply
                                          -- Carrying: CTB-claim-handle
                                          ctb.mgr.handle[from.mgr] ? CASE get.ctb.claim.handle.confirm; ctb.claim.handle
                                          --{{{  IN message
                                          IF
                                            output.msgs
                                              CLAIM int.msg.handle
                                                SEQ
                                                  int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                  int.msg.handle[to.handler] ! msg.str; "/"
                                                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                  int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.claim.handle.confirm; [cli-end]"
                                                  int.msg.handle[to.handler] ! msg.end; FALSE
                                            TRUE
                                              SKIP
                                          --}}}
                                      CLAIM ctb.claim.handle
                                        SEQ
                                          --{{{  OUT message
                                          IF
                                            output.msgs
                                              CLAIM int.msg.handle
                                                SEQ
                                                  int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                  int.msg.handle[to.handler] ! msg.str; "/"
                                                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                  int.msg.handle[to.handler] ! msg.str; ": OUT ctbclaimh "
                                                  int.msg.handle[to.handler] ! msg.int; nct.id
                                                  int.msg.handle[to.handler] ! msg.str; "/"
                                                  int.msg.handle[to.handler] ! msg.int; dir.type
                                                  int.msg.handle[to.handler] ! msg.str; ": release"
                                                  int.msg.handle[to.handler] ! msg.end; FALSE
                                            TRUE
                                              SKIP
                                          --}}}
                                          ctb.claim.handle[to.handler] ! release
                                --}}}
                                --{{{  Update CLC-descriptor
                                -- Bit 1 (lowest bit): channel-type-end CLC (1)
                                clc.desc[current.clc.desc.index] := 1
                                -- Bit 2: direction-type (0 = client-end, 1 = server-end)
                                IF
                                  dir.type = PONYC.INT.DIRTYPE.SVR
                                    clc.desc[current.clc.desc.index] := clc.desc[current.clc.desc.index] \/ 2
                                  TRUE
                                    SKIP
                                -- Bit 3: share-type (1 = unshared, 0 = shared (IMPORTANT: different from
                                --   `PONYC.SHARETYPE.SHARED' in order to fit it into one bit))
                                IF
                                  share.type = PONYC.SHARETYPE.UNSHARED
                                    clc.desc[current.clc.desc.index] := clc.desc[current.clc.desc.index] \/ 4
                                  TRUE
                                    SKIP
                                -- Store NCT-ID in the next BYTESIN (INT) bytes
                                []BYTE nct.id.array RETYPES nct.id:
                                [clc.desc FROM current.clc.desc.index + 1 FOR BYTESIN (INT)] := nct.id.array
                                -- Update index
                                current.clc.desc.index := current.clc.desc.index + (1 + BYTESIN (INT))
                                --}}}
                                i := i + 1
                            --}}}
                    --}}}
                  CHAN BOOL cancel.sync:
                  PAR
                    --{{{  Output `first.clc' to CTB-handler
                    SEQ
                      --{{{  OUT message
                      IF
                        output.msgs
                          CLAIM int.msg.handle
                            SEQ
                              int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                              int.msg.handle[to.handler] ! msg.str; "/"
                              int.msg.handle[to.handler] ! msg.int; own.chan.id
                              int.msg.handle[to.handler] ! msg.str; ": OUT int.dech: first.clc; "
                              int.msg.handle[to.handler] ! msg.int; di.nlcs.first
                              int.msg.handle[to.handler] ! msg.str; "; "
                              int.msg.handle[to.handler] ! msg.int; cte.nlcs.first
                              int.msg.handle[to.handler] ! msg.str; "; "
                              int.msg.handle[to.handler] ! msg.bool; has.rest.clcs
                              int.msg.handle[to.handler] ! msg.end; FALSE
                        TRUE
                          SKIP
                      --}}}
                      -- Carrying: number of data-item NLCs in first CLC;
                      --           number of channel-type-end NLCs in first CLC;
                      --           are there remaining CLCs?
                      int.dec.handle.svr[from.handler] ! first.clc; di.nlcs.first; cte.nlcs.first;
                                                                   has.rest.clcs
                      -- Output of `first.clc' message finished
                      cancel.sync ! TRUE
                    --}}}
                    --{{{  Check for cancel while ULC pending
                    ALT
                      int.dec.handle.svr[to.handler] ? CASE cancel.session
                        SEQ
                          --{{{  IN message
                          IF
                            output.msgs
                              CLAIM int.msg.handle
                                SEQ
                                  int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                                  int.msg.handle[to.handler] ! msg.str; "/"
                                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                                  int.msg.handle[to.handler] ! msg.str; ": IN int.dech: cancel.session"
                                  int.msg.handle[to.handler] ! msg.end; FALSE
                            TRUE
                              SKIP
                          --}}}
                          BOOL any:
                          cancel.sync ? any
                          was.cancelled := TRUE
                      BOOL any:
                      cancel.sync ? any
                        was.cancelled := FALSE
                    --}}}
                  --{{{  Was there a `cancel'?
                  IF
                    --{{{  There was a `cancel' before `first.clc' message was sent
                    was.cancelled
                      SEQ
                        --{{{  Internal-claim all previously internal-released unshared ends
                        IF
                          -- There are channel-type-end NLCs in first CLC
                          cte.nlcs.first > 0
                            INITIAL INT current.clc.desc.index IS 0:
                            WHILE current.clc.desc.index < (SIZE clc.desc)
                              IF
                                --{{{  Data-item NLC
                                clc.desc[current.clc.desc.index] = 0
                                  -- Update index
                                  current.clc.desc.index := current.clc.desc.index + 1
                                --}}}
                                --{{{  Channel-type-end NLC
                                TRUE
                                  SEQ
                                    --{{{  Actual operation
                                    IF
                                      -- Unshared end
                                      (clc.desc[current.clc.desc.index] /\ 5) = 5
                                        INITIAL [BYTESIN (INT)]BYTE nct.id.array IS [clc.desc FROM current.clc.desc.index + 1 FOR BYTESIN (INT)]:
                                        INT nct.id RETYPES nct.id.array:
                                        IF
                                          -- End was attempted to be sent over itself
                                          nct.id = own.nct.id
                                            SKIP
                                          -- End belongs to other CTB
                                          TRUE
                                            -- Internal-claim the end
                                            INT dir.type:
                                            SHARED PONY.INT.CTBCLAIMHANDLE! ctb.claim.handle:
                                            SEQ
                                              IF
                                                -- Unshared client-end
                                                clc.desc[current.clc.desc.index] = 5
                                                  dir.type := PONYC.INT.DIRTYPE.CLI
                                                -- Unshared server-end
                                                TRUE
                                                  dir.type := PONYC.INT.DIRTYPE.SVR
                                              CLAIM ctb.mgr.handle
                                                SEQ
                                                  -- Get CTB-claim-handle from CTB-manager
                                                  --{{{  OUT message
                                                  IF
                                                    output.msgs
                                                      CLAIM int.msg.handle
                                                        SEQ
                                                          int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                          int.msg.handle[to.handler] ! msg.str; "/"
                                                          int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                          int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.claim.handle; "
                                                          int.msg.handle[to.handler] ! msg.int; nct.id
                                                          int.msg.handle[to.handler] ! msg.str; "; "
                                                          int.msg.handle[to.handler] ! msg.int; dir.type
                                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                                    TRUE
                                                      SKIP
                                                  --}}}
                                                  -- Carrying: NCT-ID;
                                                  --           direction-type of the end to be claimed/released
                                                  --             (0 = client-end, 1 = server-end)
                                                  ctb.mgr.handle[to.mgr] ! get.ctb.claim.handle; nct.id; dir.type
                                                  -- Get reply
                                                  -- Carrying: CTB-claim-handle
                                                  ctb.mgr.handle[from.mgr] ? CASE get.ctb.claim.handle.confirm; ctb.claim.handle
                                                  --{{{  IN message
                                                  IF
                                                    output.msgs
                                                      CLAIM int.msg.handle
                                                        SEQ
                                                          int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                          int.msg.handle[to.handler] ! msg.str; "/"
                                                          int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                          int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.claim.handle.confirm; [cli-end]"
                                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                                    TRUE
                                                      SKIP
                                                  --}}}
                                              CLAIM ctb.claim.handle
                                                SEQ
                                                  --{{{  OUT message
                                                  IF
                                                    output.msgs
                                                      CLAIM int.msg.handle
                                                        SEQ
                                                          int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                          int.msg.handle[to.handler] ! msg.str; "/"
                                                          int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                          int.msg.handle[to.handler] ! msg.str; ": OUT ctbclaimh "
                                                          int.msg.handle[to.handler] ! msg.int; nct.id
                                                          int.msg.handle[to.handler] ! msg.str; "/"
                                                          int.msg.handle[to.handler] ! msg.int; dir.type
                                                          int.msg.handle[to.handler] ! msg.str; ": claim"
                                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                                    TRUE
                                                      SKIP
                                                  --}}}
                                                  ctb.claim.handle[to.handler] ! claim
                                      -- Shared end
                                      TRUE
                                        SKIP
                                    --}}}
                                    -- Update index
                                    current.clc.desc.index := current.clc.desc.index + (1 + BYTESIN (INT))
                                --}}}
                          -- No channel-type-end NLCs in first CLC
                          TRUE
                            SKIP
                        --}}}
                        -- Cancel ULC in decoder, deactivate decoder
                        --{{{  OUT message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; "/"
                                int.msg.handle[to.handler] ! msg.int; own.chan.id
                                int.msg.handle[to.handler] ! msg.str; ": OUT ext.dech: cancel"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        dec.handle.svr[to.decoder] ! cancel
                        -- Get confirmation
                        dec.handle.svr[from.decoder] ? CASE cancel.confirm
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; "/"
                                int.msg.handle[to.handler] ! msg.int; own.chan.id
                                int.msg.handle[to.handler] ! msg.str; ": IN ext.dech: cancel.confirm"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        -- Deactivate handler
                        in.session := FALSE
                        -- Confirm `cancel.session'
                        --{{{  OUT message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; "/"
                                int.msg.handle[to.handler] ! msg.int; own.chan.id
                                int.msg.handle[to.handler] ! msg.str; ": OUT int.dech: cancel.confirm"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        int.dec.handle.svr[from.handler] ! cancel.confirm
                    --}}}
                    --{{{  No `cancel'; the first CLC's NLCs can now be output to CTB-handler
                    TRUE
                      SEQ
                        -- Check whether first CLC is an end-over-itself-CLC
                        IF
                          sending.end.over.itself
                            SEQ
                              -- Notify CTB-handler
                              --{{{  OUT message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; own.nct.id
                                      int.msg.handle[to.handler] ! msg.str; "/"
                                      int.msg.handle[to.handler] ! msg.int; own.chan.id
                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.dech: end.over.itself.clc"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              int.dec.handle.svr[from.handler] ! end.over.itself.clc
                          TRUE
                            SKIP
                        -- Output first CLC to CTB-handler
                        --{{{  OUT message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; "/"
                                int.msg.handle[to.handler] ! msg.int; own.chan.id
                                int.msg.handle[to.handler] ! msg.str; ": OUT int.dech: clc; [array ("
                                int.msg.handle[to.handler] ! msg.int; SIZE addr.array
                                int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                                int.msg.handle[to.handler] ! msg.int; SIZE size.array
                                int.msg.handle[to.handler] ! msg.str; ")]"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        -- Carrying: address-array;
                        --           size-array
                        int.dec.handle.svr[from.handler] ! clc; addr.array; size.array
                        -- Get reply from CTB-handler
                        int.dec.handle.svr[to.handler] ? CASE
                          --{{{  Cancel
                          cancel.session
                            SEQ
                              --{{{  IN message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; own.nct.id
                                      int.msg.handle[to.handler] ! msg.str; "/"
                                      int.msg.handle[to.handler] ! msg.int; own.chan.id
                                      int.msg.handle[to.handler] ! msg.str; ": IN int.dech: cancel.session"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              --{{{  Internal-claim all previously internal-released unshared ends
                              IF
                                -- There are channel-type-end NLCs in first CLC
                                cte.nlcs.first > 0
                                  INITIAL INT current.clc.desc.index IS 0:
                                  WHILE current.clc.desc.index < (SIZE clc.desc)
                                    IF
                                      --{{{  Data-item NLC
                                      clc.desc[current.clc.desc.index] = 0
                                        -- Update index
                                        current.clc.desc.index := current.clc.desc.index + 1
                                      --}}}
                                      --{{{  Channel-type-end NLC
                                      TRUE
                                        SEQ
                                          --{{{  Actual operation
                                          IF
                                            -- Unshared end
                                            (clc.desc[current.clc.desc.index] /\ 5) = 5
                                              INITIAL [BYTESIN (INT)]BYTE nct.id.array IS [clc.desc FROM current.clc.desc.index + 1 FOR BYTESIN (INT)]:
                                              INT nct.id RETYPES nct.id.array:
                                              IF
                                                -- End was attempted to be sent over itself
                                                nct.id = own.nct.id
                                                  SKIP
                                                -- End belongs to other CTB
                                                TRUE
                                                  -- Internal-claim the end
                                                  INT dir.type:
                                                  SHARED PONY.INT.CTBCLAIMHANDLE! ctb.claim.handle:
                                                  SEQ
                                                    IF
                                                      -- Unshared client-end
                                                      clc.desc[current.clc.desc.index] = 5
                                                        dir.type := PONYC.INT.DIRTYPE.CLI
                                                      -- Unshared server-end
                                                      TRUE
                                                        dir.type := PONYC.INT.DIRTYPE.SVR
                                                    CLAIM ctb.mgr.handle
                                                      SEQ
                                                        -- Get CTB-claim-handle from CTB-manager
                                                        --{{{  OUT message
                                                        IF
                                                          output.msgs
                                                            CLAIM int.msg.handle
                                                              SEQ
                                                                int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                                int.msg.handle[to.handler] ! msg.str; "/"
                                                                int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                                int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.claim.handle; "
                                                                int.msg.handle[to.handler] ! msg.int; nct.id
                                                                int.msg.handle[to.handler] ! msg.str; "; "
                                                                int.msg.handle[to.handler] ! msg.int; dir.type
                                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                                          TRUE
                                                            SKIP
                                                        --}}}
                                                        -- Carrying: NCT-ID;
                                                        --           direction-type of the end to be claimed/released
                                                        --             (0 = client-end, 1 = server-end)
                                                        ctb.mgr.handle[to.mgr] ! get.ctb.claim.handle; nct.id; dir.type
                                                        -- Get reply
                                                        -- Carrying: CTB-claim-handle
                                                        ctb.mgr.handle[from.mgr] ? CASE get.ctb.claim.handle.confirm; ctb.claim.handle
                                                        --{{{  IN message
                                                        IF
                                                          output.msgs
                                                            CLAIM int.msg.handle
                                                              SEQ
                                                                int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                                int.msg.handle[to.handler] ! msg.str; "/"
                                                                int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                                int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.claim.handle.confirm; [cli-end]"
                                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                                          TRUE
                                                            SKIP
                                                        --}}}
                                                    CLAIM ctb.claim.handle
                                                      SEQ
                                                        --{{{  OUT message
                                                        IF
                                                          output.msgs
                                                            CLAIM int.msg.handle
                                                              SEQ
                                                                int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                                int.msg.handle[to.handler] ! msg.str; "/"
                                                                int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                                int.msg.handle[to.handler] ! msg.str; ": OUT ctbclaimh "
                                                                int.msg.handle[to.handler] ! msg.int; nct.id
                                                                int.msg.handle[to.handler] ! msg.str; "/"
                                                                int.msg.handle[to.handler] ! msg.int; dir.type
                                                                int.msg.handle[to.handler] ! msg.str; ": claim"
                                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                                          TRUE
                                                            SKIP
                                                        --}}}
                                                        ctb.claim.handle[to.handler] ! claim
                                            -- Shared end
                                            TRUE
                                              SKIP
                                          --}}}
                                          -- Update index
                                          current.clc.desc.index := current.clc.desc.index + (1 + BYTESIN (INT))
                                      --}}}
                                -- No channel-type-end NLCs in first CLC
                                TRUE
                                  SKIP
                              --}}}
                              -- Cancel ULC in decoder, deactivate decoder
                              --{{{  OUT message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; own.nct.id
                                      int.msg.handle[to.handler] ! msg.str; "/"
                                      int.msg.handle[to.handler] ! msg.int; own.chan.id
                                      int.msg.handle[to.handler] ! msg.str; ": OUT ext.dech: cancel"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              dec.handle.svr[to.decoder] ! cancel
                              -- Get confirmation
                              dec.handle.svr[from.decoder] ? CASE cancel.confirm
                              --{{{  IN message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; own.nct.id
                                      int.msg.handle[to.handler] ! msg.str; "/"
                                      int.msg.handle[to.handler] ! msg.int; own.chan.id
                                      int.msg.handle[to.handler] ! msg.str; ": IN ext.dech: cancel.confirm"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              -- Deactivate handler
                              in.session := FALSE
                              -- Confirm `cancel.session'
                              --{{{  OUT message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; own.nct.id
                                      int.msg.handle[to.handler] ! msg.str; "/"
                                      int.msg.handle[to.handler] ! msg.int; own.chan.id
                                      int.msg.handle[to.handler] ! msg.str; ": OUT int.dech: cancel.confirm"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              int.dec.handle.svr[from.handler] ! cancel.confirm
                          --}}}
                          --{{{  First CLC has been taken by remote user-level process
                          ack
                            SEQ
                              --{{{  IN message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; own.nct.id
                                      int.msg.handle[to.handler] ! msg.str; "/"
                                      int.msg.handle[to.handler] ! msg.int; own.chan.id
                                      int.msg.handle[to.handler] ! msg.str; ": IN int.dech: ack"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              -- Pass ack on to decoder
                              --{{{  OUT message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; own.nct.id
                                      int.msg.handle[to.handler] ! msg.str; "/"
                                      int.msg.handle[to.handler] ! msg.int; own.chan.id
                                      int.msg.handle[to.handler] ! msg.str; ": OUT ext.dech: ack"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              dec.handle.svr[to.decoder] ! ack
                              --{{{  Deal with remaining CLCs
                              IF
                                has.rest.clcs
                                  INT di.nlcs.rest, cte.nlcs.rest:
                                  SEQ
                                    -- Carrying: number of data-item NLCs in remaining CLCs;
                                    --           number of channel-type-end NLCs in remaining CLCs
                                    dec.handle.svr[from.decoder] ? CASE rest.clcs;
                                                                        di.nlcs.rest; cte.nlcs.rest
                                    --{{{  IN message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                                            int.msg.handle[to.handler] ! msg.str; "/"
                                            int.msg.handle[to.handler] ! msg.int; own.chan.id
                                            int.msg.handle[to.handler] ! msg.str; ": IN ext.dech: rest.clcs; "
                                            int.msg.handle[to.handler] ! msg.int; di.nlcs.rest
                                            int.msg.handle[to.handler] ! msg.str; "; "
                                            int.msg.handle[to.handler] ! msg.int; cte.nlcs.rest
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    sending.end.over.itself := FALSE
                                    IF
                                      --{{{  No channel-type-end NLCs in remaining CLCs
                                      cte.nlcs.rest = 0
                                        SEQ
                                          -- Initialise address/size-arrays
                                          addr.array := MOBILE [di.nlcs.rest]INT
                                          size.array := MOBILE [di.nlcs.rest]INT
                                          -- Get all NLCs of remaining CLCs from decoder
                                          INT addr, size:
                                          SEQ i = 0 FOR di.nlcs.rest
                                            SEQ
                                              -- Data-item NLC
                                              -- Carrying: address;
                                              --           size
                                              dec.handle.svr[from.decoder] ? CASE data.item.nlc; addr; size
                                              --{{{  IN message
                                              IF
                                                output.msgs
                                                  CLAIM int.msg.handle
                                                    SEQ
                                                      int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                      int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                      int.msg.handle[to.handler] ! msg.str; "/"
                                                      int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                      int.msg.handle[to.handler] ! msg.str; ": IN ext.dech: data.item.nlc; "
                                                      int.msg.handle[to.handler] ! msg.hex; addr
                                                      int.msg.handle[to.handler] ! msg.str; "; "
                                                      int.msg.handle[to.handler] ! msg.int; size
                                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                                TRUE
                                                  SKIP
                                              --}}}
                                              addr.array[i] := addr
                                              size.array[i] := size
                                      --}}}
                                      --{{{  There are channel-type-end NLCs in remaining CLCs
                                      TRUE
                                        INT clc.desc.addr, clc.desc.size:
                                        SEQ
                                          -- Initialise address/size-arrays
                                          addr.array := MOBILE [di.nlcs.rest + 1]INT
                                          size.array := MOBILE [di.nlcs.rest + 1]INT
                                          -- Initialise CLC-descriptor
                                          clc.desc := MOBILE [di.nlcs.rest + ((1 + BYTESIN (INT)) * cte.nlcs.rest)]BYTE
                                          -- Store CLC-descriptor's address/size as last item in address/size-arrays
                                          DECODE.DATA (clc.desc, clc.desc.addr, clc.desc.size)
                                          addr.array[di.nlcs.rest] := clc.desc.addr
                                          size.array[di.nlcs.rest] := clc.desc.size
                                          -- Get all NLCs of remaining CLCs from decoder
                                          INITIAL INT current.as.index IS 0:
                                          INITIAL INT current.clc.desc.index IS 0:
                                          INITIAL INT i IS 0:
                                          WHILE i < (di.nlcs.rest + cte.nlcs.rest)
                                            dec.handle.svr[from.decoder] ? CASE
                                              --{{{  Data-item NLC
                                              INT addr, size:
                                              -- Carrying: address;
                                              --           size
                                              data.item.nlc; addr; size
                                                SEQ
                                                  --{{{  IN message
                                                  IF
                                                    output.msgs
                                                      CLAIM int.msg.handle
                                                        SEQ
                                                          int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                          int.msg.handle[to.handler] ! msg.str; "/"
                                                          int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                          int.msg.handle[to.handler] ! msg.str; ": IN ext.dech: data.item.nlc; "
                                                          int.msg.handle[to.handler] ! msg.hex; addr
                                                          int.msg.handle[to.handler] ! msg.str; "; "
                                                          int.msg.handle[to.handler] ! msg.int; size
                                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                                    TRUE
                                                      SKIP
                                                  --}}}
                                                  -- Store address/size
                                                  addr.array[current.as.index] := addr
                                                  size.array[current.as.index] := size
                                                  current.as.index := current.as.index + 1
                                                  -- Update CLC-descriptor
                                                  clc.desc[current.clc.desc.index] := 0
                                                  current.clc.desc.index := current.clc.desc.index + 1
                                                  i := i + 1
                                              --}}}
                                              --{{{  Make CTB networked
                                              INT ctb.ptr, cli.state, svr.state, num.chans, num.readers.in.svr:
                                              -- Carrying: CTB-pointer;
                                              --           client-state (1 = unshared,
                                              --                         2 = shared/unclaimed, 3 = shared/claimed);
                                              --           server-state (1 = unshared,
                                              --                         2 = shared/unclaimed, 3 = shared/claimed);
                                              --           number of channel-words;
                                              --           number of reading-ends in server-end
                                              make.ctb.networked; ctb.ptr; cli.state; svr.state;
                                                                  num.chans; num.readers.in.svr
                                                INT nct.id:
                                                INITIAL BOOL initial.cli.claimed IS NOT (cli.state = PONYC.SHARETYPE.SHARED):
                                                INITIAL BOOL initial.svr.claimed IS NOT (svr.state = PONYC.SHARETYPE.SHARED):
                                                PONY.NETHOOKHANDLE! net.hook.handle:
                                                MOBILE []PONY.DECODEHANDLE! dec.handle.array:
                                                MOBILE []PONY.ENCODEHANDLE! enc.handle.array:
                                                SEQ
                                                  --{{{  IN message
                                                  IF
                                                    output.msgs
                                                      CLAIM int.msg.handle
                                                        SEQ
                                                          int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                          int.msg.handle[to.handler] ! msg.str; "/"
                                                          int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                          int.msg.handle[to.handler] ! msg.str; ": IN ext.dech: make.ctb.networked; "
                                                          int.msg.handle[to.handler] ! msg.hex; ctb.ptr
                                                          int.msg.handle[to.handler] ! msg.str; "; "
                                                          int.msg.handle[to.handler] ! msg.int; cli.state
                                                          int.msg.handle[to.handler] ! msg.str; "; "
                                                          int.msg.handle[to.handler] ! msg.int; svr.state
                                                          int.msg.handle[to.handler] ! msg.str; "; "
                                                          int.msg.handle[to.handler] ! msg.int; num.chans
                                                          int.msg.handle[to.handler] ! msg.str; "; "
                                                          int.msg.handle[to.handler] ! msg.int; num.readers.in.svr
                                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                                    TRUE
                                                      SKIP
                                                  --}}}
                                                  -- Send request to NCT-manager (via master-link-handle)
                                                  CLAIM master.link.handle
                                                    SEQ
                                                      --{{{  OUT message
                                                      IF
                                                        output.msgs
                                                          CLAIM int.msg.handle
                                                            SEQ
                                                              int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                              int.msg.handle[to.handler] ! msg.str; "/"
                                                              int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                              int.msg.handle[to.handler] ! msg.str; ": OUT linkh 0: fornctmgr.make.ctb.networked; "
                                                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                              int.msg.handle[to.handler] ! msg.str; "; "
                                                              int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                              int.msg.handle[to.handler] ! msg.str; "; "
                                                              int.msg.handle[to.handler] ! msg.bool; initial.cli.claimed
                                                              int.msg.handle[to.handler] ! msg.str; "; "
                                                              int.msg.handle[to.handler] ! msg.bool; initial.svr.claimed
                                                              int.msg.handle[to.handler] ! msg.end; FALSE
                                                        TRUE
                                                          SKIP
                                                      --}}}
                                                      -- Carrying: NCT-ID of the decode-handler making the request
                                                      --           channel-ID of the decode-handler making the request
                                                      --           client-end initially claimed?;
                                                      --           server-end initially claimed?
                                                      master.link.handle[to.handler] ! fornctmgr.make.ctb.networked;
                                                                                       own.nct.id; own.chan.id;
                                                                                       initial.cli.claimed;
                                                                                       initial.svr.claimed
                                                  -- Wait for reply (via decode-reply-handle)
                                                  -- Carrying: NCT-ID
                                                  dec.reply.handle.svr[to.handler] ? CASE make.ctb.networked.confirm; nct.id
                                                  --{{{  IN message
                                                  IF
                                                    output.msgs
                                                      CLAIM int.msg.handle
                                                        SEQ
                                                          int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                          int.msg.handle[to.handler] ! msg.str; "/"
                                                          int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                          int.msg.handle[to.handler] ! msg.str; ": IN decreplyh: make.ctb.networked.confirm; "
                                                          int.msg.handle[to.handler] ! msg.int; nct.id
                                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                                    TRUE
                                                      SKIP
                                                  --}}}
                                                  -- Send request to CTB-manager
                                                  CLAIM ctb.mgr.handle
                                                    SEQ
                                                      --{{{  OUT message
                                                      IF
                                                        output.msgs
                                                          CLAIM int.msg.handle
                                                            SEQ
                                                              int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                              int.msg.handle[to.handler] ! msg.str; "/"
                                                              int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                              int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: make.ctb.networked; "
                                                              int.msg.handle[to.handler] ! msg.int; nct.id
                                                              int.msg.handle[to.handler] ! msg.str; "; "
                                                              int.msg.handle[to.handler] ! msg.hex; ctb.ptr
                                                              int.msg.handle[to.handler] ! msg.str; "; "
                                                              int.msg.handle[to.handler] ! msg.bool; initial.cli.claimed
                                                              int.msg.handle[to.handler] ! msg.str; "; "
                                                              int.msg.handle[to.handler] ! msg.bool; initial.svr.claimed
                                                              int.msg.handle[to.handler] ! msg.str; "; "
                                                              int.msg.handle[to.handler] ! msg.int; num.chans
                                                              int.msg.handle[to.handler] ! msg.str; "; "
                                                              int.msg.handle[to.handler] ! msg.int; num.readers.in.svr
                                                              int.msg.handle[to.handler] ! msg.end; FALSE
                                                        TRUE
                                                          SKIP
                                                      --}}}
                                                      -- Carrying: NCT-ID;
                                                      --           CTB-pointer;
                                                      --           client-end initially claimed?;
                                                      --           server-end initially claimed?;
                                                      --           number of channel-words;
                                                      --           number of reading-ends in server-end
                                                      ctb.mgr.handle[to.mgr] ! make.ctb.networked; nct.id; ctb.ptr;
                                                                                                   initial.cli.claimed;
                                                                                                   initial.svr.claimed;
                                                                                                   num.chans;
                                                                                                   num.readers.in.svr
                                                      -- Wait for reply
                                                      -- Carrying: network-hook-handle;
                                                      --           array of decode-handles;
                                                      --           array of encode-handles
                                                      ctb.mgr.handle[from.mgr] ? CASE make.ctb.networked.confirm;
                                                                                      net.hook.handle;
                                                                                      dec.handle.array; enc.handle.array
                                                      --{{{  IN message
                                                      IF
                                                        output.msgs
                                                          CLAIM int.msg.handle
                                                            SEQ
                                                              int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                              int.msg.handle[to.handler] ! msg.str; "/"
                                                              int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                              int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: make.ctb.networked.confirm; [cli-end]; [array ("
                                                              int.msg.handle[to.handler] ! msg.int; SIZE dec.handle.array
                                                              int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                                                              int.msg.handle[to.handler] ! msg.int; SIZE enc.handle.array
                                                              int.msg.handle[to.handler] ! msg.str; ")]"
                                                              int.msg.handle[to.handler] ! msg.end; FALSE
                                                        TRUE
                                                          SKIP
                                                      --}}}
                                                  -- Send reply to decoder
                                                  --{{{  OUT message
                                                  IF
                                                    output.msgs
                                                      CLAIM int.msg.handle
                                                        SEQ
                                                          int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                          int.msg.handle[to.handler] ! msg.str; "/"
                                                          int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                          int.msg.handle[to.handler] ! msg.str; ": OUT ext.dech: make.ctb.networked.confirm; "
                                                          int.msg.handle[to.handler] ! msg.int; nct.id
                                                          int.msg.handle[to.handler] ! msg.str; "; [cli-end]; [array ("
                                                          int.msg.handle[to.handler] ! msg.int; SIZE dec.handle.array
                                                          int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                                                          int.msg.handle[to.handler] ! msg.int; SIZE enc.handle.array
                                                          int.msg.handle[to.handler] ! msg.str; ")]"
                                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                                    TRUE
                                                      SKIP
                                                  --}}}
                                                  -- Carrying: NCT-ID;
                                                  --           network-hook-handle;
                                                  --           array of decode-handles;
                                                  --           array of encode-handles
                                                  dec.handle.svr[to.decoder] ! make.ctb.networked.confirm;
                                                                               nct.id; net.hook.handle;
                                                                               dec.handle.array; enc.handle.array
                                              --}}}
                                              --{{{  Channel-type-end NLC
                                              INT nct.id, dir.type, share.type:
                                              -- Carrying: NCT-ID;
                                              --           direction-type of the end to be sent
                                              --             (0 = client-end, 1 = server-end);
                                              --           share-type of the end to be sent
                                              --             (1 = unshared, 2 = shared)
                                              ct.end.nlc; nct.id; dir.type; share.type
                                                SEQ
                                                  --{{{  IN message
                                                  IF
                                                    output.msgs
                                                      CLAIM int.msg.handle
                                                        SEQ
                                                          int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                          int.msg.handle[to.handler] ! msg.str; "/"
                                                          int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                          int.msg.handle[to.handler] ! msg.str; ": IN ext.dech: ct.end.nlc; "
                                                          int.msg.handle[to.handler] ! msg.int; nct.id
                                                          int.msg.handle[to.handler] ! msg.str; "; "
                                                          int.msg.handle[to.handler] ! msg.int; dir.type
                                                          int.msg.handle[to.handler] ! msg.str; "; "
                                                          int.msg.handle[to.handler] ! msg.int; share.type
                                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                                    TRUE
                                                      SKIP
                                                  --}}}
                                                  --{{{  Internal-release preparations
                                                  IF
                                                    -- Shared end
                                                    share.type = PONYC.SHARETYPE.SHARED
                                                      SKIP
                                                    -- Unshared end of own CTB
                                                    nct.id = own.nct.id
                                                      sending.end.over.itself := TRUE
                                                    -- Unshared end of other CTB
                                                    TRUE
                                                      -- Internal-release the end
                                                      SHARED PONY.INT.CTBCLAIMHANDLE! ctb.claim.handle:
                                                      SEQ
                                                        CLAIM ctb.mgr.handle
                                                          SEQ
                                                            -- Get CTB-claim-handle from CTB-manager
                                                            --{{{  OUT message
                                                            IF
                                                              output.msgs
                                                                CLAIM int.msg.handle
                                                                  SEQ
                                                                    int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                                    int.msg.handle[to.handler] ! msg.str; "/"
                                                                    int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.claim.handle; "
                                                                    int.msg.handle[to.handler] ! msg.int; nct.id
                                                                    int.msg.handle[to.handler] ! msg.str; "; "
                                                                    int.msg.handle[to.handler] ! msg.int; dir.type
                                                                    int.msg.handle[to.handler] ! msg.end; FALSE
                                                              TRUE
                                                                SKIP
                                                            --}}}
                                                            -- Carrying: NCT-ID;
                                                            --           direction-type of the end to be claimed/released
                                                            --             (0 = client-end, 1 = server-end)
                                                            ctb.mgr.handle[to.mgr] ! get.ctb.claim.handle; nct.id; dir.type
                                                            -- Get reply
                                                            -- Carrying: CTB-claim-handle
                                                            ctb.mgr.handle[from.mgr] ? CASE get.ctb.claim.handle.confirm; ctb.claim.handle
                                                            --{{{  IN message
                                                            IF
                                                              output.msgs
                                                                CLAIM int.msg.handle
                                                                  SEQ
                                                                    int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                                    int.msg.handle[to.handler] ! msg.str; "/"
                                                                    int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                                    int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.claim.handle.confirm; [cli-end]"
                                                                    int.msg.handle[to.handler] ! msg.end; FALSE
                                                              TRUE
                                                                SKIP
                                                            --}}}
                                                        CLAIM ctb.claim.handle
                                                          SEQ
                                                            --{{{  OUT message
                                                            IF
                                                              output.msgs
                                                                CLAIM int.msg.handle
                                                                  SEQ
                                                                    int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                                    int.msg.handle[to.handler] ! msg.str; "/"
                                                                    int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbclaimh "
                                                                    int.msg.handle[to.handler] ! msg.int; nct.id
                                                                    int.msg.handle[to.handler] ! msg.str; "/"
                                                                    int.msg.handle[to.handler] ! msg.int; dir.type
                                                                    int.msg.handle[to.handler] ! msg.str; ": release"
                                                                    int.msg.handle[to.handler] ! msg.end; FALSE
                                                              TRUE
                                                                SKIP
                                                            --}}}
                                                            ctb.claim.handle[to.handler] ! release
                                                  --}}}
                                                  --{{{  Update CLC-descriptor
                                                  -- Bit 1: channel-type-end CLC (1)
                                                  clc.desc[current.clc.desc.index] := 1
                                                  -- Bit 2: direction-type (0 = client-end, 1 = server-end)
                                                  IF
                                                    dir.type = PONYC.INT.DIRTYPE.SVR
                                                      clc.desc[current.clc.desc.index] := clc.desc[current.clc.desc.index] \/ 2
                                                    TRUE
                                                      SKIP
                                                  -- Bit 3: share-type (1 = unshared, 0 = shared (IMPORTANT: different from
                                                  --   `PONYC.SHARETYPE.SHARED' in order to fit it into one bit))
                                                  IF
                                                    share.type = PONYC.SHARETYPE.UNSHARED
                                                      clc.desc[current.clc.desc.index] := clc.desc[current.clc.desc.index] \/ 4
                                                    TRUE
                                                      SKIP
                                                  -- Store NCT-ID in the next BYTESIN (INT) bytes
                                                  []BYTE nct.id.array RETYPES nct.id:
                                                  [clc.desc FROM current.clc.desc.index + 1 FOR BYTESIN (INT)] := nct.id.array
                                                  -- Update index
                                                  current.clc.desc.index := current.clc.desc.index + (1 + BYTESIN (INT))
                                                  --}}}
                                                  i := i + 1
                                              --}}}
                                      --}}}
                                    -- Output `rest.clcs' to CTB-handler
                                    --{{{  OUT message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                                            int.msg.handle[to.handler] ! msg.str; "/"
                                            int.msg.handle[to.handler] ! msg.int; own.chan.id
                                            int.msg.handle[to.handler] ! msg.str; ": OUT int.dech: rest.clcs; "
                                            int.msg.handle[to.handler] ! msg.int; di.nlcs.rest
                                            int.msg.handle[to.handler] ! msg.str; "; "
                                            int.msg.handle[to.handler] ! msg.int; cte.nlcs.rest
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    -- Carrying: number of data-item NLCs in remaining CLCs;
                                    --           number of channel-type-end NLCs in remaining CLCs
                                    int.dec.handle.svr[from.handler] ! rest.clcs;
                                                                       di.nlcs.rest; cte.nlcs.rest
                                    -- Check whether remaining CLCs contain an end-over-itself-CLC
                                    IF
                                      sending.end.over.itself
                                        SEQ
                                          -- Notify CTB-handler
                                          --{{{  OUT message
                                          IF
                                            output.msgs
                                              CLAIM int.msg.handle
                                                SEQ
                                                  int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                  int.msg.handle[to.handler] ! msg.str; "/"
                                                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                  int.msg.handle[to.handler] ! msg.str; ": OUT int.dech: end.over.itself.clc"
                                                  int.msg.handle[to.handler] ! msg.end; FALSE
                                            TRUE
                                              SKIP
                                          --}}}
                                          int.dec.handle.svr[from.handler] ! end.over.itself.clc
                                      TRUE
                                        SKIP
                                    -- Output remaining CLCs to CTB-handler
                                    --{{{  OUT message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                                            int.msg.handle[to.handler] ! msg.str; "/"
                                            int.msg.handle[to.handler] ! msg.int; own.chan.id
                                            int.msg.handle[to.handler] ! msg.str; ": OUT int.dech: clc; [array ("
                                            int.msg.handle[to.handler] ! msg.int; SIZE addr.array
                                            int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                                            int.msg.handle[to.handler] ! msg.int; SIZE size.array
                                            int.msg.handle[to.handler] ! msg.str; ")]"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    -- Carrying: address-array;
                                    --           size-array
                                    int.dec.handle.svr[from.handler] ! clc; addr.array; size.array
                                    -- Get remote ack
                                    int.dec.handle.svr[to.handler] ? CASE ack
                                    --{{{  IN message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                                            int.msg.handle[to.handler] ! msg.str; "/"
                                            int.msg.handle[to.handler] ! msg.int; own.chan.id
                                            int.msg.handle[to.handler] ! msg.str; ": IN int.dech: ack"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    -- Pass ack on to decoder
                                    --{{{  OUT message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                                            int.msg.handle[to.handler] ! msg.str; "/"
                                            int.msg.handle[to.handler] ! msg.int; own.chan.id
                                            int.msg.handle[to.handler] ! msg.str; ": OUT ext.dech: ack"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    dec.handle.svr[to.decoder] ! ack
                                TRUE
                                  SKIP
                              --}}}
                          --}}}
                    --}}}
                  --}}}
              --}}}
      --}}}
      --{{{  Cancel encode
      cancel.encode
        SEQ
          --{{{  IN message
          IF
            output.msgs
              CLAIM int.msg.handle
                SEQ
                  int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                  int.msg.handle[to.handler] ! msg.str; "/"
                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                  int.msg.handle[to.handler] ! msg.str; ": IN int.dech: cancel.encode"
                  int.msg.handle[to.handler] ! msg.end; FALSE
            TRUE
              SKIP
          --}}}
          -- Send message to decoder
          --{{{  OUT message
          IF
            output.msgs
              CLAIM int.msg.handle
                SEQ
                  int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                  int.msg.handle[to.handler] ! msg.str; "/"
                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                  int.msg.handle[to.handler] ! msg.str; ": OUT ext.dech: cancel.encode"
                  int.msg.handle[to.handler] ! msg.end; FALSE
            TRUE
              SKIP
          --}}}
          dec.handle.svr[to.decoder] ! cancel.encode
          -- Wait for acknowledgement signal
          int.dec.handle.svr[to.handler] ? CASE cancel.encode.ack
          --{{{  IN message
          IF
            output.msgs
              CLAIM int.msg.handle
                SEQ
                  int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                  int.msg.handle[to.handler] ! msg.str; "/"
                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                  int.msg.handle[to.handler] ! msg.str; ": IN int.dech: cancel.encode.ack"
                  int.msg.handle[to.handler] ! msg.end; FALSE
            TRUE
              SKIP
          --}}}
          -- Send acknowledgement to decoder
          --{{{  OUT message
          IF
            output.msgs
              CLAIM int.msg.handle
                SEQ
                  int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                  int.msg.handle[to.handler] ! msg.str; "/"
                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                  int.msg.handle[to.handler] ! msg.str; ": OUT ext.dech: cancel.encode.ack"
                  int.msg.handle[to.handler] ! msg.end; FALSE
            TRUE
              SKIP
          --}}}
          dec.handle.svr[to.decoder] ! cancel.encode.ack
          -- Get reply from decoder
          dec.handle.svr[from.decoder] ? CASE
            encode.cancelled
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; "/"
                        int.msg.handle[to.handler] ! msg.int; own.chan.id
                        int.msg.handle[to.handler] ! msg.str; ": IN ext.dech: encode.cancelled"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                -- Pass reply on
                --{{{  OUT message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; "/"
                        int.msg.handle[to.handler] ! msg.int; own.chan.id
                        int.msg.handle[to.handler] ! msg.str; ": OUT int.dech: encode.cancelled"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                int.dec.handle.svr[from.handler] ! encode.cancelled
            encode.not.cancelled
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; "/"
                        int.msg.handle[to.handler] ! msg.int; own.chan.id
                        int.msg.handle[to.handler] ! msg.str; ": IN ext.dech: encode.not.cancelled"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                -- Pass reply on
                --{{{  OUT message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; "/"
                        int.msg.handle[to.handler] ! msg.int; own.chan.id
                        int.msg.handle[to.handler] ! msg.str; ": OUT int.dech: encode.not.cancelled"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                int.dec.handle.svr[from.handler] ! encode.not.cancelled
      --}}}
      --{{{  Shutdown
      shutdown
        SEQ
          --{{{  IN message
          IF
            output.msgs
              CLAIM int.msg.handle
                SEQ
                  int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                  int.msg.handle[to.handler] ! msg.str; "/"
                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                  int.msg.handle[to.handler] ! msg.str; ": IN int.dech: shutdown"
                  int.msg.handle[to.handler] ! msg.end; FALSE
            TRUE
              SKIP
          --}}}
          -- Terminate decoder
          --{{{  OUT message
          IF
            output.msgs
              CLAIM int.msg.handle
                SEQ
                  int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                  int.msg.handle[to.handler] ! msg.str; "/"
                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                  int.msg.handle[to.handler] ! msg.str; ": OUT ext.dech: term"
                  int.msg.handle[to.handler] ! msg.end; FALSE
            TRUE
              SKIP
          --}}}
          dec.handle.svr[to.decoder] ! term
          -- Leave main loop
          running := FALSE
          -- Send reply
          --{{{  OUT message
          IF
            output.msgs
              CLAIM int.msg.handle
                SEQ
                  int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                  int.msg.handle[to.handler] ! msg.str; "/"
                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                  int.msg.handle[to.handler] ! msg.str; ": OUT int.dech: shutdown.confirm"
                  int.msg.handle[to.handler] ! msg.end; FALSE
            TRUE
              SKIP
          --}}}
          int.dec.handle.svr[from.handler] ! shutdown.confirm
      --}}}
:
--}}}
--{{{  PROC pony.int.enc.handler
-- Encode-handler
-- Parameters: own.nct.id         | VAL: own NCT-ID
--             own.chan.id        | VAL: index of own channel-word
--             enc.handle.svr     | server-end of encode-handle
--             int.enc.handle.svr | server-end of internal encode-handle
--             ctb.mgr.handle     | CTB-manager-handle (client-end)
--             output.msgs        | VAL: output messages?
--             int.msg.handle     | internal message-handle (client-end)
PROC pony.int.enc.handler (VAL INT own.nct.id, own.chan.id,
                           PONY.ENCODEHANDLE? enc.handle.svr,
                           PONY.INT.ENCODEHANDLE? int.enc.handle.svr,
                           SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle,
                           VAL BOOL output.msgs,
                           SHARED PONY.INT.MSGHANDLE! int.msg.handle)
  INITIAL BOOL running IS TRUE:
  WHILE running
    int.enc.handle.svr[to.handler] ? CASE
      --{{{  Get first CLC of next ULC from CTB-handler
      INT di.nlcs.first, cte.nlcs.first:
      BOOL has.rest.clcs:
      -- Carrying: number of data-item NLCs in first CLC;
      --           number of channel-type-end NLCs in first CLC;
      --           are there remaining CLCs?
      first.clc; di.nlcs.first; cte.nlcs.first; has.rest.clcs
        MOBILE []BYTE data.array:
        MOBILE []INT size.array:
        MOBILE []BYTE clc.desc.first, clc.desc.rest:
        INITIAL BOOL was.cancelled IS FALSE:
        INT di.nlcs.rest, cte.nlcs.rest:
        SEQ
          --{{{  IN message
          IF
            output.msgs
              CLAIM int.msg.handle
                SEQ
                  int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                  int.msg.handle[to.handler] ! msg.str; "/"
                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                  int.msg.handle[to.handler] ! msg.str; ": IN int.ench: first.clc; "
                  int.msg.handle[to.handler] ! msg.int; di.nlcs.first
                  int.msg.handle[to.handler] ! msg.str; "; "
                  int.msg.handle[to.handler] ! msg.int; cte.nlcs.first
                  int.msg.handle[to.handler] ! msg.str; "; "
                  int.msg.handle[to.handler] ! msg.bool; has.rest.clcs
                  int.msg.handle[to.handler] ! msg.end; FALSE
            TRUE
              SKIP
          --}}}
          -- Pass `first.clc' on to encoder
          --{{{  OUT message
          IF
            output.msgs
              CLAIM int.msg.handle
                SEQ
                  int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                  int.msg.handle[to.handler] ! msg.str; "/"
                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                  int.msg.handle[to.handler] ! msg.str; ": OUT ext.ench: first.clc; "
                  int.msg.handle[to.handler] ! msg.int; di.nlcs.first
                  int.msg.handle[to.handler] ! msg.str; "; "
                  int.msg.handle[to.handler] ! msg.int; cte.nlcs.first
                  int.msg.handle[to.handler] ! msg.str; "; "
                  int.msg.handle[to.handler] ! msg.bool; has.rest.clcs
                  int.msg.handle[to.handler] ! msg.end; FALSE
            TRUE
              SKIP
          --}}}
          -- Carrying: number of data-item NLCs in first CLC;
          --           number of channel-type-end NLCs in first CLC;
          --           are there remaining CLCs?
          enc.handle.svr[to.encoder] ! first.clc;
                                       di.nlcs.first; cte.nlcs.first;
                                       has.rest.clcs
          --{{{  Get first CLC from CTB-handler
          -- Carrying: data-array;
          --           size-array
          int.enc.handle.svr[to.handler] ? CASE clc; data.array; size.array
          --{{{  IN message
          IF
            output.msgs
              CLAIM int.msg.handle
                SEQ
                  int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                  int.msg.handle[to.handler] ! msg.str; "/"
                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                  int.msg.handle[to.handler] ! msg.str; ": IN int.ench: clc; [array ("
                  int.msg.handle[to.handler] ! msg.int; SIZE data.array
                  int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                  int.msg.handle[to.handler] ! msg.int; SIZE size.array
                  int.msg.handle[to.handler] ! msg.str; ")]"
                  int.msg.handle[to.handler] ! msg.end; FALSE
            TRUE
              SKIP
          --}}}
          IF
            --{{{  No channel-type-end NLCs in first CLC
            cte.nlcs.first = 0
              -- Send all NLCs of first CLC to encoder
              INITIAL INT nlc.start.index IS 0:
              MOBILE []BYTE nlc.data.array:
              INT addr, size:
              SEQ i = 0 FOR di.nlcs.first
                SEQ
                  -- Get NLC-data-array
                  IF
                    di.nlcs.first = 1
                      nlc.data.array := data.array
                    TRUE
                      SEQ
                        nlc.data.array := MOBILE [size.array[i]]BYTE
                        [nlc.data.array FOR size.array[i]] := [data.array FROM nlc.start.index FOR size.array[i]]
                        nlc.start.index := nlc.start.index + size.array[i]
                  -- Detach NLC-data-array
                  DETACH.DYNMOB (nlc.data.array, addr, size)
                  -- Data-item NLC
                  --{{{  OUT message
                  IF
                    output.msgs
                      CLAIM int.msg.handle
                        SEQ
                          int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                          int.msg.handle[to.handler] ! msg.str; "/"
                          int.msg.handle[to.handler] ! msg.int; own.chan.id
                          int.msg.handle[to.handler] ! msg.str; ": OUT ext.ench: data.item.nlc; "
                          int.msg.handle[to.handler] ! msg.hex; addr
                          int.msg.handle[to.handler] ! msg.str; "; "
                          int.msg.handle[to.handler] ! msg.int; size
                          int.msg.handle[to.handler] ! msg.end; FALSE
                    TRUE
                      SKIP
                  --}}}
                  -- Carrying: address;
                  --           size
                  enc.handle.svr[to.encoder] ! data.item.nlc; addr; size
            --}}}
            --{{{  There are channel-type-end NLCs in first CLC
            TRUE
              SEQ
                --{{{  Get CLC-descriptor
                IF
                  di.nlcs.first = 0
                    SEQ
                      clc.desc.first := data.array
                      -- Without next line compiler complains when doing `DETACH.DYNMOB'
                      --   (compiler does not know that with `di.nlcs.first' being zero,
                      --   no data-item NLCs can happen, and with `DETACH.DYNMOB' the
                      --   undefinedness-checker produces an error rather than a warning)
                      data.array := ""
                  TRUE
                    SEQ
                      clc.desc.first := MOBILE [size.array[di.nlcs.first]]BYTE
                      [clc.desc.first FOR size.array[di.nlcs.first]] :=
                        [data.array FROM ((SIZE data.array) - size.array[di.nlcs.first])]
                --}}}
                -- Send all NLCs of first CLC to encoder
                INITIAL INT nlc.start.index IS 0:
                INITIAL INT current.size.index IS 0:
                INITIAL INT current.clc.desc.index IS 0:
                WHILE current.clc.desc.index < (SIZE clc.desc.first)
                  IF
                    --{{{  Data-item NLC
                    clc.desc.first[current.clc.desc.index] = 0
                      MOBILE []BYTE nlc.data.array:
                      INT addr, size:
                      SEQ
                        -- Get NLC-data-array
                        nlc.data.array := MOBILE [size.array[current.size.index]]BYTE
                        [nlc.data.array FOR size.array[current.size.index]] :=
                          [data.array FROM nlc.start.index FOR size.array[current.size.index]]
                        nlc.start.index := nlc.start.index + size.array[current.size.index]
                        current.size.index := current.size.index + 1
                        -- Detach NLC-data-array
                        DETACH.DYNMOB (nlc.data.array, addr, size)
                        -- Data-item NLC
                        --{{{  OUT message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; "/"
                                int.msg.handle[to.handler] ! msg.int; own.chan.id
                                int.msg.handle[to.handler] ! msg.str; ": OUT ext.ench: data.item.nlc; "
                                int.msg.handle[to.handler] ! msg.hex; addr
                                int.msg.handle[to.handler] ! msg.str; "; "
                                int.msg.handle[to.handler] ! msg.int; size
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        -- Carrying: address;
                        --           size
                        enc.handle.svr[to.encoder] ! data.item.nlc; addr; size
                        -- Update CLC-descriptor index
                        current.clc.desc.index := current.clc.desc.index + 1
                    --}}}
                    --{{{  Channel-type-end NLC
                    TRUE
                      INITIAL [BYTESIN (INT)]BYTE nct.id.array IS [clc.desc.first FROM current.clc.desc.index + 1 FOR BYTESIN (INT)]:
                      INT nct.id RETYPES nct.id.array:
                      SEQ
                        -- Send request to CTB-manager
                        CLAIM ctb.mgr.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                    int.msg.handle[to.handler] ! msg.str; "/"
                                    int.msg.handle[to.handler] ! msg.int; own.chan.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: alloc.ct.end; "
                                    int.msg.handle[to.handler] ! msg.int; nct.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID
                            ctb.mgr.handle[to.mgr] ! alloc.ct.end; nct.id
                            -- Wait for reply
                            ctb.mgr.handle[from.mgr] ? CASE
                              --{{{  Increase reference-count of CTB
                              INT ctb.ptr:
                              -- Carrying: CTB-pointer
                              clone.ctb; ctb.ptr
                                SEQ
                                  --{{{  IN message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                          int.msg.handle[to.handler] ! msg.str; "/"
                                          int.msg.handle[to.handler] ! msg.int; own.chan.id
                                          int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: clone.ctb; "
                                          int.msg.handle[to.handler] ! msg.hex; ctb.ptr
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                                  -- Pass message on to encoder
                                  --{{{  OUT message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                          int.msg.handle[to.handler] ! msg.str; "/"
                                          int.msg.handle[to.handler] ! msg.int; own.chan.id
                                          int.msg.handle[to.handler] ! msg.str; ": OUT ext.ench: clone.ctb; "
                                          int.msg.handle[to.handler] ! msg.hex; ctb.ptr
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                                  -- Carrying: CTB-pointer
                                  enc.handle.svr[to.encoder] ! clone.ctb; ctb.ptr
                              --}}}
                              --{{{  Allocate new CTB
                              alloc.new.ctb
                                INT ctb.ptr, num.chans, num.readers.in.svr:
                                PONY.NETHOOKHANDLE! net.hook.handle:
                                MOBILE []PONY.DECODEHANDLE! dec.handle.array:
                                MOBILE []PONY.ENCODEHANDLE! enc.handle.array:
                                SEQ
                                  --{{{  IN message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                          int.msg.handle[to.handler] ! msg.str; "/"
                                          int.msg.handle[to.handler] ! msg.int; own.chan.id
                                          int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: alloc.new.ctb"
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                                  -- Pass message on to encoder
                                  --{{{  OUT message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                          int.msg.handle[to.handler] ! msg.str; "/"
                                          int.msg.handle[to.handler] ! msg.int; own.chan.id
                                          int.msg.handle[to.handler] ! msg.str; ": OUT ext.ench: alloc.new.ctb; "
                                          int.msg.handle[to.handler] ! msg.int; nct.id
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                                  -- Carrying: NCT-ID
                                  enc.handle.svr[to.encoder] ! alloc.new.ctb; nct.id
                                  -- Wait for reply
                                  -- Carrying: CTB-pointer;
                                  --           number of channel-words in CTB;
                                  --           number of reading-ends in server-end
                                  enc.handle.svr[from.encoder] ? CASE alloc.new.ctb.confirm; ctb.ptr;
                                                                      num.chans; num.readers.in.svr
                                  --{{{  IN message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                          int.msg.handle[to.handler] ! msg.str; "/"
                                          int.msg.handle[to.handler] ! msg.int; own.chan.id
                                          int.msg.handle[to.handler] ! msg.str; ": IN ext.ench: alloc.new.ctb.confirm; "
                                          int.msg.handle[to.handler] ! msg.hex; ctb.ptr
                                          int.msg.handle[to.handler] ! msg.str; "; "
                                          int.msg.handle[to.handler] ! msg.int; num.chans
                                          int.msg.handle[to.handler] ! msg.str; "; "
                                          int.msg.handle[to.handler] ! msg.int; num.readers.in.svr
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                                  -- Pass channel-counts on to CTB-manager
                                  --{{{  OUT message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                          int.msg.handle[to.handler] ! msg.str; "/"
                                          int.msg.handle[to.handler] ! msg.int; own.chan.id
                                          int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: alloc.new.ctb.confirm.chancounts; "
                                          int.msg.handle[to.handler] ! msg.int; num.chans
                                          int.msg.handle[to.handler] ! msg.str; "; "
                                          int.msg.handle[to.handler] ! msg.int; num.readers.in.svr
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                                  -- Carrying: number of channel-words in CTB;
                                  --           number of reading-ends in server-end
                                  ctb.mgr.handle[to.mgr] ! alloc.new.ctb.confirm.chancounts;
                                                           num.chans; num.readers.in.svr
                                  -- Wait for reply
                                  -- Carrying: network-hook-handle;
                                  --           array of decode-handles;
                                  --           array of encode-handles
                                  ctb.mgr.handle[from.mgr] ? CASE alloc.new.ctb.confirm;
                                                                  net.hook.handle;
                                                                  dec.handle.array; enc.handle.array
                                  --{{{  IN message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                          int.msg.handle[to.handler] ! msg.str; "/"
                                          int.msg.handle[to.handler] ! msg.int; own.chan.id
                                          int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: alloc.new.ctb.confirm; [cli-end]; [array ("
                                          int.msg.handle[to.handler] ! msg.int; SIZE dec.handle.array
                                          int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                                          int.msg.handle[to.handler] ! msg.int; SIZE enc.handle.array
                                          int.msg.handle[to.handler] ! msg.str; ")]"
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                                  -- Pass message on to encoder
                                  --{{{  OUT message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                          int.msg.handle[to.handler] ! msg.str; "/"
                                          int.msg.handle[to.handler] ! msg.int; own.chan.id
                                          int.msg.handle[to.handler] ! msg.str; ": OUT ext.ench: alloc.new.ctb.confirm; [cli-end]; [array ("
                                          int.msg.handle[to.handler] ! msg.int; SIZE dec.handle.array
                                          int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                                          int.msg.handle[to.handler] ! msg.int; SIZE enc.handle.array
                                          int.msg.handle[to.handler] ! msg.str; ")]"
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                                  -- Carrying: network-hook-handle;
                                  --           array of decode-handles;
                                  --           array of encode-handles
                                  enc.handle.svr[to.encoder] ! alloc.new.ctb.confirm;
                                                               net.hook.handle;
                                                               dec.handle.array; enc.handle.array
                                  -- Pass CTB-pointer on to CTB-manager
                                  --{{{  OUT message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                          int.msg.handle[to.handler] ! msg.str; "/"
                                          int.msg.handle[to.handler] ! msg.int; own.chan.id
                                          int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: alloc.new.ctb.confirm.ctbptr; "
                                          int.msg.handle[to.handler] ! msg.hex; ctb.ptr
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                                  -- Carrying: CTB-pointer
                                  ctb.mgr.handle[to.mgr] ! alloc.new.ctb.confirm.ctbptr; ctb.ptr
                              --}}}
                        -- Update CLC-descriptor index
                        current.clc.desc.index := current.clc.desc.index + (1 + BYTESIN (INT))
                    --}}}
            --}}}
          -- Wait for `ack' from encoder
          enc.handle.svr[from.encoder] ? CASE ack
          --{{{  IN message
          IF
            output.msgs
              CLAIM int.msg.handle
                SEQ
                  int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                  int.msg.handle[to.handler] ! msg.str; "/"
                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                  int.msg.handle[to.handler] ! msg.str; ": IN ext.ench: ack"
                  int.msg.handle[to.handler] ! msg.end; FALSE
            TRUE
              SKIP
          --}}}
          -- Pass `ack' on to CTB-handler
          --{{{  OUT message
          IF
            output.msgs
              CLAIM int.msg.handle
                SEQ
                  int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                  int.msg.handle[to.handler] ! msg.str; "/"
                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                  int.msg.handle[to.handler] ! msg.str; ": OUT int.ench: ack"
                  int.msg.handle[to.handler] ! msg.end; FALSE
            TRUE
              SKIP
          --}}}
          int.enc.handle.svr[from.handler] ! ack
          --}}}
          --{{{  Wait for next message from CTB-handler
          int.enc.handle.svr[to.handler] ? CASE
            --{{{  Cancel session
            --       (first CLC was `cancel.encode'ed
            --       (both possible whether ULC has one and more CLCs))
            cancel.session
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; "/"
                        int.msg.handle[to.handler] ! msg.int; own.chan.id
                        int.msg.handle[to.handler] ! msg.str; ": IN int.ench: cancel.session"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                was.cancelled := TRUE
                IF
                  has.rest.clcs
                    SEQ
                      -- Cancel session in encoder
                      --{{{  OUT message
                      IF
                        output.msgs
                          CLAIM int.msg.handle
                            SEQ
                              int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                              int.msg.handle[to.handler] ! msg.str; "/"
                              int.msg.handle[to.handler] ! msg.int; own.chan.id
                              int.msg.handle[to.handler] ! msg.str; ": OUT ext.ench: cancel"
                              int.msg.handle[to.handler] ! msg.end; FALSE
                        TRUE
                          SKIP
                      --}}}
                      enc.handle.svr[to.encoder] ! cancel
                  TRUE
                    SKIP
            --}}}
            --{{{  There is just one CLC, which was outputted successfully
            output.successful
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; "/"
                        int.msg.handle[to.handler] ! msg.int; own.chan.id
                        int.msg.handle[to.handler] ! msg.str; ": IN int.ench: output.successful"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                cte.nlcs.rest := 0
            --}}}
            --{{{  Get remaining CLCs from CTB-handler
            --       (only possible if there is more than one CLC and first CLC was
            --       outputted successfully)
            -- Carrying: number of data-item NLCs in remaining CLCs;
            --           number of channel-type-end NLCs in remaining CLCs
            rest.clcs; di.nlcs.rest; cte.nlcs.rest
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; "/"
                        int.msg.handle[to.handler] ! msg.int; own.chan.id
                        int.msg.handle[to.handler] ! msg.str; ": IN int.ench: rest.clcs; "
                        int.msg.handle[to.handler] ! msg.int; di.nlcs.rest
                        int.msg.handle[to.handler] ! msg.str; "; "
                        int.msg.handle[to.handler] ! msg.int; cte.nlcs.rest
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                -- Pass `rest.clcs' on to encoder
                --{{{  OUT message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; "/"
                        int.msg.handle[to.handler] ! msg.int; own.chan.id
                        int.msg.handle[to.handler] ! msg.str; ": OUT ext.ench: rest.clcs; "
                        int.msg.handle[to.handler] ! msg.int; di.nlcs.rest
                        int.msg.handle[to.handler] ! msg.str; "; "
                        int.msg.handle[to.handler] ! msg.int; cte.nlcs.rest
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                -- Carrying: number of data-item NLCs in remaining CLCs;
                --           number of channel-type-end NLCs in remaining CLCs
                enc.handle.svr[to.encoder] ! rest.clcs;
                                             di.nlcs.rest; cte.nlcs.rest
                -- Get remaining CLCs
                -- Carrying: data-array;
                --           size-array
                int.enc.handle.svr[to.handler] ? CASE clc; data.array; size.array
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; "/"
                        int.msg.handle[to.handler] ! msg.int; own.chan.id
                        int.msg.handle[to.handler] ! msg.str; ": IN int.ench: clc; [array ("
                        int.msg.handle[to.handler] ! msg.int; SIZE data.array
                        int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                        int.msg.handle[to.handler] ! msg.int; SIZE size.array
                        int.msg.handle[to.handler] ! msg.str; ")]"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                IF
                  --{{{  No channel-type-end NLCs in remaining CLCs
                  cte.nlcs.rest = 0
                    -- Send all NLCs of remaining CLCs to encoder
                    INITIAL INT nlc.start.index IS 0:
                    MOBILE []BYTE nlc.data.array:
                    INT addr, size:
                    SEQ i = 0 FOR di.nlcs.rest
                      SEQ
                        -- Get NLC-data-array
                        IF
                          di.nlcs.rest = 1
                            nlc.data.array := data.array
                          TRUE
                            SEQ
                              nlc.data.array := MOBILE [size.array[i]]BYTE
                              [nlc.data.array FOR size.array[i]] :=
                                [data.array FROM nlc.start.index FOR size.array[i]]
                              nlc.start.index := nlc.start.index + size.array[i]
                        -- Detach NLC-data-array
                        DETACH.DYNMOB (nlc.data.array, addr, size)
                        -- Data-item NLC
                        --{{{  OUT message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; "/"
                                int.msg.handle[to.handler] ! msg.int; own.chan.id
                                int.msg.handle[to.handler] ! msg.str; ": OUT ext.ench: data.item.nlc; "
                                int.msg.handle[to.handler] ! msg.hex; addr
                                int.msg.handle[to.handler] ! msg.str; "; "
                                int.msg.handle[to.handler] ! msg.int; size
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        -- Carrying: address;
                        --           size
                        enc.handle.svr[to.encoder] ! data.item.nlc; addr; size
                  --}}}
                  --{{{  There are channel-type-end NLCs in remaining CLCs
                  TRUE
                    SEQ
                      --{{{  Get CLC-descriptor
                      IF
                        di.nlcs.rest = 0
                          SEQ
                            clc.desc.rest := data.array
                            -- Without next line compiler complains when doing `DETACH.DYNMOB'
                            --   (compiler does not know that with `di.nlcs.rest' being zero,
                            --   no data-item NLCs can happen, and with `DETACH.DYNMOB' the
                            --   undefinedness-checker produces an error rather than a warning)
                            data.array := ""
                        TRUE
                          SEQ
                            clc.desc.rest := MOBILE [size.array[di.nlcs.rest]]BYTE
                            [clc.desc.rest FOR size.array[di.nlcs.rest]] :=
                              [data.array FROM ((SIZE data.array) - size.array[di.nlcs.rest])]
                      --}}}
                      -- Send all NLCs of remaining CLCs to encoder
                      INITIAL INT nlc.start.index IS 0:
                      INITIAL INT current.size.index IS 0:
                      INITIAL INT current.clc.desc.index IS 0:
                      WHILE current.clc.desc.index < (SIZE clc.desc.rest)
                        IF
                          --{{{  Data-item NLC
                          clc.desc.rest[current.clc.desc.index] = 0
                            MOBILE []BYTE nlc.data.array:
                            INT addr, size:
                            SEQ
                              -- Get NLC-data-array
                              nlc.data.array := MOBILE [size.array[current.size.index]]BYTE
                              [nlc.data.array FOR size.array[current.size.index]] :=
                                [data.array FROM nlc.start.index FOR size.array[current.size.index]]
                              nlc.start.index := nlc.start.index + size.array[current.size.index]
                              current.size.index := current.size.index + 1
                              -- Detach NLC-data-array
                              DETACH.DYNMOB (nlc.data.array, addr, size)
                              -- Data-item NLC
                              --{{{  OUT message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; own.nct.id
                                      int.msg.handle[to.handler] ! msg.str; "/"
                                      int.msg.handle[to.handler] ! msg.int; own.chan.id
                                      int.msg.handle[to.handler] ! msg.str; ": OUT ext.ench: data.item.nlc; "
                                      int.msg.handle[to.handler] ! msg.hex; addr
                                      int.msg.handle[to.handler] ! msg.str; "; "
                                      int.msg.handle[to.handler] ! msg.int; size
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              -- Carrying: address;
                              --           size
                              enc.handle.svr[to.encoder] ! data.item.nlc; addr; size
                              -- Update CLC-descriptor index
                              current.clc.desc.index := current.clc.desc.index + 1
                          --}}}
                          --{{{  Channel-type-end NLC
                          TRUE
                            INITIAL [BYTESIN (INT)]BYTE nct.id.array IS [clc.desc.rest FROM current.clc.desc.index + 1 FOR BYTESIN (INT)]:
                            INT nct.id RETYPES nct.id.array:
                            SEQ
                              -- Send request to CTB-manager
                              CLAIM ctb.mgr.handle
                                SEQ
                                  --{{{  OUT message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                          int.msg.handle[to.handler] ! msg.str; "/"
                                          int.msg.handle[to.handler] ! msg.int; own.chan.id
                                          int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: alloc.ct.end; "
                                          int.msg.handle[to.handler] ! msg.int; nct.id
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                                  -- Carrying: NCT-ID
                                  ctb.mgr.handle[to.mgr] ! alloc.ct.end; nct.id
                                  -- Wait for reply
                                  ctb.mgr.handle[from.mgr] ? CASE
                                    --{{{  Increase reference-count of CTB
                                    INT ctb.ptr:
                                    -- Carrying: CTB-pointer
                                    clone.ctb; ctb.ptr
                                      SEQ
                                        --{{{  IN message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                int.msg.handle[to.handler] ! msg.str; "/"
                                                int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: clone.ctb; "
                                                int.msg.handle[to.handler] ! msg.hex; ctb.ptr
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        -- Pass message on to encoder
                                        --{{{  OUT message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                int.msg.handle[to.handler] ! msg.str; "/"
                                                int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                int.msg.handle[to.handler] ! msg.str; ": OUT ext.ench: clone.ctb; "
                                                int.msg.handle[to.handler] ! msg.hex; ctb.ptr
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        -- Carrying: CTB-pointer
                                        enc.handle.svr[to.encoder] ! clone.ctb; ctb.ptr
                                    --}}}
                                    --{{{  Allocate new CTB
                                    alloc.new.ctb
                                      INT ctb.ptr, num.chans, num.readers.in.svr:
                                      PONY.NETHOOKHANDLE! net.hook.handle:
                                      MOBILE []PONY.DECODEHANDLE! dec.handle.array:
                                      MOBILE []PONY.ENCODEHANDLE! enc.handle.array:
                                      SEQ
                                        --{{{  IN message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                int.msg.handle[to.handler] ! msg.str; "/"
                                                int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: alloc.new.ctb"
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        -- Pass message on to encoder
                                        --{{{  OUT message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                int.msg.handle[to.handler] ! msg.str; "/"
                                                int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                int.msg.handle[to.handler] ! msg.str; ": OUT ext.ench: alloc.new.ctb; "
                                                int.msg.handle[to.handler] ! msg.int; nct.id
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        -- Carrying: NCT-ID
                                        enc.handle.svr[to.encoder] ! alloc.new.ctb; nct.id
                                        -- Wait for reply
                                        -- Carrying: CTB-pointer;
                                        --           number of channel-words in CTB;
                                        --           number of reading-ends in server-end
                                        enc.handle.svr[from.encoder] ? CASE alloc.new.ctb.confirm; ctb.ptr;
                                                                            num.chans; num.readers.in.svr
                                        --{{{  IN message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                int.msg.handle[to.handler] ! msg.str; "/"
                                                int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                int.msg.handle[to.handler] ! msg.str; ": IN ext.ench: alloc.new.ctb.confirm; "
                                                int.msg.handle[to.handler] ! msg.hex; ctb.ptr
                                                int.msg.handle[to.handler] ! msg.str; "; "
                                                int.msg.handle[to.handler] ! msg.int; num.chans
                                                int.msg.handle[to.handler] ! msg.str; "; "
                                                int.msg.handle[to.handler] ! msg.int; num.readers.in.svr
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        -- Pass channel-counts on to CTB-manager
                                        --{{{  OUT message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                int.msg.handle[to.handler] ! msg.str; "/"
                                                int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: alloc.new.ctb.confirm.chancounts; "
                                                int.msg.handle[to.handler] ! msg.int; num.chans
                                                int.msg.handle[to.handler] ! msg.str; "; "
                                                int.msg.handle[to.handler] ! msg.int; num.readers.in.svr
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        -- Carrying: number of channel-words in CTB;
                                        --           number of reading-ends in server-end
                                        ctb.mgr.handle[to.mgr] ! alloc.new.ctb.confirm.chancounts;
                                                                 num.chans; num.readers.in.svr
                                        -- Wait for reply
                                        -- Carrying: network-hook-handle;
                                        --           array of decode-handles;
                                        --           array of encode-handles
                                        ctb.mgr.handle[from.mgr] ? CASE alloc.new.ctb.confirm;
                                                                        net.hook.handle;
                                                                        dec.handle.array; enc.handle.array
                                        --{{{  IN message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                int.msg.handle[to.handler] ! msg.str; "/"
                                                int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: alloc.new.ctb.confirm; [cli-end]; [array ("
                                                int.msg.handle[to.handler] ! msg.int; SIZE dec.handle.array
                                                int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                                                int.msg.handle[to.handler] ! msg.int; SIZE enc.handle.array
                                                int.msg.handle[to.handler] ! msg.str; ")]"
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        -- Pass message on to encoder
                                        --{{{  OUT message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                int.msg.handle[to.handler] ! msg.str; "/"
                                                int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                int.msg.handle[to.handler] ! msg.str; ": OUT ext.ench: alloc.new.ctb.confirm; [cli-end]; [array ("
                                                int.msg.handle[to.handler] ! msg.int; SIZE dec.handle.array
                                                int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                                                int.msg.handle[to.handler] ! msg.int; SIZE enc.handle.array
                                                int.msg.handle[to.handler] ! msg.str; ")]"
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        -- Carrying: network-hook-handle;
                                        --           array of decode-handles;
                                        --           array of encode-handles
                                        enc.handle.svr[to.encoder] ! alloc.new.ctb.confirm;
                                                                     net.hook.handle;
                                                                     dec.handle.array; enc.handle.array
                                        -- Pass CTB-pointer on to CTB-manager
                                        --{{{  OUT message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                int.msg.handle[to.handler] ! msg.str; "/"
                                                int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: alloc.new.ctb.confirm.ctbptr; "
                                                int.msg.handle[to.handler] ! msg.hex; ctb.ptr
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        -- Carrying: CTB-pointer
                                        ctb.mgr.handle[to.mgr] ! alloc.new.ctb.confirm.ctbptr; ctb.ptr
                                    --}}}
                              -- Update CLC-descriptor index
                              current.clc.desc.index := current.clc.desc.index + (1 + BYTESIN (INT))
                          --}}}
                  --}}}
                -- Wait for `ack' from encoder
                enc.handle.svr[from.encoder] ? CASE ack
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; "/"
                        int.msg.handle[to.handler] ! msg.int; own.chan.id
                        int.msg.handle[to.handler] ! msg.str; ": IN ext.ench: ack"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                -- Pass `ack' on to CTB-handler
                --{{{  OUT message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; "/"
                        int.msg.handle[to.handler] ! msg.int; own.chan.id
                        int.msg.handle[to.handler] ! msg.str; ": OUT int.ench: ack"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                int.enc.handle.svr[from.handler] ! ack
            --}}}
          --}}}
          --{{{  Internal-claim unshared ends
          IF
            NOT was.cancelled
              SEQ
                --{{{  Internal-claim all outputted unshared ends of first CLC
                IF
                  -- There are channel-type-end NLCs in first CLC
                  cte.nlcs.first > 0
                    INITIAL INT current.clc.desc.index IS 0:
                    WHILE current.clc.desc.index < (SIZE clc.desc.first)
                      IF
                        --{{{  Data-item NLC
                        clc.desc.first[current.clc.desc.index] = 0
                          -- Update index
                          current.clc.desc.index := current.clc.desc.index + 1
                        --}}}
                        --{{{  Channel-type-end NLC
                        TRUE
                          SEQ
                            --{{{  Actual operation
                            IF
                              -- Unshared end
                              (clc.desc.first[current.clc.desc.index] /\ 5) = 5
                                INITIAL [BYTESIN (INT)]BYTE nct.id.array IS [clc.desc.first FROM current.clc.desc.index + 1 FOR BYTESIN (INT)]:
                                INT nct.id RETYPES nct.id.array:
                                IF
                                  -- End was sent over itself
                                  nct.id = own.nct.id
                                    SKIP
                                  -- End belongs to other CTB
                                  TRUE
                                    -- Internal-claim the end
                                    INT dir.type:
                                    SHARED PONY.INT.CTBCLAIMHANDLE! ctb.claim.handle:
                                    SEQ
                                      IF
                                        -- Unshared client-end
                                        clc.desc.first[current.clc.desc.index] = 5
                                          dir.type := PONYC.INT.DIRTYPE.CLI
                                        -- Unshared server-end
                                        TRUE
                                          dir.type := PONYC.INT.DIRTYPE.SVR
                                      CLAIM ctb.mgr.handle
                                        SEQ
                                          -- Get CTB-claim-handle from CTB-manager
                                          --{{{  OUT message
                                          IF
                                            output.msgs
                                              CLAIM int.msg.handle
                                                SEQ
                                                  int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                  int.msg.handle[to.handler] ! msg.str; "/"
                                                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                  int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.claim.handle; "
                                                  int.msg.handle[to.handler] ! msg.int; nct.id
                                                  int.msg.handle[to.handler] ! msg.str; "; "
                                                  int.msg.handle[to.handler] ! msg.int; dir.type
                                                  int.msg.handle[to.handler] ! msg.end; FALSE
                                            TRUE
                                              SKIP
                                          --}}}
                                          -- Carrying: NCT-ID;
                                          --           direction-type of the end to be claimed/released
                                          --             (0 = client-end, 1 = server-end)
                                          ctb.mgr.handle[to.mgr] ! get.ctb.claim.handle; nct.id; dir.type
                                          -- Get reply
                                          -- Carrying: CTB-claim-handle
                                          ctb.mgr.handle[from.mgr] ? CASE get.ctb.claim.handle.confirm;
                                                                          ctb.claim.handle
                                          --{{{  IN message
                                          IF
                                            output.msgs
                                              CLAIM int.msg.handle
                                                SEQ
                                                  int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                  int.msg.handle[to.handler] ! msg.str; "/"
                                                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                  int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.claim.handle.confirm; [cli-end]"
                                                  int.msg.handle[to.handler] ! msg.end; FALSE
                                            TRUE
                                              SKIP
                                          --}}}
                                      CLAIM ctb.claim.handle
                                        SEQ
                                          --{{{  OUT message
                                          IF
                                            output.msgs
                                              CLAIM int.msg.handle
                                                SEQ
                                                  int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                  int.msg.handle[to.handler] ! msg.str; "/"
                                                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                  int.msg.handle[to.handler] ! msg.str; ": OUT ctbclaimh "
                                                  int.msg.handle[to.handler] ! msg.int; nct.id
                                                  int.msg.handle[to.handler] ! msg.str; "/"
                                                  int.msg.handle[to.handler] ! msg.int; dir.type
                                                  int.msg.handle[to.handler] ! msg.str; ": claim"
                                                  int.msg.handle[to.handler] ! msg.end; FALSE
                                            TRUE
                                              SKIP
                                          --}}}
                                          ctb.claim.handle[to.handler] ! claim
                              -- Shared end
                              TRUE
                                SKIP
                            --}}}
                            -- Update index
                            current.clc.desc.index := current.clc.desc.index + (1 + BYTESIN (INT))
                        --}}}
                  -- No channel-type-end NLCs in first CLC
                  TRUE
                    SKIP
                --}}}
                --{{{  Internal-claim all outputted unshared ends of remaining CLCs
                IF
                  -- There are channel-type-end NLCs in remaining CLCs
                  cte.nlcs.rest > 0
                    INITIAL INT current.clc.desc.index IS 0:
                    WHILE current.clc.desc.index < (SIZE clc.desc.rest)
                      IF
                        --{{{  Data-item NLC
                        clc.desc.rest[current.clc.desc.index] = 0
                          -- Update index
                          current.clc.desc.index := current.clc.desc.index + 1
                        --}}}
                        --{{{  Channel-type-end NLC
                        TRUE
                          SEQ
                            --{{{  Actual operation
                            IF
                              -- Unshared end
                              (clc.desc.rest[current.clc.desc.index] /\ 5) = 5
                                INITIAL [BYTESIN (INT)]BYTE nct.id.array IS [clc.desc.rest FROM current.clc.desc.index + 1 FOR BYTESIN (INT)]:
                                INT nct.id RETYPES nct.id.array:
                                IF
                                  -- End was sent over itself
                                  nct.id = own.nct.id
                                    SKIP
                                  -- End belongs to other CTB
                                  TRUE
                                    -- Internal-claim the end
                                    INT dir.type:
                                    SHARED PONY.INT.CTBCLAIMHANDLE! ctb.claim.handle:
                                    SEQ
                                      IF
                                        -- Unshared client-end
                                        clc.desc.rest[current.clc.desc.index] = 5
                                          dir.type := PONYC.INT.DIRTYPE.CLI
                                        -- Unshared server-end
                                        TRUE
                                          dir.type := PONYC.INT.DIRTYPE.SVR
                                      CLAIM ctb.mgr.handle
                                        SEQ
                                          -- Get CTB-claim-handle from CTB-manager
                                          --{{{  OUT message
                                          IF
                                            output.msgs
                                              CLAIM int.msg.handle
                                                SEQ
                                                  int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                  int.msg.handle[to.handler] ! msg.str; "/"
                                                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                  int.msg.handle[to.handler] ! msg.str; ": OUT ctbmgrh: get.ctb.claim.handle; "
                                                  int.msg.handle[to.handler] ! msg.int; nct.id
                                                  int.msg.handle[to.handler] ! msg.str; "; "
                                                  int.msg.handle[to.handler] ! msg.int; dir.type
                                                  int.msg.handle[to.handler] ! msg.end; FALSE
                                            TRUE
                                              SKIP
                                          --}}}
                                          -- Carrying: NCT-ID;
                                          --           direction-type of the end to be claimed/released
                                          --             (0 = client-end, 1 = server-end)
                                          ctb.mgr.handle[to.mgr] ! get.ctb.claim.handle; nct.id; dir.type
                                          -- Get reply
                                          -- Carrying: CTB-claim-handle
                                          ctb.mgr.handle[from.mgr] ? CASE get.ctb.claim.handle.confirm;
                                                                          ctb.claim.handle
                                          --{{{  IN message
                                          IF
                                            output.msgs
                                              CLAIM int.msg.handle
                                                SEQ
                                                  int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                  int.msg.handle[to.handler] ! msg.str; "/"
                                                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                  int.msg.handle[to.handler] ! msg.str; ": IN ctbmgrh: get.ctb.claim.handle.confirm; [cli-end]"
                                                  int.msg.handle[to.handler] ! msg.end; FALSE
                                            TRUE
                                              SKIP
                                          --}}}
                                      CLAIM ctb.claim.handle
                                        SEQ
                                          --{{{  OUT message
                                          IF
                                            output.msgs
                                              CLAIM int.msg.handle
                                                SEQ
                                                  int.msg.handle[to.handler] ! msg.str; "dec.hdlr "
                                                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                  int.msg.handle[to.handler] ! msg.str; "/"
                                                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                                                  int.msg.handle[to.handler] ! msg.str; ": OUT ctbclaimh "
                                                  int.msg.handle[to.handler] ! msg.int; nct.id
                                                  int.msg.handle[to.handler] ! msg.str; "/"
                                                  int.msg.handle[to.handler] ! msg.int; dir.type
                                                  int.msg.handle[to.handler] ! msg.str; ": claim"
                                                  int.msg.handle[to.handler] ! msg.end; FALSE
                                            TRUE
                                              SKIP
                                          --}}}
                                          ctb.claim.handle[to.handler] ! claim
                              -- Shared end
                              TRUE
                                SKIP
                            --}}}
                            -- Update index
                            current.clc.desc.index := current.clc.desc.index + (1 + BYTESIN (INT))
                        --}}}
                  -- No channel-type-end NLCs in remaining CLCs
                  TRUE
                    SKIP
                --}}}
            TRUE
              SKIP
          --}}}
      --}}}
      --{{{  Shutdown
      shutdown
        SEQ
          --{{{  IN message
          IF
            output.msgs
              CLAIM int.msg.handle
                SEQ
                  int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                  int.msg.handle[to.handler] ! msg.str; "/"
                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                  int.msg.handle[to.handler] ! msg.str; ": IN int.ench: shutdown"
                  int.msg.handle[to.handler] ! msg.end; FALSE
            TRUE
              SKIP
          --}}}
          -- Terminate encoder
          --{{{  OUT message
          IF
            output.msgs
              CLAIM int.msg.handle
                SEQ
                  int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                  int.msg.handle[to.handler] ! msg.str; "/"
                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                  int.msg.handle[to.handler] ! msg.str; ": OUT ext.ench: term"
                  int.msg.handle[to.handler] ! msg.end; FALSE
            TRUE
              SKIP
          --}}}
          enc.handle.svr[to.encoder] ! term
          -- Leave main loop
          running := FALSE
          -- Send reply
          --{{{  OUT message
          IF
            output.msgs
              CLAIM int.msg.handle
                SEQ
                  int.msg.handle[to.handler] ! msg.str; "enc.hdlr "
                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                  int.msg.handle[to.handler] ! msg.str; "/"
                  int.msg.handle[to.handler] ! msg.int; own.chan.id
                  int.msg.handle[to.handler] ! msg.str; ": OUT int.ench: shutdown.confirm"
                  int.msg.handle[to.handler] ! msg.end; FALSE
            TRUE
              SKIP
          --}}}
          int.enc.handle.svr[from.handler] ! shutdown.confirm
      --}}}
:
--}}}

--}}}

