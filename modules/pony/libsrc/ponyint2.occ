-- Copyright: Mario Schweigler (C) 2005-2006
-- Institution: Computing Laboratory, University of Kent, Canterbury, UK
-- Description: pony internal code file 2

-- This program is free software; you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 2 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program; if not, write to the Free Software
-- Foundation, Inc., 51 Franklin Street, Fifth Floor,
-- Boston, MA 02110-1301, USA.

--{{{  Compiler declarations
#INCLUDE "ponylib.inc"
#INCLUDE "ponyint.inc"
#USE "ponyint1.tce"
--}}}

--{{{  Processes

--{{{  PROC pony.int.ctb.handler
-- CTB-handler
-- Parameters: own.node.id              | VAL: own node-ID
--             own.nct.id               | VAL: own NCT-ID
--             initial.cli.claimed      | VAL: client-end initially claimed?
--             initial.svr.claimed      | VAL: server-end initially claimed?
--             num.chans                | VAL: number of channel-words
--             num.readers.in.svr       | VAL: number of reading-ends in
--                                               server-end
--             net.hook.handle.svr      | server-end of network-hook-handle
--             dec.handle.svr.array     | array of decode-handle server-ends
--             enc.handle.svr.array     | array of encode-handle server-ends
--             ctb.main.handle.svr      | server-end of CTB-main-handle
--             ctb.instant.handle.svr   | server-end of CTB-instant-handle
--             ctb.cli.claim.handle.svr | server-end of client-claim-handle
--             ctb.svr.claim.handle.svr | server-end of server-claim-handle
--             ctb.mgr.handle           | CTB-manager-handle (client-end)
--             link.mgr.handle          | link-manager-handle (client-end)
--             master.link.handle       | link-handle for master node
--                                      |   (client-end)
--             output.msgs              | VAL: output messages?
--             int.msg.handle           | internal message-handle (client-end)
PROC pony.int.ctb.handler (VAL INT own.node.id, own.nct.id,
                           VAL BOOL initial.cli.claimed, initial.svr.claimed,
                           VAL INT num.chans, num.readers.in.svr,
                           PONY.NETHOOKHANDLE? net.hook.handle.svr,
                           MOBILE []PONY.DECODEHANDLE? dec.handle.svr.array,
                           MOBILE []PONY.ENCODEHANDLE? enc.handle.svr.array,
                           PONY.INT.CTBMAINHANDLE? ctb.main.handle.svr,
                           PONY.INT.CTBINSTANTHANDLE? ctb.instant.handle.svr,
                           PONY.INT.CTBCLAIMHANDLE? ctb.cli.claim.handle.svr,
                           PONY.INT.CTBCLAIMHANDLE? ctb.svr.claim.handle.svr,
                           SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle,
                           SHARED PONY.INT.LINKMGRHANDLE! link.mgr.handle,
                           SHARED PONY.INT.LINKHANDLE! master.link.handle,
                           VAL BOOL output.msgs,
                           SHARED PONY.INT.MSGHANDLE! int.msg.handle)
  --{{{  Internal decode- and encode-handle-arrays and session-link-handle
  INITIAL MOBILE []PONY.INT.DECODEHANDLE! int.dec.handle.array IS MOBILE [num.chans]PONY.INT.DECODEHANDLE!:
  INITIAL MOBILE []PONY.INT.ENCODEHANDLE! int.enc.handle.array IS MOBILE [num.chans]PONY.INT.ENCODEHANDLE!:
  SHARED PONY.INT.LINKHANDLE! session.link.handle:
  --}}}
  --{{{  Channels
  CHAN BOOL claim.cli, release.cli, release.cli.listener,
            stop.cli.listener,
            claim.svr, release.svr, release.svr.listener,
            stop.svr.listener,
            stop.instant.handler:
  CHAN MOBILE []SHARED PONY.INT.DECODEREPLYHANDLE! pass.dec.reply.handle.array:
  CHAN INT update.current.remote.node:
  --}}}
  --{{{  Constants
  -- Claim-state
  VAL INT CLAIMSTATE.RELEASED IS 0:
  VAL INT CLAIMSTATE.PENDING IS 1:
  VAL INT CLAIMSTATE.CLAIMED IS 2:
  -- Session-state
  VAL INT SESSIONSTATE.NONE IS 0:
  VAL INT SESSIONSTATE.INT IS 1:
  VAL INT SESSIONSTATE.EXT IS 2:
  VAL INT SESSIONSTATE.SENDINGEOI IS 3:
  VAL INT SESSIONSTATE.SUSPENDED IS 4:
  -- ULC-state
  VAL INT ULCSTATE.NONE IS 0:
  VAL INT ULCSTATE.FIRSTPENDING.JUSTONE IS 1:
  VAL INT ULCSTATE.FIRSTPENDING.MORETOCOME IS 2:
  VAL INT ULCSTATE.RESTPENDING IS 3:
  --}}}
  --{{{  Variables
  INITIAL INT cli.claim.state IS CLAIMSTATE.RELEASED:
  INITIAL INT svr.claim.state IS CLAIMSTATE.RELEASED:
  INITIAL INT session.state IS SESSIONSTATE.NONE:
  INITIAL INT ignore.cli.claim IS 0:
  INITIAL INT ignore.svr.claim IS 0:
  INITIAL INT current.remote.node IS -1:
  INITIAL MOBILE []INT ulc.state.array IS MOBILE [num.chans]INT:
  --}}}
  PAR
    --{{{  Client-listener
    INITIAL BOOL running IS TRUE:
    WHILE running
      ALT
        -- Listen on `client' channel of network-hook-handle
        INT signal:
        net.hook.handle.svr[client] ?? signal
          INITIAL BOOL is.claim IS (signal /\ 1) = 0:
          SEQ
            IF
              is.claim
                SEQ
                  --{{{  IN message
                  IF
                    output.msgs
                      CLAIM int.msg.handle
                        SEQ
                          int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                          int.msg.handle[to.handler] ! msg.str; ": IN nethookh [client]: [claim-signal]"
                          int.msg.handle[to.handler] ! msg.end; FALSE
                    TRUE
                      SKIP
                  --}}}
                  claim.cli ! TRUE
              TRUE
                SEQ
                  --{{{  IN message
                  IF
                    output.msgs
                      CLAIM int.msg.handle
                        SEQ
                          int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                          int.msg.handle[to.handler] ! msg.str; ": IN nethookh [client]: [release-signal]"
                          int.msg.handle[to.handler] ! msg.end; FALSE
                    TRUE
                      SKIP
                  --}}}
                  release.cli ! TRUE
            -- Wait before releasing extended rendezvous
            BOOL any:
            release.cli.listener ? any
        -- Listen on client-claim-handle
        ctb.cli.claim.handle.svr[to.handler] ?? CASE
          claim
            SEQ
              --{{{  IN message
              IF
                output.msgs
                  CLAIM int.msg.handle
                    SEQ
                      int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                      int.msg.handle[to.handler] ! msg.int; own.nct.id
                      int.msg.handle[to.handler] ! msg.str; ": IN ctbclaimh [client]: claim"
                      int.msg.handle[to.handler] ! msg.end; FALSE
                TRUE
                  SKIP
              --}}}
              claim.cli ! TRUE
              -- Wait before releasing extended rendezvous
              BOOL any:
              release.cli.listener ? any
          release
            SEQ
              --{{{  IN message
              IF
                output.msgs
                  CLAIM int.msg.handle
                    SEQ
                      int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                      int.msg.handle[to.handler] ! msg.int; own.nct.id
                      int.msg.handle[to.handler] ! msg.str; ": IN ctbclaimh [client]: release"
                      int.msg.handle[to.handler] ! msg.end; FALSE
                TRUE
                  SKIP
              --}}}
              release.cli ! TRUE
              -- Wait before releasing extended rendezvous
              BOOL any:
              release.cli.listener ? any
        -- Stop client-listener
        BOOL any:
        stop.cli.listener ? any
          -- Leave loop
          running := FALSE
    --}}}
    --{{{  Server-listener
    INITIAL BOOL running IS TRUE:
    WHILE running
      ALT
        -- Listen on `server' channel of network-hook-handle
        INT signal:
        net.hook.handle.svr[server] ?? signal
          INITIAL BOOL is.claim IS (signal /\ 1) = 0:
          SEQ
            IF
              is.claim
                SEQ
                  --{{{  IN message
                  IF
                    output.msgs
                      CLAIM int.msg.handle
                        SEQ
                          int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                          int.msg.handle[to.handler] ! msg.str; ": IN nethookh [server]: [claim-signal]"
                          int.msg.handle[to.handler] ! msg.end; FALSE
                    TRUE
                      SKIP
                  --}}}
                  claim.svr ! TRUE
              TRUE
                SEQ
                  --{{{  IN message
                  IF
                    output.msgs
                      CLAIM int.msg.handle
                        SEQ
                          int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                          int.msg.handle[to.handler] ! msg.str; ": IN nethookh [server]: [release-signal]"
                          int.msg.handle[to.handler] ! msg.end; FALSE
                    TRUE
                      SKIP
                  --}}}
                  release.svr ! TRUE
            BOOL any:
            -- Wait before releasing extended rendezvous
            release.svr.listener ? any
        -- Listen on server-claim-handle
        ctb.svr.claim.handle.svr[to.handler] ?? CASE
          claim
            SEQ
              --{{{  IN message
              IF
                output.msgs
                  CLAIM int.msg.handle
                    SEQ
                      int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                      int.msg.handle[to.handler] ! msg.int; own.nct.id
                      int.msg.handle[to.handler] ! msg.str; ": IN ctbclaimh [server]: claim"
                      int.msg.handle[to.handler] ! msg.end; FALSE
                TRUE
                  SKIP
              --}}}
              claim.svr ! TRUE
              -- Wait before releasing extended rendezvous
              BOOL any:
              release.svr.listener ? any
          release
            SEQ
              --{{{  IN message
              IF
                output.msgs
                  CLAIM int.msg.handle
                    SEQ
                      int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                      int.msg.handle[to.handler] ! msg.int; own.nct.id
                      int.msg.handle[to.handler] ! msg.str; ": IN ctbclaimh [server]: release"
                      int.msg.handle[to.handler] ! msg.end; FALSE
                TRUE
                  SKIP
              --}}}
              release.svr ! TRUE
              -- Wait before releasing extended rendezvous
              BOOL any:
              release.svr.listener ? any
        -- Stop server-listener
        BOOL any:
        stop.svr.listener ? any
          -- Leave loop
          running := FALSE
    --}}}
    --{{{  Instant-handler
    MOBILE []SHARED PONY.INT.DECODEREPLYHANDLE! dec.reply.handle.array:
    INT current.remote.node:
    SEQ
      -- Get dec-reply-handle-array via internal channel
      pass.dec.reply.handle.array ? dec.reply.handle.array
      -- Get initial current remote node
      update.current.remote.node ? current.remote.node
      INITIAL BOOL running IS TRUE:
      WHILE running
        ALT
          -- Update current remote node
          update.current.remote.node ? current.remote.node
            SKIP
          -- Request via CTB-instant-handle
          ctb.instant.handle.svr[to.handler] ? CASE
            --{{{  Get decode-reply-handle for a given channel-ID
            INT chan.id:
            -- Carrying: channel-ID
            get.dec.reply.handle; chan.id
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; ": IN ctbinsth: get.dec.reply.handle; "
                        int.msg.handle[to.handler] ! msg.int; chan.id
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                -- Send reply
                --{{{  OUT message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; ": OUT ctbinsth: get.dec.reply.handle.confirm; [cli-end]"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                -- Carrying: decode-reply-handle
                ctb.instant.handle.svr[from.handler] ! get.dec.reply.handle.confirm;
                                                       dec.reply.handle.array[chan.id]
            --}}}
            --{{{  Get ID of current remote node
            get.current.remote.node
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; ": IN ctbinsth: get.current.remote.node"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                IF
                  -- Currently no session
                  current.remote.node = (-1)
                    SEQ
                      -- Send reply
                      --{{{  OUT message
                      IF
                        output.msgs
                          CLAIM int.msg.handle
                            SEQ
                              int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                              int.msg.handle[to.handler] ! msg.str; ": OUT ctbinsth: get.current.remote.node.nosession"
                              int.msg.handle[to.handler] ! msg.end; FALSE
                        TRUE
                          SKIP
                      --}}}
                      ctb.instant.handle.svr[from.handler] ! get.current.remote.node.nosession
                  -- Both ends on same node
                  current.remote.node = own.node.id
                    SEQ
                      -- Send reply
                      --{{{  OUT message
                      IF
                        output.msgs
                          CLAIM int.msg.handle
                            SEQ
                              int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                              int.msg.handle[to.handler] ! msg.str; ": OUT ctbinsth: get.current.remote.node.samenode"
                              int.msg.handle[to.handler] ! msg.end; FALSE
                        TRUE
                          SKIP
                      --}}}
                      ctb.instant.handle.svr[from.handler] ! get.current.remote.node.samenode
                  -- Session involving remote node
                  TRUE
                    SEQ
                      -- Return current remote node
                      --{{{  OUT message
                      IF
                        output.msgs
                          CLAIM int.msg.handle
                            SEQ
                              int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                              int.msg.handle[to.handler] ! msg.str; ": OUT ctbinsth: get.current.remote.node.confirm; "
                              int.msg.handle[to.handler] ! msg.int; current.remote.node
                              int.msg.handle[to.handler] ! msg.end; FALSE
                        TRUE
                          SKIP
                      --}}}
                      -- Carrying: ID of remote node
                      ctb.instant.handle.svr[from.handler] ! get.current.remote.node.confirm;
                                                             current.remote.node
            --}}}
          -- Stop instant-handler
          BOOL any:
          stop.instant.handler ? any
            -- Leave loop
            running := FALSE
    --}}}
    SEQ
      --{{{  Fork off decode-handlers and encode-handlers
      INITIAL MOBILE []SHARED PONY.INT.DECODEREPLYHANDLE! dec.reply.handle.array IS MOBILE [num.chans]SHARED PONY.INT.DECODEREPLYHANDLE!:
      SEQ
        SEQ i = 0 FOR num.chans
          PONY.INT.DECODEHANDLE? int.dec.handle.svr:
          PONY.INT.DECODEREPLYHANDLE? dec.reply.handle.svr:
          PONY.INT.ENCODEHANDLE? int.enc.handle.svr:
          SEQ
            -- Allocate internal decode-handle and encode-handle
            int.dec.handle.array[i], int.dec.handle.svr := MOBILE PONY.INT.DECODEHANDLE
            dec.reply.handle.array[i], dec.reply.handle.svr := MOBILE PONY.INT.DECODEREPLYHANDLE
            int.enc.handle.array[i], int.enc.handle.svr := MOBILE PONY.INT.ENCODEHANDLE
            -- Fork off decode-handler and encode-handler
            --{{{  FORK message
            IF
              output.msgs
                CLAIM int.msg.handle
                  SEQ
                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                    int.msg.handle[to.handler] ! msg.str; ": FORK dec.hdlr ("
                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                    int.msg.handle[to.handler] ! msg.str; ", "
                    int.msg.handle[to.handler] ! msg.int; i
                    int.msg.handle[to.handler] ! msg.str; ", [svr-end], [svr-end], [svr-end], [cli-end], [cli-end], "
                    int.msg.handle[to.handler] ! msg.bool; output.msgs
                    int.msg.handle[to.handler] ! msg.str; ", [cli-end])"
                    int.msg.handle[to.handler] ! msg.end; FALSE
              TRUE
                SKIP
            --}}}
            FORK pony.int.dec.handler (own.nct.id, i,
                                       dec.handle.svr.array[i],
                                       int.dec.handle.svr, dec.reply.handle.svr,
                                       ctb.mgr.handle, master.link.handle,
                                       output.msgs, int.msg.handle)
            --{{{  FORK message
            IF
              output.msgs
                CLAIM int.msg.handle
                  SEQ
                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                    int.msg.handle[to.handler] ! msg.str; ": FORK enc.hdlr ("
                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                    int.msg.handle[to.handler] ! msg.str; ", "
                    int.msg.handle[to.handler] ! msg.int; i
                    int.msg.handle[to.handler] ! msg.str; ", [svr-end], [svr-end], [cli-end], "
                    int.msg.handle[to.handler] ! msg.bool; output.msgs
                    int.msg.handle[to.handler] ! msg.str; ", [cli-end])"
                    int.msg.handle[to.handler] ! msg.end; FALSE
              TRUE
                SKIP
            --}}}
            FORK pony.int.enc.handler (own.nct.id, i,
                                       enc.handle.svr.array[i],
                                       int.enc.handle.svr, ctb.mgr.handle,
                                       output.msgs, int.msg.handle)
        -- Pass decode-reply-handle-array to instant-handler
        pass.dec.reply.handle.array ! dec.reply.handle.array
      --}}}
      --{{{  Initialise variables
      IF
        initial.cli.claimed
          cli.claim.state := CLAIMSTATE.CLAIMED
        TRUE
          SKIP
      IF
        initial.svr.claimed
          svr.claim.state := CLAIMSTATE.CLAIMED
        TRUE
          SKIP
      IF
        initial.cli.claimed AND initial.svr.claimed
          SEQ
            session.state := SESSIONSTATE.INT
            current.remote.node := own.node.id
        TRUE
          SKIP
      update.current.remote.node ! current.remote.node
      SEQ i = 0 FOR num.chans
        ulc.state.array[i] := ULCSTATE.NONE
      --}}}
      --{{{  Main function
      INITIAL BOOL running IS TRUE:
      WHILE running
        ALT
          --{{{  Claim client-end
          BOOL any:
          (cli.claim.state = CLAIMSTATE.RELEASED) & claim.cli ? any
            IF
              ignore.cli.claim > 0
                SEQ
                  -- Release client-listener
                  release.cli.listener ! TRUE
                  -- Decrease `ignore.cli.claim' flag
                  ignore.cli.claim := ignore.cli.claim - 1
              TRUE
                SEQ
                  -- Update client-claim-state
                  cli.claim.state := CLAIMSTATE.PENDING
                  -- Send request to NCT-handler (via master-link-handle)
                  CLAIM master.link.handle
                    SEQ
                      --{{{  OUT message
                      IF
                        output.msgs
                          CLAIM int.msg.handle
                            SEQ
                              int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                              int.msg.handle[to.handler] ! msg.str; ": OUT linkh 0: forncthandler.claim.cli; "
                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                              int.msg.handle[to.handler] ! msg.end; FALSE
                        TRUE
                          SKIP
                      --}}}
                      -- Carrying: NCT-ID of the CTB-handler making the request
                      master.link.handle[to.handler] ! forncthandler.claim.cli; own.nct.id
          --}}}
          --{{{  Claim server-end
          BOOL any:
          (svr.claim.state = CLAIMSTATE.RELEASED) & claim.svr ? any
            IF
              ignore.svr.claim > 0
                SEQ
                  -- Release server-listener
                  release.svr.listener ! TRUE
                  -- Decrease `ignore.svr.claim' flag
                  ignore.svr.claim := ignore.svr.claim - 1
              TRUE
                SEQ
                  -- Update server-claim-state
                  svr.claim.state := CLAIMSTATE.PENDING
                  -- Send request to NCT-handler (via master-link-handle)
                  CLAIM master.link.handle
                    SEQ
                      --{{{  OUT message
                      IF
                        output.msgs
                          CLAIM int.msg.handle
                            SEQ
                              int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                              int.msg.handle[to.handler] ! msg.str; ": OUT linkh 0: forncthandler.claim.svr; "
                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                              int.msg.handle[to.handler] ! msg.end; FALSE
                        TRUE
                          SKIP
                      --}}}
                      -- Carrying: NCT-ID of the CTB-handler making the request
                      master.link.handle[to.handler] ! forncthandler.claim.svr; own.nct.id
          --}}}
          --{{{  Reply from NCT-handler regarding pending client-end-claim
          (cli.claim.state = CLAIMSTATE.PENDING) & ctb.main.handle.svr[from.ncthandler.re.client] ? CASE
            --{{{  Confirm claim of client-end - currently no other end claimed
            claim.confirm.nootherend
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [from.ncthandler.re.client]: claim.confirm.nootherend"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                -- Update client-claim-state
                cli.claim.state := CLAIMSTATE.CLAIMED
                -- Release client-listener
                release.cli.listener ! TRUE
            --}}}
            --{{{  Confirm claim of client-end - other end is claimed
            -- Carrying: node-ID of the other end's node
            claim.confirm.otherendclaimed; current.remote.node
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [from.ncthandler.re.client]: claim.confirm.otherendclaimed; "
                        int.msg.handle[to.handler] ! msg.int; current.remote.node
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                -- Update current remote node in instant-handler
                update.current.remote.node ! current.remote.node
                -- Update session-state (new session is definitely external)
                session.state := SESSIONSTATE.EXT
                -- Update client-claim-state
                cli.claim.state := CLAIMSTATE.CLAIMED
                -- Release client-listener
                release.cli.listener ! TRUE
                -- Get session-link-handle from link-manager
                CLAIM link.mgr.handle
                  SEQ
                    --{{{  OUT message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                            int.msg.handle[to.handler] ! msg.str; ": OUT linkmgrh: get.link.handle; "
                            int.msg.handle[to.handler] ! msg.int; current.remote.node
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                    -- Carrying: node-ID
                    link.mgr.handle[to.mgr] ! get.link.handle; current.remote.node
                    -- Get reply
                    -- Carrying: link-handle
                    link.mgr.handle[from.mgr] ? CASE get.link.handle.confirm; session.link.handle
                    --{{{  IN message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                            int.msg.handle[to.handler] ! msg.str; ": IN linkmgrh: get.link.handle.confirm; [cli-end]"
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                -- Activate all decode-handlers for client-end
                SEQ i = 0 FOR num.readers.in.svr
                  SEQ
                    --{{{  OUT message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                            int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
                            int.msg.handle[to.handler] ! msg.int; i
                            int.msg.handle[to.handler] ! msg.str; ": start.session"
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                    int.dec.handle.array[i][to.handler] ! start.session
                -- Send start-of-session confirmation to remote CTB-handler
                CLAIM session.link.handle
                  SEQ
                    --{{{  OUT message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                            int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
                            int.msg.handle[to.handler] ! msg.int; current.remote.node
                            int.msg.handle[to.handler] ! msg.str; ": insession.start.session; "
                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                    -- Carrying: NCT-ID of the CTB-handler making the request
                    session.link.handle[to.handler] ! insession.start.session; own.nct.id
                --}}}
          --}}}
          --{{{  Reply from NCT-handler regarding pending server-end-claim
          (svr.claim.state = CLAIMSTATE.PENDING) & ctb.main.handle.svr[from.ncthandler.re.server] ? CASE
            --{{{  Confirm claim of server-end - currently no other end claimed
            claim.confirm.nootherend
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [from.ncthandler.re.server]: claim.confirm.nootherend"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                -- Update server-claim-state
                svr.claim.state := CLAIMSTATE.CLAIMED
                -- Release server-listener
                release.svr.listener ! TRUE
            --}}}
            --{{{  Confirm claim of server-end - other end is claimed
            -- Carrying: node-ID of the other end's node
            claim.confirm.otherendclaimed; current.remote.node
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [from.ncthandler.re.server]: claim.confirm.otherendclaimed; "
                        int.msg.handle[to.handler] ! msg.int; current.remote.node
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                -- Update current remote node in instant-handler
                update.current.remote.node ! current.remote.node
                -- Update session-state (new session is definitely external)
                session.state := SESSIONSTATE.EXT
                -- Update server-claim-state
                svr.claim.state := CLAIMSTATE.CLAIMED
                -- Release server-listener
                release.svr.listener ! TRUE
                -- Get session-link-handle from link-manager
                CLAIM link.mgr.handle
                  SEQ
                    --{{{  OUT message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                            int.msg.handle[to.handler] ! msg.str; ": OUT linkmgrh: get.link.handle; "
                            int.msg.handle[to.handler] ! msg.int; current.remote.node
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                    -- Carrying: node-ID
                    link.mgr.handle[to.mgr] ! get.link.handle; current.remote.node
                    -- Get reply
                    -- Carrying: link-handle
                    link.mgr.handle[from.mgr] ? CASE get.link.handle.confirm; session.link.handle
                    --{{{  IN message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                            int.msg.handle[to.handler] ! msg.str; ": IN linkmgrh: get.link.handle.confirm; [cli-end]"
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                -- Activate all decode-handlers for server-end
                SEQ i = num.readers.in.svr FOR (num.chans - num.readers.in.svr)
                  SEQ
                    --{{{  OUT message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                            int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
                            int.msg.handle[to.handler] ! msg.int; i
                            int.msg.handle[to.handler] ! msg.str; ": start.session"
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                    int.dec.handle.array[i][to.handler] ! start.session
                -- Send start-of-session confirmation to remote CTB-handler
                CLAIM session.link.handle
                  SEQ
                    --{{{  OUT message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                            int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
                            int.msg.handle[to.handler] ! msg.int; current.remote.node
                            int.msg.handle[to.handler] ! msg.str; ": insession.start.session; "
                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                    -- Carrying: NCT-ID of the CTB-handler making the request
                    session.link.handle[to.handler] ! insession.start.session; own.nct.id
            --}}}
          --}}}
          --{{{  New-other-end message from NCT-handler regarding client-end-claim
          -- Carrying: node-ID of the other end's node
          (cli.claim.state =
              CLAIMSTATE.CLAIMED) & ctb.main.handle.svr[from.ncthandler.re.client] ? CASE new.other.end;
                                                                                          current.remote.node
            SEQ
              --{{{  IN message
              IF
                output.msgs
                  CLAIM int.msg.handle
                    SEQ
                      int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                      int.msg.handle[to.handler] ! msg.int; own.nct.id
                      int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [from.ncthandler.re.client]: new.other.end; "
                      int.msg.handle[to.handler] ! msg.int; current.remote.node
                      int.msg.handle[to.handler] ! msg.end; FALSE
                TRUE
                  SKIP
              --}}}
              -- Update current remote node in instant-handler
              update.current.remote.node ! current.remote.node
              IF
                --{{{  Internal session
                current.remote.node = own.node.id
                  SEQ
                    -- Update session-state
                    session.state := SESSIONSTATE.INT
                    -- Update server-claim-state (currently definitely `pending')
                    svr.claim.state := CLAIMSTATE.CLAIMED
                    -- Release server-listener
                    release.svr.listener ! TRUE
                --}}}
                --{{{  External session
                TRUE
                  SEQ
                    -- Update session-state
                    session.state := SESSIONSTATE.EXT
                    -- Get session-link-handle from link-manager
                    CLAIM link.mgr.handle
                      SEQ
                        --{{{  OUT message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; ": OUT linkmgrh: get.link.handle; "
                                int.msg.handle[to.handler] ! msg.int; current.remote.node
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        -- Carrying: node-ID
                        link.mgr.handle[to.mgr] ! get.link.handle; current.remote.node
                        -- Get reply
                        -- Carrying: link-handle
                        link.mgr.handle[from.mgr] ? CASE get.link.handle.confirm; session.link.handle
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkmgrh: get.link.handle.confirm; [cli-end]"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                    -- Activate all decode-handlers for client-end
                    SEQ i = 0 FOR num.readers.in.svr
                      SEQ
                        --{{{  OUT message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
                                int.msg.handle[to.handler] ! msg.int; i
                                int.msg.handle[to.handler] ! msg.str; ": start.session"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        int.dec.handle.array[i][to.handler] ! start.session
                --}}}
              -- Confirm new-other-end to NCT-handler
              CLAIM master.link.handle
                SEQ
                  --{{{  OUT message
                  IF
                    output.msgs
                      CLAIM int.msg.handle
                        SEQ
                          int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                          int.msg.handle[to.handler] ! msg.str; ": OUT linkh 0: forncthandler.new.other.end.confirm; "
                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                          int.msg.handle[to.handler] ! msg.end; FALSE
                    TRUE
                      SKIP
                  --}}}
                  -- Carrying: NCT-ID of the CTB-handler making the request
                  master.link.handle[to.handler] ! forncthandler.new.other.end.confirm; own.nct.id
              -- Wait for start-of-session confirmation from remote CTB-handler
              IF
                session.state = SESSIONSTATE.EXT
                  ctb.main.handle.svr[to.handler] ? CASE start.session
                TRUE
                  SKIP
          --}}}
          --{{{  New-other-end message from NCT-handler regarding server-end-claim
          -- Carrying: node-ID of the other end's node
          (svr.claim.state =
              CLAIMSTATE.CLAIMED) & ctb.main.handle.svr[from.ncthandler.re.server] ? CASE new.other.end;
                                                                                          current.remote.node
            SEQ
              --{{{  IN message
              IF
                output.msgs
                  CLAIM int.msg.handle
                    SEQ
                      int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                      int.msg.handle[to.handler] ! msg.int; own.nct.id
                      int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [from.ncthandler.re.server]: new.other.end; "
                      int.msg.handle[to.handler] ! msg.int; current.remote.node
                      int.msg.handle[to.handler] ! msg.end; FALSE
                TRUE
                  SKIP
              --}}}
              -- Update current remote node in instant-handler
              update.current.remote.node ! current.remote.node
              IF
                --{{{  Internal session
                current.remote.node = own.node.id
                  SEQ
                    -- Update session-state
                    session.state := SESSIONSTATE.INT
                    -- Update client-claim-state (currently definitely `pending')
                    cli.claim.state := CLAIMSTATE.CLAIMED
                    -- Release client-listener
                    release.cli.listener ! TRUE
                --}}}
                --{{{  External session
                TRUE
                  SEQ
                    -- Update session-state
                    session.state := SESSIONSTATE.EXT
                    -- Get session-link-handle from link-manager
                    CLAIM link.mgr.handle
                      SEQ
                        --{{{  OUT message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; ": OUT linkmgrh: get.link.handle; "
                                int.msg.handle[to.handler] ! msg.int; current.remote.node
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        -- Carrying: node-ID
                        link.mgr.handle[to.mgr] ! get.link.handle; current.remote.node
                        -- Get reply
                        -- Carrying: link-handle
                        link.mgr.handle[from.mgr] ? CASE get.link.handle.confirm; session.link.handle
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; ": IN linkmgrh: get.link.handle.confirm; [cli-end]"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                    -- Activate all decode-handlers for server-end
                    SEQ i = num.readers.in.svr FOR (num.chans - num.readers.in.svr)
                      SEQ
                        --{{{  OUT message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
                                int.msg.handle[to.handler] ! msg.int; i
                                int.msg.handle[to.handler] ! msg.str; ": start.session"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        int.dec.handle.array[i][to.handler] ! start.session
                --}}}
              -- Confirm new-other-end to NCT-handler
              CLAIM master.link.handle
                SEQ
                  --{{{  OUT message
                  IF
                    output.msgs
                      CLAIM int.msg.handle
                        SEQ
                          int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                          int.msg.handle[to.handler] ! msg.str; ": OUT linkh 0: forncthandler.new.other.end.confirm; "
                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                          int.msg.handle[to.handler] ! msg.end; FALSE
                    TRUE
                      SKIP
                  --}}}
                  -- Carrying: NCT-ID of the CTB-handler making the request
                  master.link.handle[to.handler] ! forncthandler.new.other.end.confirm; own.nct.id
              -- Wait for start-of-session confirmation from remote CTB-handler
              IF
                session.state = SESSIONSTATE.EXT
                  ctb.main.handle.svr[to.handler] ? CASE start.session
                TRUE
                  SKIP
          --}}}
          --{{{  Release client-end (outside session)
          BOOL any:
          ((session.state = SESSIONSTATE.NONE) AND (cli.claim.state <>
              CLAIMSTATE.PENDING)) & release.cli ? any
            IF
              --{{{  Client-end currently released
              cli.claim.state = CLAIMSTATE.RELEASED
                SEQ
                  -- Release client-listener
                  release.cli.listener ! TRUE
                  -- Increase `ignore.cli.claim' flag
                  ignore.cli.claim := ignore.cli.claim + 1
              --}}}
              --{{{  Client-end currently claimed
              TRUE
                SEQ
                  -- Send release request to NCT-handler (via master-link-handle)
                  CLAIM master.link.handle
                    SEQ
                      --{{{  OUT message
                      IF
                        output.msgs
                          CLAIM int.msg.handle
                            SEQ
                              int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                              int.msg.handle[to.handler] ! msg.str; ": OUT linkh 0: forncthandler.release.cli; "
                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                              int.msg.handle[to.handler] ! msg.end; FALSE
                        TRUE
                          SKIP
                      --}}}
                      -- Carrying: NCT-ID of the CTB-handler making the request
                      master.link.handle[to.handler] ! forncthandler.release.cli; own.nct.id
                  -- Wait for reply (via CTB-main-handle)
                  INT any:
                  -- Carrying: node-ID of the other end's node (dummy in this case)
                  ctb.main.handle.svr[from.ncthandler.re.client] ? CASE new.other.end; any
                  --{{{  IN message
                  IF
                    output.msgs
                      CLAIM int.msg.handle
                        SEQ
                          int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                          int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [from.ncthandler.re.client]: new.other.end; [any-int]"
                          int.msg.handle[to.handler] ! msg.end; FALSE
                    TRUE
                      SKIP
                  --}}}
                  -- Update client-claim-state
                  cli.claim.state := CLAIMSTATE.RELEASED
                  -- Release client-listener
                  release.cli.listener ! TRUE
              --}}}
          --}}}
          --{{{  Release server-end (outside session)
          BOOL any:
          ((session.state = SESSIONSTATE.NONE) AND (svr.claim.state <>
              CLAIMSTATE.PENDING)) & release.svr ? any
            IF
              --{{{  Server-end currently released
              svr.claim.state = CLAIMSTATE.RELEASED
                SEQ
                  -- Release server-listener
                  release.svr.listener ! TRUE
                  -- Increase `ignore.svr.claim' flag
                  ignore.svr.claim := ignore.svr.claim + 1
              --}}}
              --{{{  Server-end currently claimed
              TRUE
                SEQ
                  -- Send release request to NCT-handler (via master-link-handle)
                  CLAIM master.link.handle
                    SEQ
                      --{{{  OUT message
                      IF
                        output.msgs
                          CLAIM int.msg.handle
                            SEQ
                              int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                              int.msg.handle[to.handler] ! msg.str; ": OUT linkh 0: forncthandler.release.svr; "
                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                              int.msg.handle[to.handler] ! msg.end; FALSE
                        TRUE
                          SKIP
                      --}}}
                      -- Carrying: NCT-ID of the CTB-handler making the request
                      master.link.handle[to.handler] ! forncthandler.release.svr; own.nct.id
                  -- Wait for reply (via CTB-main-handle)
                  INT any:
                  -- Carrying: node-ID of the other end's node (dummy in this case)
                  ctb.main.handle.svr[from.ncthandler.re.server] ? CASE new.other.end; any
                  --{{{  IN message
                  IF
                    output.msgs
                      CLAIM int.msg.handle
                        SEQ
                          int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                          int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [from.ncthandler.re.server]: new.other.end; [any-int]"
                          int.msg.handle[to.handler] ! msg.end; FALSE
                    TRUE
                      SKIP
                  --}}}
                  -- Update server-claim-state
                  svr.claim.state := CLAIMSTATE.RELEASED
                  -- Release server-listener
                  release.svr.listener ! TRUE
              --}}}
          --}}}
          --{{{  Release client-end (during session)
          BOOL any:
          ((session.state <> SESSIONSTATE.NONE) AND (cli.claim.state =
              CLAIMSTATE.CLAIMED)) & release.cli ? any
            SEQ
              --{{{  Close session if not internal
              IF
                session.state <> SESSIONSTATE.INT
                  SEQ
                    --{{{  Deactivate all decode-handlers if not suspended
                    IF
                      session.state <> SESSIONSTATE.SUSPENDED
                        SEQ i = 0 FOR num.readers.in.svr
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
                                    int.msg.handle[to.handler] ! msg.int; i
                                    int.msg.handle[to.handler] ! msg.str; ": cancel.session"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            int.dec.handle.array[i][to.handler] ! cancel.session
                            -- Wait for reply (can only be `cancel.confirm' in this case)
                            int.dec.handle.array[i][from.handler] ? CASE cancel.confirm
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                    int.msg.handle[to.handler] ! msg.int; i
                                    int.msg.handle[to.handler] ! msg.str; ": cancel.confirm"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                      TRUE
                        SKIP
                    --}}}
                    --{{{  Send close-session message to remote CTB-handler (via session-link-handle)
                    CLAIM session.link.handle
                      SEQ
                        --{{{  OUT message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
                                int.msg.handle[to.handler] ! msg.int; current.remote.node
                                int.msg.handle[to.handler] ! msg.str; ": insession.close.session; "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        -- Carrying: NCT-ID of the CTB-handler making the request
                        session.link.handle[to.handler] ! insession.close.session; own.nct.id
                    --}}}
                    --{{{  Cancel (or get ack from) all pending encode-handlers
                    SEQ i = num.readers.in.svr FOR (num.chans - num.readers.in.svr)
                      IF
                        ulc.state.array[i] <> ULCSTATE.NONE
                          SEQ
                            IF
                              --{{{  Remaining CLCs pending
                              ulc.state.array[i] = ULCSTATE.RESTPENDING
                                SEQ
                                  -- Wait for `ack' from encode-handler (will definitely come)
                                  int.enc.handle.array[i][from.handler] ? CASE ack
                                  --{{{  IN message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                          int.msg.handle[to.handler] ! msg.str; ": IN int.ench "
                                          int.msg.handle[to.handler] ! msg.int; i
                                          int.msg.handle[to.handler] ! msg.str; ": ack"
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                                  -- Pass `ack' on to remote CTB-handler (via session-link-handle)
                                  CLAIM session.link.handle
                                    SEQ
                                      --{{{  OUT message
                                      IF
                                        output.msgs
                                          CLAIM int.msg.handle
                                            SEQ
                                              int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                                              int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
                                              int.msg.handle[to.handler] ! msg.int; current.remote.node
                                              int.msg.handle[to.handler] ! msg.str; ": insession.ack; "
                                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                                              int.msg.handle[to.handler] ! msg.str; "; "
                                              int.msg.handle[to.handler] ! msg.int; i
                                              int.msg.handle[to.handler] ! msg.end; FALSE
                                        TRUE
                                          SKIP
                                      --}}}
                                      -- Carrying: NCT-ID of the CTB-handler making the request;
                                      --           channel-ID of the relevant channel
                                      session.link.handle[to.handler] ! insession.ack; own.nct.id; i
                                  --{{{  Deal with special case if session-state is suspended
                                  IF
                                    session.state = SESSIONSTATE.SUSPENDED
                                      SEQ
                                        -- Update server-claim-state
                                        svr.claim.state := CLAIMSTATE.CLAIMED
                                        -- Send `eoi.done' to NCT-handler (via master-link-handle)
                                        CLAIM master.link.handle
                                          SEQ
                                            --{{{  OUT message
                                            IF
                                              output.msgs
                                                CLAIM int.msg.handle
                                                  SEQ
                                                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                    int.msg.handle[to.handler] ! msg.str; ": OUT linkh 0: forncthandler.eoi.done; "
                                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                    int.msg.handle[to.handler] ! msg.end; FALSE
                                              TRUE
                                                SKIP
                                            --}}}
                                            -- Carrying: NCT-ID of the CTB-handler making the request
                                            master.link.handle[to.handler] ! forncthandler.eoi.done; own.nct.id
                                    TRUE
                                      SKIP
                                  --}}}
                              --}}}
                              --{{{  First CLC pending
                              TRUE
                                SEQ
                                  -- Initiate `cancel.encode'
                                  --{{{  OUT message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                          int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
                                          int.msg.handle[to.handler] ! msg.int; i
                                          int.msg.handle[to.handler] ! msg.str; ": cancel.encode"
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                                  int.dec.handle.array[i][to.handler] ! cancel.encode
                                  -- Wait for `ack' from encode-handler
                                  int.enc.handle.array[i][from.handler] ? CASE ack
                                  --{{{  IN message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                          int.msg.handle[to.handler] ! msg.str; ": IN int.ench "
                                          int.msg.handle[to.handler] ! msg.int; i
                                          int.msg.handle[to.handler] ! msg.str; ": ack"
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                                  -- Send `cancel.encode.ack' to decode-handler
                                  --{{{  OUT message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                          int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
                                          int.msg.handle[to.handler] ! msg.int; i
                                          int.msg.handle[to.handler] ! msg.str; ": cancel.encode.ack"
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                                  int.dec.handle.array[i][to.handler] ! cancel.encode.ack
                                  -- Get reply from decode-handler
                                  int.dec.handle.array[i][from.handler] ? CASE
                                    --{{{  CLC was cancelled
                                    encode.cancelled
                                      SEQ
                                        --{{{  IN message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                                int.msg.handle[to.handler] ! msg.int; i
                                                int.msg.handle[to.handler] ! msg.str; ": encode.cancelled"
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        -- Cancel CLC in encode-handler
                                        --{{{  OUT message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                int.msg.handle[to.handler] ! msg.str; ": OUT int.ench "
                                                int.msg.handle[to.handler] ! msg.int; i
                                                int.msg.handle[to.handler] ! msg.str; ": cancel.session"
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        int.enc.handle.array[i][to.handler] ! cancel.session
                                        -- Send `cancel' to remote CTB-handler (via session-link-handle)
                                        CLAIM session.link.handle
                                          SEQ
                                            --{{{  OUT message
                                            IF
                                              output.msgs
                                                CLAIM int.msg.handle
                                                  SEQ
                                                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                    int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
                                                    int.msg.handle[to.handler] ! msg.int; current.remote.node
                                                    int.msg.handle[to.handler] ! msg.str; ": insession.cancel; "
                                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                    int.msg.handle[to.handler] ! msg.str; "; "
                                                    int.msg.handle[to.handler] ! msg.int; i
                                                    int.msg.handle[to.handler] ! msg.end; FALSE
                                              TRUE
                                                SKIP
                                            --}}}
                                            -- Carrying: NCT-ID of the CTB-handler making the request;
                                            --           channel-ID of the relevant channel
                                            session.link.handle[to.handler] ! insession.cancel; own.nct.id; i
                                    --}}}
                                    --{{{  CLC was not cancelled
                                    --       (can only be the case if there are no remaining CLCs)
                                    encode.not.cancelled
                                      SEQ
                                        --{{{  IN message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                                int.msg.handle[to.handler] ! msg.int; i
                                                int.msg.handle[to.handler] ! msg.str; ": encode.not.cancelled"
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        -- Send confirmation to encode-handler
                                        --{{{  OUT message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                int.msg.handle[to.handler] ! msg.str; ": OUT int.ench "
                                                int.msg.handle[to.handler] ! msg.int; i
                                                int.msg.handle[to.handler] ! msg.str; ": output.successful"
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        int.enc.handle.array[i][to.handler] ! output.successful
                                        -- Pass `ack' on to remote CTB-handler (via session-link-handle)
                                        CLAIM session.link.handle
                                          SEQ
                                            --{{{  OUT message
                                            IF
                                              output.msgs
                                                CLAIM int.msg.handle
                                                  SEQ
                                                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                    int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
                                                    int.msg.handle[to.handler] ! msg.int; current.remote.node
                                                    int.msg.handle[to.handler] ! msg.str; ": insession.ack; "
                                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                    int.msg.handle[to.handler] ! msg.str; "; "
                                                    int.msg.handle[to.handler] ! msg.int; i
                                                    int.msg.handle[to.handler] ! msg.end; FALSE
                                              TRUE
                                                SKIP
                                            --}}}
                                            -- Carrying: NCT-ID of the CTB-handler making the request;
                                            --           channel-ID of the relevant channel
                                            session.link.handle[to.handler] ! insession.ack; own.nct.id; i
                                        --{{{  Deal with special case if session-state is suspended
                                        IF
                                          session.state = SESSIONSTATE.SUSPENDED
                                            SEQ
                                              -- Update server-claim-state
                                              svr.claim.state := CLAIMSTATE.CLAIMED
                                              -- Send `eoi.done' to NCT-handler (via master-link-handle)
                                              CLAIM master.link.handle
                                                SEQ
                                                  --{{{  OUT message
                                                  IF
                                                    output.msgs
                                                      CLAIM int.msg.handle
                                                        SEQ
                                                          int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                          int.msg.handle[to.handler] ! msg.str; ": OUT linkh 0: forncthandler.eoi.done; "
                                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                                    TRUE
                                                      SKIP
                                                  --}}}
                                                  -- Carrying: NCT-ID of the CTB-handler making the request
                                                  master.link.handle[to.handler] ! forncthandler.eoi.done; own.nct.id
                                          TRUE
                                            SKIP
                                        --}}}
                                    --}}}
                              --}}}
                            -- Update ULC-state of the pending ULC
                            ulc.state.array[i] := ULCSTATE.NONE
                        TRUE
                          SKIP
                    --}}}
                    --{{{  Wait for confirmation from remote CTB-handler
                    INITIAL BOOL running IS TRUE:
                    WHILE running
                      ctb.main.handle.svr[to.handler] ? CASE
                        --{{{  First CLC of a ULC
                        INT chan.id, di.nlcs.first, cte.nlcs.first:
                        BOOL has.rest.clcs:
                        MOBILE []BYTE data.array:
                        MOBILE []INT size.array:
                        -- Carrying: channel-ID of the relevant channel;
                        --           number of data-item NLCs in first CLC;
                        --           number of channel-type-end NLCs in first CLC;
                        --           are there remaining CLCs?;
                        --           data-array;
                        --           size-array
                        first.clc; chan.id; di.nlcs.first; cte.nlcs.first;
                                            has.rest.clcs;
                                            data.array; size.array
                          SEQ
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [to.handler]: first.clc; "
                                    int.msg.handle[to.handler] ! msg.int; chan.id
                                    int.msg.handle[to.handler] ! msg.str; "; "
                                    int.msg.handle[to.handler] ! msg.int; di.nlcs.first
                                    int.msg.handle[to.handler] ! msg.str; "; "
                                    int.msg.handle[to.handler] ! msg.int; cte.nlcs.first
                                    int.msg.handle[to.handler] ! msg.str; "; "
                                    int.msg.handle[to.handler] ! msg.bool; has.rest.clcs
                                    int.msg.handle[to.handler] ! msg.str; "; [array ("
                                    int.msg.handle[to.handler] ! msg.int; SIZE data.array
                                    int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                                    int.msg.handle[to.handler] ! msg.int; SIZE size.array
                                    int.msg.handle[to.handler] ! msg.str; ")]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Send `cancel' to remote CTB-handler (via session-link-handle)
                            CLAIM session.link.handle
                              SEQ
                                --{{{  OUT message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                                        int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
                                        int.msg.handle[to.handler] ! msg.int; current.remote.node
                                        int.msg.handle[to.handler] ! msg.str; ": insession.cancel; "
                                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                                        int.msg.handle[to.handler] ! msg.str; "; "
                                        int.msg.handle[to.handler] ! msg.int; chan.id
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                                -- Carrying: NCT-ID of the CTB-handler making the request;
                                --           channel-ID of the relevant channel
                                session.link.handle[to.handler] ! insession.cancel; own.nct.id; chan.id
                        --}}}
                        --{{{  Close session
                        close.session
                          SEQ
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [to.handler]: close.session"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Leave loop
                            running := FALSE
                        --}}}
                        --{{{  Suspend session
                        suspend.session
                          --{{{  IN message
                          IF
                            output.msgs
                              CLAIM int.msg.handle
                                SEQ
                                  int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                                  int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [to.handler]: suspend.session"
                                  int.msg.handle[to.handler] ! msg.end; FALSE
                            TRUE
                              SKIP
                          --}}}
                        --}}}
                    --}}}
                TRUE
                  SKIP
              --}}}
              -- Send release request to NCT-handler (via master-link-handle)
              CLAIM master.link.handle
                SEQ
                  --{{{  OUT message
                  IF
                    output.msgs
                      CLAIM int.msg.handle
                        SEQ
                          int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                          int.msg.handle[to.handler] ! msg.str; ": OUT linkh 0: forncthandler.release.cli; "
                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                          int.msg.handle[to.handler] ! msg.end; FALSE
                    TRUE
                      SKIP
                  --}}}
                  -- Carrying: NCT-ID of the CTB-handler making the request
                  master.link.handle[to.handler] ! forncthandler.release.cli; own.nct.id
              -- Wait for reply (via CTB-main-handle)
              INT any:
              -- Carrying: node-ID of the other end's node (dummy in this case)
              ctb.main.handle.svr[from.ncthandler.re.client] ? CASE new.other.end; any
              --{{{  IN message
              IF
                output.msgs
                  CLAIM int.msg.handle
                    SEQ
                      int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                      int.msg.handle[to.handler] ! msg.int; own.nct.id
                      int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [from.ncthandler.re.client]: new.other.end; [any-int]"
                      int.msg.handle[to.handler] ! msg.end; FALSE
                TRUE
                  SKIP
              --}}}
              -- Update session-state
              session.state := SESSIONSTATE.NONE
              -- Update current remote node
              current.remote.node := -1
              -- Update current remote node in instant-handler
              update.current.remote.node ! current.remote.node
              -- Update client-claim-state
              cli.claim.state := CLAIMSTATE.RELEASED
              -- Release client-listener
              release.cli.listener ! TRUE
          --}}}
          --{{{  Release server-end (during session)
          BOOL any:
          ((session.state <> SESSIONSTATE.NONE) AND (svr.claim.state =
              CLAIMSTATE.CLAIMED)) & release.svr ? any
            SEQ
              --{{{  Close session if not internal
              IF
                session.state <> SESSIONSTATE.INT
                  SEQ
                    --{{{  Deactivate all decode-handlers if not suspended
                    IF
                      session.state <> SESSIONSTATE.SUSPENDED
                        SEQ i = num.readers.in.svr FOR (num.chans - num.readers.in.svr)
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
                                    int.msg.handle[to.handler] ! msg.int; i
                                    int.msg.handle[to.handler] ! msg.str; ": cancel.session"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            int.dec.handle.array[i][to.handler] ! cancel.session
                            -- Wait for reply (can only be `cancel.confirm' in this case)
                            int.dec.handle.array[i][from.handler] ? CASE cancel.confirm
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                    int.msg.handle[to.handler] ! msg.int; i
                                    int.msg.handle[to.handler] ! msg.str; ": cancel.confirm"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                      TRUE
                        SKIP
                    --}}}
                    --{{{  Send close-session message to remote CTB-handler (via session-link-handle)
                    CLAIM session.link.handle
                      SEQ
                        --{{{  OUT message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
                                int.msg.handle[to.handler] ! msg.int; current.remote.node
                                int.msg.handle[to.handler] ! msg.str; ": insession.close.session; "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        -- Carrying: NCT-ID of the CTB-handler making the request
                        session.link.handle[to.handler] ! insession.close.session; own.nct.id
                    --}}}
                    --{{{  Cancel (or get ack from) all pending encode-handlers
                    SEQ i = 0 FOR num.readers.in.svr
                      IF
                        ulc.state.array[i] <> ULCSTATE.NONE
                          SEQ
                            IF
                              --{{{  Remaining CLCs pending
                              ulc.state.array[i] = ULCSTATE.RESTPENDING
                                SEQ
                                  -- Wait for `ack' from encode-handler (will definitely come)
                                  int.enc.handle.array[i][from.handler] ? CASE ack
                                  --{{{  IN message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                          int.msg.handle[to.handler] ! msg.str; ": IN int.ench "
                                          int.msg.handle[to.handler] ! msg.int; i
                                          int.msg.handle[to.handler] ! msg.str; ": ack"
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                                  -- Pass `ack' on to remote CTB-handler (via session-link-handle)
                                  CLAIM session.link.handle
                                    SEQ
                                      --{{{  OUT message
                                      IF
                                        output.msgs
                                          CLAIM int.msg.handle
                                            SEQ
                                              int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                                              int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
                                              int.msg.handle[to.handler] ! msg.int; current.remote.node
                                              int.msg.handle[to.handler] ! msg.str; ": insession.ack; "
                                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                                              int.msg.handle[to.handler] ! msg.str; "; "
                                              int.msg.handle[to.handler] ! msg.int; i
                                              int.msg.handle[to.handler] ! msg.end; FALSE
                                        TRUE
                                          SKIP
                                      --}}}
                                      -- Carrying: NCT-ID of the CTB-handler making the request;
                                      --           channel-ID of the relevant channel
                                      session.link.handle[to.handler] ! insession.ack; own.nct.id; i
                                  --{{{  Deal with special case if session-state is suspended
                                  IF
                                    session.state = SESSIONSTATE.SUSPENDED
                                      SEQ
                                        -- Update client-claim-state
                                        cli.claim.state := CLAIMSTATE.CLAIMED
                                        -- Send `eoi.done' to NCT-handler (via master-link-handle)
                                        CLAIM master.link.handle
                                          SEQ
                                            --{{{  OUT message
                                            IF
                                              output.msgs
                                                CLAIM int.msg.handle
                                                  SEQ
                                                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                    int.msg.handle[to.handler] ! msg.str; ": OUT linkh 0: forncthandler.eoi.done; "
                                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                    int.msg.handle[to.handler] ! msg.end; FALSE
                                              TRUE
                                                SKIP
                                            --}}}
                                            -- Carrying: NCT-ID of the CTB-handler making the request
                                            master.link.handle[to.handler] ! forncthandler.eoi.done; own.nct.id
                                    TRUE
                                      SKIP
                                  --}}}
                              --}}}
                              --{{{  First CLC pending
                              TRUE
                                SEQ
                                  -- Initiate `cancel.encode'
                                  --{{{  OUT message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                          int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
                                          int.msg.handle[to.handler] ! msg.int; i
                                          int.msg.handle[to.handler] ! msg.str; ": cancel.encode"
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                                  int.dec.handle.array[i][to.handler] ! cancel.encode
                                  -- Wait for `ack' from encode-handler
                                  int.enc.handle.array[i][from.handler] ? CASE ack
                                  --{{{  IN message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                          int.msg.handle[to.handler] ! msg.str; ": IN int.ench "
                                          int.msg.handle[to.handler] ! msg.int; i
                                          int.msg.handle[to.handler] ! msg.str; ": ack"
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                                  -- Send `cancel.encode.ack' to decode-handler
                                  --{{{  OUT message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                          int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
                                          int.msg.handle[to.handler] ! msg.int; i
                                          int.msg.handle[to.handler] ! msg.str; ": cancel.encode.ack"
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                                  int.dec.handle.array[i][to.handler] ! cancel.encode.ack
                                  -- Get reply from decode-handler
                                  int.dec.handle.array[i][from.handler] ? CASE
                                    --{{{  CLC was cancelled
                                    encode.cancelled
                                      SEQ
                                        --{{{  IN message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                                int.msg.handle[to.handler] ! msg.int; i
                                                int.msg.handle[to.handler] ! msg.str; ": encode.cancelled"
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        -- Cancel CLC in encode-handler
                                        --{{{  OUT message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                int.msg.handle[to.handler] ! msg.str; ": OUT int.ench "
                                                int.msg.handle[to.handler] ! msg.int; i
                                                int.msg.handle[to.handler] ! msg.str; ": cancel.session"
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        int.enc.handle.array[i][to.handler] ! cancel.session
                                        -- Send `cancel' to remote CTB-handler (via session-link-handle)
                                        CLAIM session.link.handle
                                          SEQ
                                            --{{{  OUT message
                                            IF
                                              output.msgs
                                                CLAIM int.msg.handle
                                                  SEQ
                                                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                    int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
                                                    int.msg.handle[to.handler] ! msg.int; current.remote.node
                                                    int.msg.handle[to.handler] ! msg.str; ": insession.cancel; "
                                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                    int.msg.handle[to.handler] ! msg.str; "; "
                                                    int.msg.handle[to.handler] ! msg.int; i
                                                    int.msg.handle[to.handler] ! msg.end; FALSE
                                              TRUE
                                                SKIP
                                            --}}}
                                            -- Carrying: NCT-ID of the CTB-handler making the request;
                                            --           channel-ID of the relevant channel
                                            session.link.handle[to.handler] ! insession.cancel; own.nct.id; i
                                    --}}}
                                    --{{{  CLC was not cancelled
                                    --       (can only be the case if there are no remaining CLCs)
                                    encode.not.cancelled
                                      SEQ
                                        --{{{  IN message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                                int.msg.handle[to.handler] ! msg.int; i
                                                int.msg.handle[to.handler] ! msg.str; ": encode.not.cancelled"
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        -- Send confirmation to encode-handler
                                        --{{{  OUT message
                                        IF
                                          output.msgs
                                            CLAIM int.msg.handle
                                              SEQ
                                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                int.msg.handle[to.handler] ! msg.str; ": OUT int.ench "
                                                int.msg.handle[to.handler] ! msg.int; i
                                                int.msg.handle[to.handler] ! msg.str; ": output.successful"
                                                int.msg.handle[to.handler] ! msg.end; FALSE
                                          TRUE
                                            SKIP
                                        --}}}
                                        int.enc.handle.array[i][to.handler] ! output.successful
                                        -- Pass `ack' on to remote CTB-handler (via session-link-handle)
                                        CLAIM session.link.handle
                                          SEQ
                                            --{{{  OUT message
                                            IF
                                              output.msgs
                                                CLAIM int.msg.handle
                                                  SEQ
                                                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                    int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
                                                    int.msg.handle[to.handler] ! msg.int; current.remote.node
                                                    int.msg.handle[to.handler] ! msg.str; ": insession.ack; "
                                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                    int.msg.handle[to.handler] ! msg.str; "; "
                                                    int.msg.handle[to.handler] ! msg.int; i
                                                    int.msg.handle[to.handler] ! msg.end; FALSE
                                              TRUE
                                                SKIP
                                            --}}}
                                            -- Carrying: NCT-ID of the CTB-handler making the request;
                                            --           channel-ID of the relevant channel
                                            session.link.handle[to.handler] ! insession.ack; own.nct.id; i
                                        --{{{  Deal with special case if session-state is suspended
                                        IF
                                          session.state = SESSIONSTATE.SUSPENDED
                                            SEQ
                                              -- Update client-claim-state
                                              cli.claim.state := CLAIMSTATE.CLAIMED
                                              -- Send `eoi.done' to NCT-handler (via master-link-handle)
                                              CLAIM master.link.handle
                                                SEQ
                                                  --{{{  OUT message
                                                  IF
                                                    output.msgs
                                                      CLAIM int.msg.handle
                                                        SEQ
                                                          int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                          int.msg.handle[to.handler] ! msg.str; ": OUT linkh 0: forncthandler.eoi.done; "
                                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                                    TRUE
                                                      SKIP
                                                  --}}}
                                                  -- Carrying: NCT-ID of the CTB-handler making the request
                                                  master.link.handle[to.handler] ! forncthandler.eoi.done; own.nct.id
                                          TRUE
                                            SKIP
                                        --}}}
                                    --}}}
                              --}}}
                            -- Update ULC-state of the pending ULC
                            ulc.state.array[i] := ULCSTATE.NONE
                        TRUE
                          SKIP
                    --}}}
                    --{{{  Wait for confirmation from remote CTB-handler
                    INITIAL BOOL running IS TRUE:
                    WHILE running
                      ctb.main.handle.svr[to.handler] ? CASE
                        --{{{  First CLC of a ULC
                        INT chan.id, di.nlcs.first, cte.nlcs.first:
                        BOOL has.rest.clcs:
                        MOBILE []BYTE data.array:
                        MOBILE []INT size.array:
                        -- Carrying: channel-ID of the relevant channel;
                        --           number of data-item NLCs in first CLC;
                        --           number of channel-type-end NLCs in first CLC;
                        --           are there remaining CLCs?;
                        --           data-array;
                        --           size-array
                        first.clc; chan.id; di.nlcs.first; cte.nlcs.first;
                                            has.rest.clcs;
                                            data.array; size.array
                          SEQ
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [to.handler]: first.clc; "
                                    int.msg.handle[to.handler] ! msg.int; chan.id
                                    int.msg.handle[to.handler] ! msg.str; "; "
                                    int.msg.handle[to.handler] ! msg.int; di.nlcs.first
                                    int.msg.handle[to.handler] ! msg.str; "; "
                                    int.msg.handle[to.handler] ! msg.int; cte.nlcs.first
                                    int.msg.handle[to.handler] ! msg.str; "; "
                                    int.msg.handle[to.handler] ! msg.bool; has.rest.clcs
                                    int.msg.handle[to.handler] ! msg.str; "; [array ("
                                    int.msg.handle[to.handler] ! msg.int; SIZE data.array
                                    int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                                    int.msg.handle[to.handler] ! msg.int; SIZE size.array
                                    int.msg.handle[to.handler] ! msg.str; ")]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Send `cancel' to remote CTB-handler (via session-link-handle)
                            CLAIM session.link.handle
                              SEQ
                                --{{{  OUT message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                                        int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
                                        int.msg.handle[to.handler] ! msg.int; current.remote.node
                                        int.msg.handle[to.handler] ! msg.str; ": insession.cancel; "
                                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                                        int.msg.handle[to.handler] ! msg.str; "; "
                                        int.msg.handle[to.handler] ! msg.int; chan.id
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                                -- Carrying: NCT-ID of the CTB-handler making the request;
                                --           channel-ID of the relevant channel
                                session.link.handle[to.handler] ! insession.cancel; own.nct.id; chan.id
                        --}}}
                        --{{{  Close session
                        close.session
                          SEQ
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [to.handler]: close.session"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Leave loop
                            running := FALSE
                        --}}}
                        --{{{  Suspend session
                        suspend.session
                          --{{{  IN message
                          IF
                            output.msgs
                              CLAIM int.msg.handle
                                SEQ
                                  int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                                  int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [to.handler]: suspend.session"
                                  int.msg.handle[to.handler] ! msg.end; FALSE
                            TRUE
                              SKIP
                          --}}}
                        --}}}
                    --}}}
                TRUE
                  SKIP
              --}}}
              -- Send release request to NCT-handler (via master-link-handle)
              CLAIM master.link.handle
                SEQ
                  --{{{  OUT message
                  IF
                    output.msgs
                      CLAIM int.msg.handle
                        SEQ
                          int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                          int.msg.handle[to.handler] ! msg.str; ": OUT linkh 0: forncthandler.release.svr; "
                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                          int.msg.handle[to.handler] ! msg.end; FALSE
                    TRUE
                      SKIP
                  --}}}
                  -- Carrying: NCT-ID of the CTB-handler making the request
                  master.link.handle[to.handler] ! forncthandler.release.svr; own.nct.id
              -- Wait for reply (via CTB-main-handle)
              INT any:
              -- Carrying: node-ID of the other end's node (dummy in this case)
              ctb.main.handle.svr[from.ncthandler.re.server] ? CASE new.other.end; any
              --{{{  IN message
              IF
                output.msgs
                  CLAIM int.msg.handle
                    SEQ
                      int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                      int.msg.handle[to.handler] ! msg.int; own.nct.id
                      int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [from.ncthandler.re.server]: new.other.end; [any-int]"
                      int.msg.handle[to.handler] ! msg.end; FALSE
                TRUE
                  SKIP
              --}}}
              -- Update session-state
              session.state := SESSIONSTATE.NONE
              -- Update current remote node
              current.remote.node := -1
              -- Update current remote node in instant-handler
              update.current.remote.node ! current.remote.node
              -- Update server-claim-state
              svr.claim.state := CLAIMSTATE.RELEASED
              -- Release server-listener
              release.svr.listener ! TRUE
          --}}}
          ALT chan.id = 0 FOR num.chans
            ALT
              --{{{  Get `first.clc' from decode-handler
              INT di.nlcs.first, cte.nlcs.first:
              BOOL has.rest.clcs:
              -- Carrying: number of data-item NLCs in first CLC;
              --           number of channel-type-end NLCs in first CLC;
              --           are there remaining CLCs?
              int.dec.handle.array[chan.id][from.handler] ? CASE first.clc;
                                                                 di.nlcs.first; cte.nlcs.first;
                                                                 has.rest.clcs
                SEQ
                  --{{{  IN message
                  IF
                    output.msgs
                      CLAIM int.msg.handle
                        SEQ
                          int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                          int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                          int.msg.handle[to.handler] ! msg.int; chan.id
                          int.msg.handle[to.handler] ! msg.str; ": first.clc; "
                          int.msg.handle[to.handler] ! msg.int; di.nlcs.first
                          int.msg.handle[to.handler] ! msg.str; "; "
                          int.msg.handle[to.handler] ! msg.int; cte.nlcs.first
                          int.msg.handle[to.handler] ! msg.str; "; "
                          int.msg.handle[to.handler] ! msg.bool; has.rest.clcs
                          int.msg.handle[to.handler] ! msg.end; FALSE
                    TRUE
                      SKIP
                  --}}}
                  -- Update ULC-state
                  IF
                    has.rest.clcs
                      ulc.state.array[chan.id] := ULCSTATE.FIRSTPENDING.MORETOCOME
                    TRUE
                      ulc.state.array[chan.id] := ULCSTATE.FIRSTPENDING.JUSTONE
                  -- Get first CLC
                  int.dec.handle.array[chan.id][from.handler] ? CASE
                    --{{{  First CLC is an end-over-itself-CLC
                    end.over.itself.clc
                      MOBILE []INT addr.array, size.array:
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                int.msg.handle[to.handler] ! msg.int; chan.id
                                int.msg.handle[to.handler] ! msg.str; ": end.over.itself.clc"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        --{{{  Get the CLC itself
                        -- Carrying: address-array;
                        --           size-array
                        int.dec.handle.array[chan.id][from.handler] ? CASE clc; addr.array; size.array
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                int.msg.handle[to.handler] ! msg.int; chan.id
                                int.msg.handle[to.handler] ! msg.str; ": clc; [array ("
                                int.msg.handle[to.handler] ! msg.int; SIZE addr.array
                                int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                                int.msg.handle[to.handler] ! msg.int; SIZE size.array
                                int.msg.handle[to.handler] ! msg.str; ")]"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        --}}}
                        --{{{  Deactivate all decode-handlers (except this one)
                        SEQ i = 0 FOR num.chans
                          IF
                            (i <> chan.id) AND
                                (((cli.claim.state = CLAIMSTATE.CLAIMED) AND (i < num.readers.in.svr)) OR
                                ((svr.claim.state = CLAIMSTATE.CLAIMED) AND (i >= num.readers.in.svr)))
                              SEQ
                                --{{{  OUT message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                                        int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
                                        int.msg.handle[to.handler] ! msg.int; i
                                        int.msg.handle[to.handler] ! msg.str; ": cancel.session"
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                                int.dec.handle.array[i][to.handler] ! cancel.session
                                -- Wait for reply (can only be `cancel.confirm' in this case)
                                int.dec.handle.array[i][from.handler] ? CASE cancel.confirm
                                --{{{  IN message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                                        int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                        int.msg.handle[to.handler] ! msg.int; i
                                        int.msg.handle[to.handler] ! msg.str; ": cancel.confirm"
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                            TRUE
                              SKIP
                        --}}}
                        --{{{  Send suspend-session message to remote CTB-handler (via session-link-handle)
                        CLAIM session.link.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
                                    int.msg.handle[to.handler] ! msg.int; current.remote.node
                                    int.msg.handle[to.handler] ! msg.str; ": insession.suspend.session; "
                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID of the CTB-handler making the request
                            session.link.handle[to.handler] ! insession.suspend.session; own.nct.id
                        --}}}
                        --{{{  Cancel (or get ack from) all pending encode-handlers
                        SEQ i = 0 FOR num.chans
                          IF
                            (ulc.state.array[i] <> ULCSTATE.NONE) AND
                                (((cli.claim.state = CLAIMSTATE.CLAIMED) AND (i >= num.readers.in.svr)) OR
                                ((svr.claim.state = CLAIMSTATE.CLAIMED) AND (i < num.readers.in.svr)))
                              SEQ
                                IF
                                  --{{{  Remaining CLCs pending
                                  ulc.state.array[i] = ULCSTATE.RESTPENDING
                                    SEQ
                                      -- Wait for `ack' from encode-handler (will definitely come)
                                      int.enc.handle.array[i][from.handler] ? CASE ack
                                      --{{{  IN message
                                      IF
                                        output.msgs
                                          CLAIM int.msg.handle
                                            SEQ
                                              int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                                              int.msg.handle[to.handler] ! msg.str; ": IN int.ench "
                                              int.msg.handle[to.handler] ! msg.int; i
                                              int.msg.handle[to.handler] ! msg.str; ": ack"
                                              int.msg.handle[to.handler] ! msg.end; FALSE
                                        TRUE
                                          SKIP
                                      --}}}
                                      -- Pass `ack' on to remote CTB-handler (via session-link-handle)
                                      CLAIM session.link.handle
                                        SEQ
                                          --{{{  OUT message
                                          IF
                                            output.msgs
                                              CLAIM int.msg.handle
                                                SEQ
                                                  int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                  int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
                                                  int.msg.handle[to.handler] ! msg.int; current.remote.node
                                                  int.msg.handle[to.handler] ! msg.str; ": insession.ack; "
                                                  int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                  int.msg.handle[to.handler] ! msg.str; "; "
                                                  int.msg.handle[to.handler] ! msg.int; i
                                                  int.msg.handle[to.handler] ! msg.end; FALSE
                                            TRUE
                                              SKIP
                                          --}}}
                                          -- Carrying: NCT-ID of the CTB-handler making the request;
                                          --           channel-ID of the relevant channel
                                          session.link.handle[to.handler] ! insession.ack; own.nct.id; i
                                  --}}}
                                  --{{{  First CLC pending
                                  TRUE
                                    SEQ
                                      -- Initiate `cancel.encode'
                                      --{{{  OUT message
                                      IF
                                        output.msgs
                                          CLAIM int.msg.handle
                                            SEQ
                                              int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                                              int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
                                              int.msg.handle[to.handler] ! msg.int; i
                                              int.msg.handle[to.handler] ! msg.str; ": cancel.encode"
                                              int.msg.handle[to.handler] ! msg.end; FALSE
                                        TRUE
                                          SKIP
                                      --}}}
                                      int.dec.handle.array[i][to.handler] ! cancel.encode
                                      -- Wait for `ack' from encode-handler
                                      int.enc.handle.array[i][from.handler] ? CASE ack
                                      --{{{  IN message
                                      IF
                                        output.msgs
                                          CLAIM int.msg.handle
                                            SEQ
                                              int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                                              int.msg.handle[to.handler] ! msg.str; ": IN int.ench "
                                              int.msg.handle[to.handler] ! msg.int; i
                                              int.msg.handle[to.handler] ! msg.str; ": ack"
                                              int.msg.handle[to.handler] ! msg.end; FALSE
                                        TRUE
                                          SKIP
                                      --}}}
                                      -- Send `cancel.encode.ack' to decode-handler
                                      --{{{  OUT message
                                      IF
                                        output.msgs
                                          CLAIM int.msg.handle
                                            SEQ
                                              int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                                              int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
                                              int.msg.handle[to.handler] ! msg.int; i
                                              int.msg.handle[to.handler] ! msg.str; ": cancel.encode.ack"
                                              int.msg.handle[to.handler] ! msg.end; FALSE
                                        TRUE
                                          SKIP
                                      --}}}
                                      int.dec.handle.array[i][to.handler] ! cancel.encode.ack
                                      -- Get reply from decode-handler
                                      int.dec.handle.array[i][from.handler] ? CASE
                                        --{{{  CLC was cancelled
                                        encode.cancelled
                                          SEQ
                                            --{{{  IN message
                                            IF
                                              output.msgs
                                                CLAIM int.msg.handle
                                                  SEQ
                                                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                    int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                                    int.msg.handle[to.handler] ! msg.int; i
                                                    int.msg.handle[to.handler] ! msg.str; ": encode.cancelled"
                                                    int.msg.handle[to.handler] ! msg.end; FALSE
                                              TRUE
                                                SKIP
                                            --}}}
                                            -- Cancel CLC in encode-handler
                                            --{{{  OUT message
                                            IF
                                              output.msgs
                                                CLAIM int.msg.handle
                                                  SEQ
                                                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                    int.msg.handle[to.handler] ! msg.str; ": OUT int.ench "
                                                    int.msg.handle[to.handler] ! msg.int; i
                                                    int.msg.handle[to.handler] ! msg.str; ": cancel.session"
                                                    int.msg.handle[to.handler] ! msg.end; FALSE
                                              TRUE
                                                SKIP
                                            --}}}
                                            int.enc.handle.array[i][to.handler] ! cancel.session
                                            -- Send `cancel' to remote CTB-handler (via session-link-handle)
                                            CLAIM session.link.handle
                                              SEQ
                                                --{{{  OUT message
                                                IF
                                                  output.msgs
                                                    CLAIM int.msg.handle
                                                      SEQ
                                                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                        int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
                                                        int.msg.handle[to.handler] ! msg.int; current.remote.node
                                                        int.msg.handle[to.handler] ! msg.str; ": insession.cancel; "
                                                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                        int.msg.handle[to.handler] ! msg.str; "; "
                                                        int.msg.handle[to.handler] ! msg.int; i
                                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                                  TRUE
                                                    SKIP
                                                --}}}
                                                -- Carrying: NCT-ID of the CTB-handler making the request;
                                                --           channel-ID of the relevant channel
                                                session.link.handle[to.handler] ! insession.cancel; own.nct.id; i
                                        --}}}
                                        --{{{  CLC was not cancelled
                                        --       (can only be the case if there are no remaining CLCs)
                                        encode.not.cancelled
                                          SEQ
                                            --{{{  IN message
                                            IF
                                              output.msgs
                                                CLAIM int.msg.handle
                                                  SEQ
                                                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                    int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                                    int.msg.handle[to.handler] ! msg.int; i
                                                    int.msg.handle[to.handler] ! msg.str; ": encode.not.cancelled"
                                                    int.msg.handle[to.handler] ! msg.end; FALSE
                                              TRUE
                                                SKIP
                                            --}}}
                                            -- Send confirmation to encode-handler
                                            --{{{  OUT message
                                            IF
                                              output.msgs
                                                CLAIM int.msg.handle
                                                  SEQ
                                                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                    int.msg.handle[to.handler] ! msg.str; ": OUT int.ench "
                                                    int.msg.handle[to.handler] ! msg.int; i
                                                    int.msg.handle[to.handler] ! msg.str; ": output.successful"
                                                    int.msg.handle[to.handler] ! msg.end; FALSE
                                              TRUE
                                                SKIP
                                            --}}}
                                            int.enc.handle.array[i][to.handler] ! output.successful
                                            -- Pass `ack' on to remote CTB-handler (via session-link-handle)
                                            CLAIM session.link.handle
                                              SEQ
                                                --{{{  OUT message
                                                IF
                                                  output.msgs
                                                    CLAIM int.msg.handle
                                                      SEQ
                                                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                        int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
                                                        int.msg.handle[to.handler] ! msg.int; current.remote.node
                                                        int.msg.handle[to.handler] ! msg.str; ": insession.ack; "
                                                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                                                        int.msg.handle[to.handler] ! msg.str; "; "
                                                        int.msg.handle[to.handler] ! msg.int; i
                                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                                  TRUE
                                                    SKIP
                                                --}}}
                                                -- Carrying: NCT-ID of the CTB-handler making the request;
                                                --           channel-ID of the relevant channel
                                                session.link.handle[to.handler] ! insession.ack; own.nct.id; i
                                        --}}}
                                  --}}}
                                -- Update ULC-state of the pending ULC
                                ulc.state.array[i] := ULCSTATE.NONE
                            TRUE
                              SKIP
                        --}}}
                        --{{{  Wait for suspend-session-confirmation from remote CTB-handler
                        INITIAL BOOL running IS TRUE:
                        WHILE running
                          ctb.main.handle.svr[to.handler] ? CASE
                            --{{{  First CLC of a ULC
                            INT chan.id, di.nlcs.first, cte.nlcs.first:
                            BOOL has.rest.clcs:
                            MOBILE []BYTE data.array:
                            MOBILE []INT size.array:
                            -- Carrying: channel-ID of the relevant channel;
                            --           number of data-item NLCs in first CLC;
                            --           number of channel-type-end NLCs in first CLC;
                            --           are there remaining CLCs?;
                            --           data-array;
                            --           size-array
                            first.clc; chan.id; di.nlcs.first; cte.nlcs.first;
                                                has.rest.clcs;
                                                data.array; size.array
                              SEQ
                                --{{{  IN message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                                        int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [to.handler]: first.clc; "
                                        int.msg.handle[to.handler] ! msg.int; chan.id
                                        int.msg.handle[to.handler] ! msg.str; "; "
                                        int.msg.handle[to.handler] ! msg.int; di.nlcs.first
                                        int.msg.handle[to.handler] ! msg.str; "; "
                                        int.msg.handle[to.handler] ! msg.int; cte.nlcs.first
                                        int.msg.handle[to.handler] ! msg.str; "; "
                                        int.msg.handle[to.handler] ! msg.bool; has.rest.clcs
                                        int.msg.handle[to.handler] ! msg.str; "; [array ("
                                        int.msg.handle[to.handler] ! msg.int; SIZE data.array
                                        int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                                        int.msg.handle[to.handler] ! msg.int; SIZE size.array
                                        int.msg.handle[to.handler] ! msg.str; ")]"
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                                -- Send `cancel' to remote CTB-handler (via session-link-handle)
                                CLAIM session.link.handle
                                  SEQ
                                    --{{{  OUT message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                                            int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
                                            int.msg.handle[to.handler] ! msg.int; current.remote.node
                                            int.msg.handle[to.handler] ! msg.str; ": insession.cancel; "
                                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                                            int.msg.handle[to.handler] ! msg.str; "; "
                                            int.msg.handle[to.handler] ! msg.int; chan.id
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    -- Carrying: NCT-ID of the CTB-handler making the request;
                                    --           channel-ID of the relevant channel
                                    session.link.handle[to.handler] ! insession.cancel; own.nct.id; chan.id
                            --}}}
                            --{{{  Close session
                            close.session
                              SEQ
                                --{{{  IN message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                                        int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [to.handler]: close.session"
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                                -- Deactivate the decode-handler that caused the eoi
                                --{{{  OUT message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                                        int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
                                        int.msg.handle[to.handler] ! msg.int; chan.id
                                        int.msg.handle[to.handler] ! msg.str; ": cancel.session"
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                                int.dec.handle.array[chan.id][to.handler] ! cancel.session
                                -- Wait for reply
                                int.dec.handle.array[chan.id][from.handler] ? CASE cancel.confirm
                                --{{{  IN message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                                        int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                        int.msg.handle[to.handler] ! msg.int; chan.id
                                        int.msg.handle[to.handler] ! msg.str; ": cancel.confirm"
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                                -- Update ULC-state of the eoi-ULC
                                ulc.state.array[chan.id] := ULCSTATE.NONE
                                -- Send close-session message to remote CTB-handler (via session-link-handle)
                                CLAIM session.link.handle
                                  SEQ
                                    --{{{  OUT message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                                            int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
                                            int.msg.handle[to.handler] ! msg.int; current.remote.node
                                            int.msg.handle[to.handler] ! msg.str; ": insession.close.session; "
                                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    -- Carrying: NCT-ID of the CTB-handler making the request
                                    session.link.handle[to.handler] ! insession.close.session; own.nct.id
                                -- Update session-state
                                session.state := SESSIONSTATE.NONE
                                -- Update current remote node
                                current.remote.node := -1
                                -- Update current remote node in instant-handler
                                update.current.remote.node ! current.remote.node
                                -- Leave loop
                                running := FALSE
                            --}}}
                            --{{{  Suspend session
                            suspend.session
                              --{{{  IN message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; own.nct.id
                                      int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [to.handler]: suspend.session"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              -- Leave this NCT to deadlock
                              --   (as would a local channel-type in the same situation)
                            --}}}
                            --{{{  Confirm `suspend.session'
                            suspend.session.confirm
                              SEQ
                                --{{{  IN message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                                        int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [to.handler]: suspend.session.confirm"
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                                -- Update session-state
                                session.state := SESSIONSTATE.SENDINGEOI
                                -- Send eio-CLC to remote CTB-handler (via session-link-handle)
                                CLAIM session.link.handle
                                  SEQ
                                    --{{{  OUT message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                                            int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
                                            int.msg.handle[to.handler] ! msg.int; current.remote.node
                                            int.msg.handle[to.handler] ! msg.str; ": insession.first.clc; "
                                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                                            int.msg.handle[to.handler] ! msg.str; "; "
                                            int.msg.handle[to.handler] ! msg.int; chan.id
                                            int.msg.handle[to.handler] ! msg.str; "; "
                                            int.msg.handle[to.handler] ! msg.int; di.nlcs.first
                                            int.msg.handle[to.handler] ! msg.str; "; "
                                            int.msg.handle[to.handler] ! msg.int; cte.nlcs.first
                                            int.msg.handle[to.handler] ! msg.str; "; "
                                            int.msg.handle[to.handler] ! msg.bool; has.rest.clcs
                                            int.msg.handle[to.handler] ! msg.str; "; [array ("
                                            int.msg.handle[to.handler] ! msg.int; SIZE addr.array
                                            int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                                            int.msg.handle[to.handler] ! msg.int; SIZE size.array
                                            int.msg.handle[to.handler] ! msg.str; ")]"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                    -- Carrying: NCT-ID of the CTB-handler making the request;
                                    --           channel-ID of the relevant channel;
                                    --           number of data-item NLCs in first CLC;
                                    --           number of channel-type-end NLCs in first CLC;
                                    --           are there remaining CLCs?;
                                    --           address-array;
                                    --           size-array
                                    session.link.handle[to.handler] ! insession.first.clc; own.nct.id; chan.id;
                                                                      di.nlcs.first; cte.nlcs.first;
                                                                      has.rest.clcs;
                                                                      addr.array; size.array
                                -- Leave loop
                                running := FALSE
                            --}}}
                        --}}}
                    --}}}
                    --{{{  CLC itself (no eoi)
                    MOBILE []INT addr.array, size.array:
                    -- Carrying: address-array;
                    --           size-array
                    clc; addr.array; size.array
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                int.msg.handle[to.handler] ! msg.int; chan.id
                                int.msg.handle[to.handler] ! msg.str; ": clc; [array ("
                                int.msg.handle[to.handler] ! msg.int; SIZE addr.array
                                int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                                int.msg.handle[to.handler] ! msg.int; SIZE size.array
                                int.msg.handle[to.handler] ! msg.str; ")]"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        -- Pass CLC on to remote CTB-handler (via session-link-handle)
                        CLAIM session.link.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
                                    int.msg.handle[to.handler] ! msg.int; current.remote.node
                                    int.msg.handle[to.handler] ! msg.str; ": insession.first.clc; "
                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                    int.msg.handle[to.handler] ! msg.str; "; "
                                    int.msg.handle[to.handler] ! msg.int; chan.id
                                    int.msg.handle[to.handler] ! msg.str; "; "
                                    int.msg.handle[to.handler] ! msg.int; di.nlcs.first
                                    int.msg.handle[to.handler] ! msg.str; "; "
                                    int.msg.handle[to.handler] ! msg.int; cte.nlcs.first
                                    int.msg.handle[to.handler] ! msg.str; "; "
                                    int.msg.handle[to.handler] ! msg.bool; has.rest.clcs
                                    int.msg.handle[to.handler] ! msg.str; "; [array ("
                                    int.msg.handle[to.handler] ! msg.int; SIZE addr.array
                                    int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                                    int.msg.handle[to.handler] ! msg.int; SIZE size.array
                                    int.msg.handle[to.handler] ! msg.str; ")]"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID of the CTB-handler making the request;
                            --           channel-ID of the relevant channel;
                            --           number of data-item NLCs in first CLC;
                            --           number of channel-type-end NLCs in first CLC;
                            --           are there remaining CLCs?;
                            --           address-array;
                            --           size-array
                            session.link.handle[to.handler] ! insession.first.clc; own.nct.id; chan.id;
                                                              di.nlcs.first; cte.nlcs.first;
                                                              has.rest.clcs;
                                                              addr.array; size.array
                    --}}}
              --}}}
              --{{{  Get `ack' from encode-handler
              int.enc.handle.array[chan.id][from.handler] ? CASE ack
                SEQ
                  --{{{  IN message
                  IF
                    output.msgs
                      CLAIM int.msg.handle
                        SEQ
                          int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                          int.msg.handle[to.handler] ! msg.str; ": IN int.ench "
                          int.msg.handle[to.handler] ! msg.int; chan.id
                          int.msg.handle[to.handler] ! msg.str; ": ack"
                          int.msg.handle[to.handler] ! msg.end; FALSE
                    TRUE
                      SKIP
                  --}}}
                  -- Pass `ack' on to remote CTB-handler (via session-link-handle)
                  CLAIM session.link.handle
                    SEQ
                      --{{{  OUT message
                      IF
                        output.msgs
                          CLAIM int.msg.handle
                            SEQ
                              int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                              int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
                              int.msg.handle[to.handler] ! msg.int; current.remote.node
                              int.msg.handle[to.handler] ! msg.str; ": insession.ack; "
                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                              int.msg.handle[to.handler] ! msg.str; "; "
                              int.msg.handle[to.handler] ! msg.int; chan.id
                              int.msg.handle[to.handler] ! msg.end; FALSE
                        TRUE
                          SKIP
                      --}}}
                      -- Carrying: NCT-ID of the CTB-handler making the request;
                      --           channel-ID of the relevant channel
                      session.link.handle[to.handler] ! insession.ack; own.nct.id; chan.id
                  --{{{  Deal with special case if session-state is suspended
                  IF
                    (session.state = SESSIONSTATE.SUSPENDED) AND
                        ((ulc.state.array[chan.id] = ULCSTATE.FIRSTPENDING.JUSTONE) OR
                        (ulc.state.array[chan.id] = ULCSTATE.RESTPENDING))
                      SEQ
                        -- Update session-state and claim-states
                        session.state := SESSIONSTATE.INT
                        cli.claim.state := CLAIMSTATE.CLAIMED
                        svr.claim.state := CLAIMSTATE.CLAIMED
                        -- Update current remote node
                        current.remote.node := own.node.id
                        -- Update current remote node in instant-handler
                        update.current.remote.node ! current.remote.node
                        -- Send `eoi.done' to NCT-handler (via master-link-handle)
                        CLAIM master.link.handle
                          SEQ
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT linkh 0: forncthandler.eoi.done; "
                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            -- Carrying: NCT-ID of the CTB-handler making the request
                            master.link.handle[to.handler] ! forncthandler.eoi.done; own.nct.id
                    TRUE
                      SKIP
                  --}}}
                  --{{{  Update ULC-state if this was ULC's last CLC
                  IF
                    ulc.state.array[chan.id] = ULCSTATE.FIRSTPENDING.JUSTONE
                      SEQ
                        -- Send confirmation to encode-handler
                        --{{{  OUT message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; ": OUT int.ench "
                                int.msg.handle[to.handler] ! msg.int; chan.id
                                int.msg.handle[to.handler] ! msg.str; ": output.successful"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        int.enc.handle.array[chan.id][to.handler] ! output.successful
                        -- Update ULC-state
                        ulc.state.array[chan.id] := ULCSTATE.NONE
                    ulc.state.array[chan.id] = ULCSTATE.RESTPENDING
                      -- Update ULC-state
                      ulc.state.array[chan.id] := ULCSTATE.NONE
                    TRUE
                      SKIP
                  --}}}
              --}}}
          ctb.main.handle.svr[to.handler] ? CASE
            --{{{  First CLC of a ULC
            INT chan.id, di.nlcs.first, cte.nlcs.first:
            BOOL has.rest.clcs:
            MOBILE []BYTE data.array:
            MOBILE []INT size.array:
            -- Carrying: channel-ID of the relevant channel;
            --           number of data-item NLCs in first CLC;
            --           number of channel-type-end NLCs in first CLC;
            --           are there remaining CLCs?;
            --           data-array;
            --           size-array
            first.clc; chan.id; di.nlcs.first; cte.nlcs.first;
                                has.rest.clcs;
                                data.array; size.array
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [to.handler]: first.clc; "
                        int.msg.handle[to.handler] ! msg.int; chan.id
                        int.msg.handle[to.handler] ! msg.str; "; "
                        int.msg.handle[to.handler] ! msg.int; di.nlcs.first
                        int.msg.handle[to.handler] ! msg.str; "; "
                        int.msg.handle[to.handler] ! msg.int; cte.nlcs.first
                        int.msg.handle[to.handler] ! msg.str; "; "
                        int.msg.handle[to.handler] ! msg.bool; has.rest.clcs
                        int.msg.handle[to.handler] ! msg.str; "; [array ("
                        int.msg.handle[to.handler] ! msg.int; SIZE data.array
                        int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                        int.msg.handle[to.handler] ! msg.int; SIZE size.array
                        int.msg.handle[to.handler] ! msg.str; ")]"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                -- Update ULC-state
                IF
                  has.rest.clcs
                    ulc.state.array[chan.id] := ULCSTATE.FIRSTPENDING.MORETOCOME
                  TRUE
                    ulc.state.array[chan.id] := ULCSTATE.FIRSTPENDING.JUSTONE
                -- Send `first.clc' to encode-handler
                --{{{  OUT message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; ": OUT int.ench "
                        int.msg.handle[to.handler] ! msg.int; chan.id
                        int.msg.handle[to.handler] ! msg.str; ": first.clc; "
                        int.msg.handle[to.handler] ! msg.int; di.nlcs.first
                        int.msg.handle[to.handler] ! msg.str; "; "
                        int.msg.handle[to.handler] ! msg.int; cte.nlcs.first
                        int.msg.handle[to.handler] ! msg.str; "; "
                        int.msg.handle[to.handler] ! msg.bool; has.rest.clcs
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                -- Carrying: number of data-item NLCs in first CLC;
                --           number of channel-type-end NLCs in first CLC;
                --           are there remaining CLCs?
                int.enc.handle.array[chan.id][to.handler] ! first.clc;
                                                            di.nlcs.first; cte.nlcs.first;
                                                            has.rest.clcs
                -- Send `clc' to encode-handler
                --{{{  OUT message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; ": OUT int.ench "
                        int.msg.handle[to.handler] ! msg.int; chan.id
                        int.msg.handle[to.handler] ! msg.str; ": clc; [array ("
                        int.msg.handle[to.handler] ! msg.int; SIZE data.array
                        int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                        int.msg.handle[to.handler] ! msg.int; SIZE size.array
                        int.msg.handle[to.handler] ! msg.str; ")]"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                -- Carrying: data-array;
                --           size-array
                int.enc.handle.array[chan.id][to.handler] ! clc; data.array; size.array
            --}}}
            --{{{  Remaining CLCs of a ULC
            INT chan.id, di.nlcs.rest, cte.nlcs.rest:
            MOBILE []BYTE data.array:
            MOBILE []INT size.array:
            -- Carrying: channel-ID of the relevant channel;
            --           number of data-item NLCs in remaining CLCs;
            --           number of channel-type-end NLCs in remaining CLCs;
            --           data-array;
            --           size-array
            rest.clcs; chan.id; di.nlcs.rest; cte.nlcs.rest; data.array; size.array
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [to.handler]: rest.clcs; "
                        int.msg.handle[to.handler] ! msg.int; chan.id
                        int.msg.handle[to.handler] ! msg.str; "; "
                        int.msg.handle[to.handler] ! msg.int; di.nlcs.rest
                        int.msg.handle[to.handler] ! msg.str; "; "
                        int.msg.handle[to.handler] ! msg.int; cte.nlcs.rest
                        int.msg.handle[to.handler] ! msg.str; "; [array ("
                        int.msg.handle[to.handler] ! msg.int; SIZE data.array
                        int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                        int.msg.handle[to.handler] ! msg.int; SIZE size.array
                        int.msg.handle[to.handler] ! msg.str; ")]"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                -- Update ULC-state
                ulc.state.array[chan.id] := ULCSTATE.RESTPENDING
                -- Send `rest.clcs' to encode-handler
                -- Carrying: number of data-item NLCs in remaining CLCs;
                --           number of channel-type-end NLCs in remaining CLCs
                --{{{  OUT message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; ": OUT int.ench "
                        int.msg.handle[to.handler] ! msg.int; chan.id
                        int.msg.handle[to.handler] ! msg.str; ": rest.clcs; "
                        int.msg.handle[to.handler] ! msg.int; di.nlcs.rest
                        int.msg.handle[to.handler] ! msg.str; "; "
                        int.msg.handle[to.handler] ! msg.int; cte.nlcs.rest
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                int.enc.handle.array[chan.id][to.handler] ! rest.clcs; di.nlcs.rest; cte.nlcs.rest
                -- Send `clc' to encode-handler
                --{{{  OUT message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; ": OUT int.ench "
                        int.msg.handle[to.handler] ! msg.int; chan.id
                        int.msg.handle[to.handler] ! msg.str; ": clc; [array ("
                        int.msg.handle[to.handler] ! msg.int; SIZE data.array
                        int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                        int.msg.handle[to.handler] ! msg.int; SIZE size.array
                        int.msg.handle[to.handler] ! msg.str; ")]"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                -- Carrying: data-array;
                --           size-array
                int.enc.handle.array[chan.id][to.handler] ! clc; data.array; size.array
            --}}}
	    --{{{  Acknowledge CLC
	    INT chan.id:
	    -- Carrying: channel-ID of the relevant channel
	    ack; chan.id
	      SEQ
		--{{{  IN message
		IF
		  output.msgs
		    CLAIM int.msg.handle
		      SEQ
			int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
			int.msg.handle[to.handler] ! msg.int; own.nct.id
			int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [to.handler]: ack; "
			int.msg.handle[to.handler] ! msg.int; chan.id
			int.msg.handle[to.handler] ! msg.end; FALSE
		  TRUE
		    SKIP
		--}}}
		-- Pass ack on to decode-handler
		--{{{  OUT message
		IF
		  output.msgs
		    CLAIM int.msg.handle
		      SEQ
			int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
			int.msg.handle[to.handler] ! msg.int; own.nct.id
			int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
			int.msg.handle[to.handler] ! msg.int; chan.id
			int.msg.handle[to.handler] ! msg.str; ": ack"
			int.msg.handle[to.handler] ! msg.end; FALSE
		  TRUE
		    SKIP
		--}}}
		int.dec.handle.array[chan.id][to.handler] ! ack
		IF
		  --{{{  There are remaining CLCs
		  ulc.state.array[chan.id] = ULCSTATE.FIRSTPENDING.MORETOCOME
		    INT di.nlcs.rest, cte.nlcs.rest:
		    SEQ
		      -- Update ULC-state
		      ulc.state.array[chan.id] := ULCSTATE.RESTPENDING
		      -- Get `rest.clcs' from decode-handler
		      -- Carrying: number of data-item NLCs in remaining CLCs;
		      --           number of channel-type-end NLCs in remaining CLCs
		      int.dec.handle.array[chan.id][from.handler] ? CASE rest.clcs;
                                                                         di.nlcs.rest; cte.nlcs.rest
		      --{{{  IN message
		      IF
			output.msgs
			  CLAIM int.msg.handle
			    SEQ
			      int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
			      int.msg.handle[to.handler] ! msg.int; own.nct.id
			      int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
			      int.msg.handle[to.handler] ! msg.int; chan.id
			      int.msg.handle[to.handler] ! msg.str; ": rest.clcs; "
			      int.msg.handle[to.handler] ! msg.int; di.nlcs.rest
			      int.msg.handle[to.handler] ! msg.str; "; "
			      int.msg.handle[to.handler] ! msg.int; cte.nlcs.rest
			      int.msg.handle[to.handler] ! msg.end; FALSE
			TRUE
			  SKIP
		      --}}}
		      -- Get remaining CLCs
		      int.dec.handle.array[chan.id][from.handler] ? CASE
			--{{{  Remaining CLCs are end-over-itself
			end.over.itself.clc
			  MOBILE []INT addr.array, size.array:
			  SEQ
			    --{{{  IN message
			    IF
			      output.msgs
				CLAIM int.msg.handle
				  SEQ
				    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
				    int.msg.handle[to.handler] ! msg.int; own.nct.id
				    int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
				    int.msg.handle[to.handler] ! msg.int; chan.id
				    int.msg.handle[to.handler] ! msg.str; ": end.over.itself.clc"
				    int.msg.handle[to.handler] ! msg.end; FALSE
			      TRUE
				SKIP
			    --}}}
			    --{{{  Get the CLC itself
			    -- Carrying: address-array;
			    --           size-array
			    int.dec.handle.array[chan.id][from.handler] ? CASE clc; addr.array; size.array
			    --{{{  IN message
			    IF
			      output.msgs
				CLAIM int.msg.handle
				  SEQ
				    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
				    int.msg.handle[to.handler] ! msg.int; own.nct.id
				    int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
				    int.msg.handle[to.handler] ! msg.int; chan.id
				    int.msg.handle[to.handler] ! msg.str; ": clc; [array ("
				    int.msg.handle[to.handler] ! msg.int; SIZE addr.array
				    int.msg.handle[to.handler] ! msg.str; ")]; [array ("
				    int.msg.handle[to.handler] ! msg.int; SIZE size.array
				    int.msg.handle[to.handler] ! msg.str; ")]"
				    int.msg.handle[to.handler] ! msg.end; FALSE
			      TRUE
				SKIP
			    --}}}
			    --}}}
			    --{{{  Deactivate all decode-handlers (except this one)
			    SEQ i = 0 FOR num.chans
			      IF
				(i <> chan.id) AND
				    (((cli.claim.state = CLAIMSTATE.CLAIMED) AND (i < num.readers.in.svr)) OR
				    ((svr.claim.state = CLAIMSTATE.CLAIMED) AND (i >= num.readers.in.svr)))
				  SEQ
				    --{{{  OUT message
				    IF
				      output.msgs
					CLAIM int.msg.handle
					  SEQ
					    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
					    int.msg.handle[to.handler] ! msg.int; own.nct.id
					    int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
					    int.msg.handle[to.handler] ! msg.int; i
					    int.msg.handle[to.handler] ! msg.str; ": cancel.session"
					    int.msg.handle[to.handler] ! msg.end; FALSE
				      TRUE
					SKIP
				    --}}}
				    int.dec.handle.array[i][to.handler] ! cancel.session
				    -- Wait for reply (can only be `cancel.confirm' in this case)
				    int.dec.handle.array[i][from.handler] ? CASE cancel.confirm
				    --{{{  IN message
				    IF
				      output.msgs
					CLAIM int.msg.handle
					  SEQ
					    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
					    int.msg.handle[to.handler] ! msg.int; own.nct.id
					    int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
					    int.msg.handle[to.handler] ! msg.int; i
					    int.msg.handle[to.handler] ! msg.str; ": cancel.confirm"
					    int.msg.handle[to.handler] ! msg.end; FALSE
				      TRUE
					SKIP
				    --}}}
				TRUE
				  SKIP
			    --}}}
			    --{{{  Send suspend-session message to remote CTB-handler (via session-link-handle)
			    CLAIM session.link.handle
			      SEQ
				--{{{  OUT message
				IF
				  output.msgs
				    CLAIM int.msg.handle
				      SEQ
					int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
					int.msg.handle[to.handler] ! msg.int; own.nct.id
					int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
					int.msg.handle[to.handler] ! msg.int; current.remote.node
					int.msg.handle[to.handler] ! msg.str; ": insession.suspend.session; "
					int.msg.handle[to.handler] ! msg.int; own.nct.id
					int.msg.handle[to.handler] ! msg.end; FALSE
				  TRUE
				    SKIP
				--}}}
				-- Carrying: NCT-ID of the CTB-handler making the request
				session.link.handle[to.handler] ! insession.suspend.session; own.nct.id
			    --}}}
			    --{{{  Cancel (or get ack from) all pending encode-handlers
			    SEQ i = 0 FOR num.chans
			      IF
				(ulc.state.array[i] <> ULCSTATE.NONE) AND
				    (((cli.claim.state = CLAIMSTATE.CLAIMED) AND (i >= num.readers.in.svr)) OR
				    ((svr.claim.state = CLAIMSTATE.CLAIMED) AND (i < num.readers.in.svr)))
				  SEQ
				    IF
				      --{{{  Remaining CLCs pending
				      ulc.state.array[i] = ULCSTATE.RESTPENDING
					SEQ
					  -- Wait for `ack' from encode-handler (will definitely come)
					  int.enc.handle.array[i][from.handler] ? CASE ack
					  --{{{  IN message
					  IF
					    output.msgs
					      CLAIM int.msg.handle
						SEQ
						  int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
						  int.msg.handle[to.handler] ! msg.int; own.nct.id
						  int.msg.handle[to.handler] ! msg.str; ": IN int.ench "
						  int.msg.handle[to.handler] ! msg.int; i
						  int.msg.handle[to.handler] ! msg.str; ": ack"
						  int.msg.handle[to.handler] ! msg.end; FALSE
					    TRUE
					      SKIP
					  --}}}
					  -- Pass `ack' on to remote CTB-handler (via session-link-handle)
					  CLAIM session.link.handle
					    SEQ
					      --{{{  OUT message
					      IF
						output.msgs
						  CLAIM int.msg.handle
						    SEQ
						      int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
						      int.msg.handle[to.handler] ! msg.int; own.nct.id
						      int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
						      int.msg.handle[to.handler] ! msg.int; current.remote.node
						      int.msg.handle[to.handler] ! msg.str; ": insession.ack; "
						      int.msg.handle[to.handler] ! msg.int; own.nct.id
						      int.msg.handle[to.handler] ! msg.str; "; "
						      int.msg.handle[to.handler] ! msg.int; i
						      int.msg.handle[to.handler] ! msg.end; FALSE
						TRUE
						  SKIP
					      --}}}
					      -- Carrying: NCT-ID of the CTB-handler making the request;
					      --           channel-ID of the relevant channel
					      session.link.handle[to.handler] ! insession.ack; own.nct.id; i
				      --}}}
				      --{{{  First CLC pending
				      TRUE
					SEQ
					  -- Initiate `cancel.encode'
					  --{{{  OUT message
					  IF
					    output.msgs
					      CLAIM int.msg.handle
						SEQ
						  int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
						  int.msg.handle[to.handler] ! msg.int; own.nct.id
						  int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
						  int.msg.handle[to.handler] ! msg.int; i
						  int.msg.handle[to.handler] ! msg.str; ": cancel.encode"
						  int.msg.handle[to.handler] ! msg.end; FALSE
					    TRUE
					      SKIP
					  --}}}
					  int.dec.handle.array[i][to.handler] ! cancel.encode
					  -- Wait for `ack' from encode-handler
					  int.enc.handle.array[i][from.handler] ? CASE ack
					  --{{{  IN message
					  IF
					    output.msgs
					      CLAIM int.msg.handle
						SEQ
						  int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
						  int.msg.handle[to.handler] ! msg.int; own.nct.id
						  int.msg.handle[to.handler] ! msg.str; ": IN int.ench "
						  int.msg.handle[to.handler] ! msg.int; i
						  int.msg.handle[to.handler] ! msg.str; ": ack"
						  int.msg.handle[to.handler] ! msg.end; FALSE
					    TRUE
					      SKIP
					  --}}}
					  -- Send `cancel.encode.ack' to decode-handler
					  --{{{  OUT message
					  IF
					    output.msgs
					      CLAIM int.msg.handle
						SEQ
						  int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
						  int.msg.handle[to.handler] ! msg.int; own.nct.id
						  int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
						  int.msg.handle[to.handler] ! msg.int; i
						  int.msg.handle[to.handler] ! msg.str; ": cancel.encode.ack"
						  int.msg.handle[to.handler] ! msg.end; FALSE
					    TRUE
					      SKIP
					  --}}}
					  int.dec.handle.array[i][to.handler] ! cancel.encode.ack
					  -- Get reply from decode-handler
					  int.dec.handle.array[i][from.handler] ? CASE
					    --{{{  CLC was cancelled
					    encode.cancelled
					      SEQ
						--{{{  IN message
						IF
						  output.msgs
						    CLAIM int.msg.handle
						      SEQ
							int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
							int.msg.handle[to.handler] ! msg.int; own.nct.id
							int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
							int.msg.handle[to.handler] ! msg.int; i
							int.msg.handle[to.handler] ! msg.str; ": encode.cancelled"
							int.msg.handle[to.handler] ! msg.end; FALSE
						  TRUE
						    SKIP
						--}}}
						-- Cancel CLC in encode-handler
						--{{{  OUT message
						IF
						  output.msgs
						    CLAIM int.msg.handle
						      SEQ
							int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
							int.msg.handle[to.handler] ! msg.int; own.nct.id
							int.msg.handle[to.handler] ! msg.str; ": OUT int.ench "
							int.msg.handle[to.handler] ! msg.int; i
							int.msg.handle[to.handler] ! msg.str; ": cancel.session"
							int.msg.handle[to.handler] ! msg.end; FALSE
						  TRUE
						    SKIP
						--}}}
						int.enc.handle.array[i][to.handler] ! cancel.session
						-- Send `cancel' to remote CTB-handler (via session-link-handle)
						CLAIM session.link.handle
						  SEQ
						    --{{{  OUT message
						    IF
						      output.msgs
							CLAIM int.msg.handle
							  SEQ
							    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
							    int.msg.handle[to.handler] ! msg.int; own.nct.id
							    int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
							    int.msg.handle[to.handler] ! msg.int; current.remote.node
							    int.msg.handle[to.handler] ! msg.str; ": insession.cancel; "
							    int.msg.handle[to.handler] ! msg.int; own.nct.id
							    int.msg.handle[to.handler] ! msg.str; "; "
							    int.msg.handle[to.handler] ! msg.int; i
							    int.msg.handle[to.handler] ! msg.end; FALSE
						      TRUE
							SKIP
						    --}}}
						    -- Carrying: NCT-ID of the CTB-handler making the request;
						    --           channel-ID of the relevant channel
						    session.link.handle[to.handler] ! insession.cancel; own.nct.id; i
					    --}}}
					    --{{{  CLC was not cancelled
					    --       (can only be the case if there are no remaining CLCs)
					    encode.not.cancelled
					      SEQ
						--{{{  IN message
						IF
						  output.msgs
						    CLAIM int.msg.handle
						      SEQ
							int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
							int.msg.handle[to.handler] ! msg.int; own.nct.id
							int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
							int.msg.handle[to.handler] ! msg.int; i
							int.msg.handle[to.handler] ! msg.str; ": encode.not.cancelled"
							int.msg.handle[to.handler] ! msg.end; FALSE
						  TRUE
						    SKIP
						--}}}
						-- Send confirmation to encode-handler
						--{{{  OUT message
						IF
						  output.msgs
						    CLAIM int.msg.handle
						      SEQ
							int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
							int.msg.handle[to.handler] ! msg.int; own.nct.id
							int.msg.handle[to.handler] ! msg.str; ": OUT int.ench "
							int.msg.handle[to.handler] ! msg.int; i
							int.msg.handle[to.handler] ! msg.str; ": output.successful"
							int.msg.handle[to.handler] ! msg.end; FALSE
						  TRUE
						    SKIP
						--}}}
						int.enc.handle.array[i][to.handler] ! output.successful
						-- Pass `ack' on to remote CTB-handler (via session-link-handle)
						CLAIM session.link.handle
						  SEQ
						    --{{{  OUT message
						    IF
						      output.msgs
							CLAIM int.msg.handle
							  SEQ
							    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
							    int.msg.handle[to.handler] ! msg.int; own.nct.id
							    int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
							    int.msg.handle[to.handler] ! msg.int; current.remote.node
							    int.msg.handle[to.handler] ! msg.str; ": insession.ack; "
							    int.msg.handle[to.handler] ! msg.int; own.nct.id
							    int.msg.handle[to.handler] ! msg.str; "; "
							    int.msg.handle[to.handler] ! msg.int; i
							    int.msg.handle[to.handler] ! msg.end; FALSE
						      TRUE
							SKIP
						    --}}}
						    -- Carrying: NCT-ID of the CTB-handler making the request;
						    --           channel-ID of the relevant channel
						    session.link.handle[to.handler] ! insession.ack; own.nct.id; i
					    --}}}
				      --}}}
				    -- Update ULC-state of the pending ULC
				    ulc.state.array[i] := ULCSTATE.NONE
				TRUE
				  SKIP
			    --}}}
			    --{{{  Wait for suspend-session-confirmation from remote CTB-handler
			    INITIAL BOOL running IS TRUE:
			    WHILE running
			      ctb.main.handle.svr[to.handler] ? CASE
				--{{{  First CLC of a ULC
				INT chan.id, di.nlcs.first, cte.nlcs.first:
				BOOL has.rest.clcs:
				MOBILE []BYTE data.array:
				MOBILE []INT size.array:
				-- Carrying: channel-ID of the relevant channel;
				--           number of data-item NLCs in first CLC;
				--           number of channel-type-end NLCs in first CLC;
				--           are there remaining CLCs?;
				--           data-array;
				--           size-array
				first.clc; chan.id; di.nlcs.first; cte.nlcs.first;
						    has.rest.clcs;
						    data.array; size.array
				  SEQ
				    --{{{  IN message
				    IF
				      output.msgs
					CLAIM int.msg.handle
					  SEQ
					    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
					    int.msg.handle[to.handler] ! msg.int; own.nct.id
					    int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [to.handler]: first.clc; "
					    int.msg.handle[to.handler] ! msg.int; chan.id
					    int.msg.handle[to.handler] ! msg.str; "; "
					    int.msg.handle[to.handler] ! msg.int; di.nlcs.first
					    int.msg.handle[to.handler] ! msg.str; "; "
					    int.msg.handle[to.handler] ! msg.int; cte.nlcs.first
					    int.msg.handle[to.handler] ! msg.str; "; "
					    int.msg.handle[to.handler] ! msg.bool; has.rest.clcs
					    int.msg.handle[to.handler] ! msg.str; "; [array ("
					    int.msg.handle[to.handler] ! msg.int; SIZE data.array
					    int.msg.handle[to.handler] ! msg.str; ")]; [array ("
					    int.msg.handle[to.handler] ! msg.int; SIZE size.array
					    int.msg.handle[to.handler] ! msg.str; ")]"
					    int.msg.handle[to.handler] ! msg.end; FALSE
				      TRUE
					SKIP
				    --}}}
				    -- Send `cancel' to remote CTB-handler (via session-link-handle)
				    CLAIM session.link.handle
				      SEQ
					--{{{  OUT message
					IF
					  output.msgs
					    CLAIM int.msg.handle
					      SEQ
						int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
						int.msg.handle[to.handler] ! msg.int; own.nct.id
						int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
						int.msg.handle[to.handler] ! msg.int; current.remote.node
						int.msg.handle[to.handler] ! msg.str; ": insession.cancel; "
						int.msg.handle[to.handler] ! msg.int; own.nct.id
						int.msg.handle[to.handler] ! msg.str; "; "
						int.msg.handle[to.handler] ! msg.int; chan.id
						int.msg.handle[to.handler] ! msg.end; FALSE
					  TRUE
					    SKIP
					--}}}
					-- Carrying: NCT-ID of the CTB-handler making the request;
					--           channel-ID of the relevant channel
					session.link.handle[to.handler] ! insession.cancel; own.nct.id; chan.id
				--}}}
				--{{{  Confirm `suspend.session'
				suspend.session.confirm
				  SEQ
				    --{{{  IN message
				    IF
				      output.msgs
					CLAIM int.msg.handle
					  SEQ
					    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
					    int.msg.handle[to.handler] ! msg.int; own.nct.id
					    int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [to.handler]: suspend.session.confirm"
					    int.msg.handle[to.handler] ! msg.end; FALSE
				      TRUE
					SKIP
				    --}}}
				    -- Update session-state
				    session.state := SESSIONSTATE.SENDINGEOI
				    -- Send eio-CLC to remote CTB-handler (via session-link-handle)
				    CLAIM session.link.handle
				      SEQ
					--{{{  OUT message
					IF
					  output.msgs
					    CLAIM int.msg.handle
					      SEQ
						int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
						int.msg.handle[to.handler] ! msg.int; own.nct.id
						int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
						int.msg.handle[to.handler] ! msg.int; current.remote.node
						int.msg.handle[to.handler] ! msg.str; ": insession.rest.clcs; "
						int.msg.handle[to.handler] ! msg.int; own.nct.id
						int.msg.handle[to.handler] ! msg.str; "; "
						int.msg.handle[to.handler] ! msg.int; chan.id
						int.msg.handle[to.handler] ! msg.str; "; "
						int.msg.handle[to.handler] ! msg.int; di.nlcs.rest
						int.msg.handle[to.handler] ! msg.str; "; "
						int.msg.handle[to.handler] ! msg.int; cte.nlcs.rest
						int.msg.handle[to.handler] ! msg.str; "; [array ("
						int.msg.handle[to.handler] ! msg.int; SIZE addr.array
						int.msg.handle[to.handler] ! msg.str; ")]; [array ("
						int.msg.handle[to.handler] ! msg.int; SIZE size.array
						int.msg.handle[to.handler] ! msg.str; ")]"
						int.msg.handle[to.handler] ! msg.end; FALSE
					  TRUE
					    SKIP
					--}}}
					-- Carrying: NCT-ID of the CTB-handler making the request;
					--           channel-ID of the relevant channel;
					--           number of data-item NLCs in remaining CLCs;
					--           number of channel-type-end NLCs in remaining CLCs;
					--           address-array;
					--           size-array
					session.link.handle[to.handler] ! insession.rest.clcs; own.nct.id; chan.id;
									  di.nlcs.rest; cte.nlcs.rest;
									  addr.array; size.array
				    -- Leave loop
				    running := FALSE
				--}}}
			    --}}}
			--}}}
			--{{{  CLC itself (no eoi)
			MOBILE []INT addr.array, size.array:
			-- Carrying: address-array;
			--           size-array
			clc; addr.array; size.array
			  SEQ
			    --{{{  IN message
			    IF
			      output.msgs
				CLAIM int.msg.handle
				  SEQ
				    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
				    int.msg.handle[to.handler] ! msg.int; own.nct.id
				    int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
				    int.msg.handle[to.handler] ! msg.int; chan.id
				    int.msg.handle[to.handler] ! msg.str; ": clc; [array ("
				    int.msg.handle[to.handler] ! msg.int; SIZE addr.array
				    int.msg.handle[to.handler] ! msg.str; ")]; [array ("
				    int.msg.handle[to.handler] ! msg.int; SIZE size.array
				    int.msg.handle[to.handler] ! msg.str; ")]"
				    int.msg.handle[to.handler] ! msg.end; FALSE
			      TRUE
				SKIP
			    --}}}
			    -- Pass CLC on to remote CTB-handler (via session-link-handle)
			    CLAIM session.link.handle
			      SEQ
				--{{{  OUT message
				IF
				  output.msgs
				    CLAIM int.msg.handle
				      SEQ
					int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
					int.msg.handle[to.handler] ! msg.int; own.nct.id
					int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
					int.msg.handle[to.handler] ! msg.int; current.remote.node
					int.msg.handle[to.handler] ! msg.str; ": insession.rest.clcs; "
					int.msg.handle[to.handler] ! msg.int; own.nct.id
					int.msg.handle[to.handler] ! msg.str; "; "
					int.msg.handle[to.handler] ! msg.int; chan.id
					int.msg.handle[to.handler] ! msg.str; "; "
					int.msg.handle[to.handler] ! msg.int; di.nlcs.rest
					int.msg.handle[to.handler] ! msg.str; "; "
					int.msg.handle[to.handler] ! msg.int; cte.nlcs.rest
					int.msg.handle[to.handler] ! msg.str; "; [array ("
					int.msg.handle[to.handler] ! msg.int; SIZE addr.array
					int.msg.handle[to.handler] ! msg.str; ")]; [array ("
					int.msg.handle[to.handler] ! msg.int; SIZE size.array
					int.msg.handle[to.handler] ! msg.str; ")]"
					int.msg.handle[to.handler] ! msg.end; FALSE
				  TRUE
				    SKIP
				--}}}
				-- Carrying: NCT-ID of the CTB-handler making the request;
				--           channel-ID of the relevant channel;
				--           number of data-item NLCs in remaining CLCs;
				--           number of channel-type-end NLCs in remaining CLCs;
				--           address-array;
				--           size-array
				session.link.handle[to.handler] ! insession.rest.clcs; own.nct.id; chan.id;
								  di.nlcs.rest; cte.nlcs.rest;
								  addr.array; size.array
			--}}}
		  --}}}
		  --{{{  There are no remaining CLCs
		  TRUE
		    SEQ
		      -- Update ULC-state
		      ulc.state.array[chan.id] := ULCSTATE.NONE
		      --{{{  Deal with special case if session-state is sending-eoi
		      IF
			session.state = SESSIONSTATE.SENDINGEOI
			  SEQ
			    -- Cancel the eoi-decode-handler
			    --{{{  OUT message
			    IF
			      output.msgs
				CLAIM int.msg.handle
				  SEQ
				    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
				    int.msg.handle[to.handler] ! msg.int; own.nct.id
				    int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
				    int.msg.handle[to.handler] ! msg.int; chan.id
				    int.msg.handle[to.handler] ! msg.str; ": cancel.session"
				    int.msg.handle[to.handler] ! msg.end; FALSE
			      TRUE
				SKIP
			    --}}}
			    int.dec.handle.array[chan.id][to.handler] ! cancel.session
			    -- Wait for reply (can only be `cancel.confirm' in this case)
			    int.dec.handle.array[chan.id][from.handler] ? CASE cancel.confirm
			    --{{{  IN message
			    IF
			      output.msgs
				CLAIM int.msg.handle
				  SEQ
				    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
				    int.msg.handle[to.handler] ! msg.int; own.nct.id
				    int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
				    int.msg.handle[to.handler] ! msg.int; chan.id
				    int.msg.handle[to.handler] ! msg.str; ": cancel.confirm"
				    int.msg.handle[to.handler] ! msg.end; FALSE
			      TRUE
				SKIP
			    --}}}
			    -- Update session-state
			    session.state := SESSIONSTATE.NONE
			    -- Update current remote node
			    current.remote.node := -1
			    -- Update current remote node in instant-handler
			    update.current.remote.node ! current.remote.node
			    -- Update relevant claim-state
			    IF
			      cli.claim.state = CLAIMSTATE.CLAIMED
				cli.claim.state := CLAIMSTATE.RELEASED
			      TRUE
				svr.claim.state := CLAIMSTATE.RELEASED
			TRUE
			  SKIP
		      --}}}
		  --}}}
	    --}}}
            --{{{  Close session
            close.session
              INITIAL INT num.pending.decode.handlers IS 0:
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [to.handler]: close.session"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                --{{{  Cancel all non-pending decode-handlers if not sending-eoi
                --       and update `num.pending.decode.handlers'
                IF
                  session.state <> SESSIONSTATE.SENDINGEOI
                    SEQ i = 0 FOR num.chans
                      IF
                        ((cli.claim.state = CLAIMSTATE.CLAIMED) AND (i < num.readers.in.svr)) OR
                            ((svr.claim.state = CLAIMSTATE.CLAIMED) AND (i >= num.readers.in.svr))
                          IF
                            --{{{  Non-pending
                            ulc.state.array[i] = ULCSTATE.NONE
                              SEQ
                                -- Send `cancel.session' to decode-handler
                                --{{{  OUT message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                                        int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
                                        int.msg.handle[to.handler] ! msg.int; i
                                        int.msg.handle[to.handler] ! msg.str; ": cancel.session"
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                                int.dec.handle.array[i][to.handler] ! cancel.session
                                --{{{  Get confirmation
                                int.dec.handle.array[i][from.handler] ? CASE
                                  -- Confirmation
                                  cancel.confirm
                                    --{{{  IN message
                                    IF
                                      output.msgs
                                        CLAIM int.msg.handle
                                          SEQ
                                            int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                                            int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                            int.msg.handle[to.handler] ! msg.int; i
                                            int.msg.handle[to.handler] ! msg.str; ": cancel.confirm"
                                            int.msg.handle[to.handler] ! msg.end; FALSE
                                      TRUE
                                        SKIP
                                    --}}}
                                  -- Attempted new ULC - ignore
                                  INT di.nlcs.first, cte.nlcs.first:
                                  BOOL has.rest.clcs:
                                  -- Carrying: number of data-item NLCs in first CLC;
                                  --           number of channel-type-end NLCs in first CLC;
                                  --           are there remaining CLCs?
                                  first.clc; di.nlcs.first; cte.nlcs.first; has.rest.clcs
                                    SEQ
                                      --{{{  IN message
                                      IF
                                        output.msgs
                                          CLAIM int.msg.handle
                                            SEQ
                                              int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                                              int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                              int.msg.handle[to.handler] ! msg.int; i
                                              int.msg.handle[to.handler] ! msg.str; ": first.clc; "
                                              int.msg.handle[to.handler] ! msg.int; di.nlcs.first
                                              int.msg.handle[to.handler] ! msg.str; "; "
                                              int.msg.handle[to.handler] ! msg.int; cte.nlcs.first
                                              int.msg.handle[to.handler] ! msg.str; "; "
                                              int.msg.handle[to.handler] ! msg.bool; has.rest.clcs
                                              int.msg.handle[to.handler] ! msg.end; FALSE
                                        TRUE
                                          SKIP
                                      --}}}
                                      -- Get `real' confirmation
                                      int.dec.handle.array[i][from.handler] ? CASE cancel.confirm
                                      --{{{  IN message
                                      IF
                                        output.msgs
                                          CLAIM int.msg.handle
                                            SEQ
                                              int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                              int.msg.handle[to.handler] ! msg.int; own.nct.id
                                              int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                              int.msg.handle[to.handler] ! msg.int; i
                                              int.msg.handle[to.handler] ! msg.str; ": cancel.confirm"
                                              int.msg.handle[to.handler] ! msg.end; FALSE
                                        TRUE
                                          SKIP
                                      --}}}
                                --}}}
                            --}}}
                            --{{{  Pending
                            TRUE
                              num.pending.decode.handlers := num.pending.decode.handlers + 1
                            --}}}
                        TRUE
                          SKIP
                  TRUE
                    num.pending.decode.handlers := 1
                --}}}
                --{{{  Wait for cancel or ack for all pending decode-handlers
                SEQ i = 0 FOR num.pending.decode.handlers
                  ctb.main.handle.svr[to.handler] ? CASE
                    --{{{  Cancel CLC
                    INT chan.id:
                    -- Carrying: channel-ID of the relevant channel
                    cancel; chan.id
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [to.handler]: cancel; "
                                int.msg.handle[to.handler] ! msg.int; chan.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        -- Pass cancel on to decode-handler
                        --{{{  OUT message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
                                int.msg.handle[to.handler] ! msg.int; chan.id
                                int.msg.handle[to.handler] ! msg.str; ": cancel.session"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        int.dec.handle.array[chan.id][to.handler] ! cancel.session
                        -- Wait for reply
                        int.dec.handle.array[chan.id][from.handler] ? CASE cancel.confirm
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                int.msg.handle[to.handler] ! msg.int; chan.id
                                int.msg.handle[to.handler] ! msg.str; ": cancel.confirm"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        -- Update ULC-state
                        ulc.state.array[chan.id] := ULCSTATE.NONE
                    --}}}
                    --{{{  Acknowledge CLC
                    INT chan.id:
                    -- Carrying: channel-ID of the relevant channel
                    ack; chan.id
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [to.handler]: ack; "
                                int.msg.handle[to.handler] ! msg.int; chan.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        -- Pass ack on to decode-handler
                        --{{{  OUT message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
                                int.msg.handle[to.handler] ! msg.int; chan.id
                                int.msg.handle[to.handler] ! msg.str; ": ack"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        int.dec.handle.array[chan.id][to.handler] ! ack
                        --{{{  Deal with special case if session-state is sending-eoi
                        IF
                          session.state = SESSIONSTATE.SENDINGEOI
                            -- Update relevant claim-state
                            IF
                              cli.claim.state = CLAIMSTATE.CLAIMED
                                cli.claim.state := CLAIMSTATE.RELEASED
                              TRUE
                                svr.claim.state := CLAIMSTATE.RELEASED
                          TRUE
                            SKIP
                        --}}}
                        -- Send `cancel.session' to decode-handler
                        --{{{  OUT message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
                                int.msg.handle[to.handler] ! msg.int; chan.id
                                int.msg.handle[to.handler] ! msg.str; ": cancel.session"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        int.dec.handle.array[chan.id][to.handler] ! cancel.session
                        --{{{  Get confirmation
                        int.dec.handle.array[chan.id][from.handler] ? CASE
                          -- Confirmation
                          cancel.confirm
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                    int.msg.handle[to.handler] ! msg.int; chan.id
                                    int.msg.handle[to.handler] ! msg.str; ": cancel.confirm"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                          -- Attempted new ULC - ignore
                          INT di.nlcs.first, cte.nlcs.first:
                          BOOL has.rest.clcs:
                          -- Carrying: number of data-item NLCs in first CLC;
                          --           number of channel-type-end NLCs in first CLC;
                          --           are there remaining CLCs?
                          first.clc; di.nlcs.first; cte.nlcs.first; has.rest.clcs
                            SEQ
                              --{{{  IN message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; own.nct.id
                                      int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                      int.msg.handle[to.handler] ! msg.int; chan.id
                                      int.msg.handle[to.handler] ! msg.str; ": first.clc; "
                                      int.msg.handle[to.handler] ! msg.int; di.nlcs.first
                                      int.msg.handle[to.handler] ! msg.str; "; "
                                      int.msg.handle[to.handler] ! msg.int; cte.nlcs.first
                                      int.msg.handle[to.handler] ! msg.str; "; "
                                      int.msg.handle[to.handler] ! msg.bool; has.rest.clcs
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              -- Get `real' confirmation
                              int.dec.handle.array[chan.id][from.handler] ? CASE cancel.confirm
                              --{{{  IN message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; own.nct.id
                                      int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                      int.msg.handle[to.handler] ! msg.int; chan.id
                                      int.msg.handle[to.handler] ! msg.str; ": cancel.confirm"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                        --}}}
                        -- Update ULC-state
                        ulc.state.array[chan.id] := ULCSTATE.NONE
                    --}}}
                --}}}
                -- Send close-session message to remote CTB-handler (via session-link-handle)
                CLAIM session.link.handle
                  SEQ
                    --{{{  OUT message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                            int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
                            int.msg.handle[to.handler] ! msg.int; current.remote.node
                            int.msg.handle[to.handler] ! msg.str; ": insession.close.session; "
                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                    -- Carrying: NCT-ID of the CTB-handler making the request
                    session.link.handle[to.handler] ! insession.close.session; own.nct.id
                -- Update session-state
                session.state := SESSIONSTATE.NONE
                -- Update current remote node
                current.remote.node := -1
                -- Update current remote node in instant-handler
                update.current.remote.node ! current.remote.node
            --}}}
            --{{{  Suspend session
            suspend.session
              INITIAL INT num.pending.decode.handlers IS 0:
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [to.handler]: suspend.session"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                --{{{  Cancel all non-pending decode-handlers
                --       and update `num.pending.decode.handlers'
                SEQ i = 0 FOR num.chans
                  IF
                    ((cli.claim.state = CLAIMSTATE.CLAIMED) AND (i < num.readers.in.svr)) OR
                        ((svr.claim.state = CLAIMSTATE.CLAIMED) AND (i >= num.readers.in.svr))
                      IF
                        --{{{  Non-pending
                        ulc.state.array[i] = ULCSTATE.NONE
                          SEQ
                            -- Send `cancel.session' to decode-handler
                            --{{{  OUT message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                    int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
                                    int.msg.handle[to.handler] ! msg.int; i
                                    int.msg.handle[to.handler] ! msg.str; ": cancel.session"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                            int.dec.handle.array[i][to.handler] ! cancel.session
                            --{{{  Get confirmation
                            int.dec.handle.array[i][from.handler] ? CASE
                              -- Confirmation
                              cancel.confirm
                                --{{{  IN message
                                IF
                                  output.msgs
                                    CLAIM int.msg.handle
                                      SEQ
                                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                                        int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                        int.msg.handle[to.handler] ! msg.int; i
                                        int.msg.handle[to.handler] ! msg.str; ": cancel.confirm"
                                        int.msg.handle[to.handler] ! msg.end; FALSE
                                  TRUE
                                    SKIP
                                --}}}
                              -- Attempted new ULC - ignore
                              INT di.nlcs.first, cte.nlcs.first:
                              BOOL has.rest.clcs:
                              -- Carrying: number of data-item NLCs in first CLC;
                              --           number of channel-type-end NLCs in first CLC;
                              --           are there remaining CLCs?
                              first.clc; di.nlcs.first; cte.nlcs.first; has.rest.clcs
                                SEQ
                                  --{{{  IN message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                          int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                          int.msg.handle[to.handler] ! msg.int; i
                                          int.msg.handle[to.handler] ! msg.str; ": first.clc; "
                                          int.msg.handle[to.handler] ! msg.int; di.nlcs.first
                                          int.msg.handle[to.handler] ! msg.str; "; "
                                          int.msg.handle[to.handler] ! msg.int; cte.nlcs.first
                                          int.msg.handle[to.handler] ! msg.str; "; "
                                          int.msg.handle[to.handler] ! msg.bool; has.rest.clcs
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                                  -- Get `real' confirmation
                                  int.dec.handle.array[i][from.handler] ? CASE cancel.confirm
                                  --{{{  IN message
                                  IF
                                    output.msgs
                                      CLAIM int.msg.handle
                                        SEQ
                                          int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                          int.msg.handle[to.handler] ! msg.int; own.nct.id
                                          int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                          int.msg.handle[to.handler] ! msg.int; i
                                          int.msg.handle[to.handler] ! msg.str; ": cancel.confirm"
                                          int.msg.handle[to.handler] ! msg.end; FALSE
                                    TRUE
                                      SKIP
                                  --}}}
                            --}}}
                        --}}}
                        --{{{  Pending
                        TRUE
                          num.pending.decode.handlers := num.pending.decode.handlers + 1
                        --}}}
                    TRUE
                      SKIP
                --}}}
                --{{{  Wait for cancel or ack for all pending decode-handlers
                SEQ i = 0 FOR num.pending.decode.handlers
                  ctb.main.handle.svr[to.handler] ? CASE
                    --{{{  Cancel CLC
                    INT chan.id:
                    -- Carrying: channel-ID of the relevant channel
                    cancel; chan.id
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [to.handler]: cancel; "
                                int.msg.handle[to.handler] ! msg.int; chan.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        -- Pass cancel on to decode-handler
                        --{{{  OUT message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
                                int.msg.handle[to.handler] ! msg.int; chan.id
                                int.msg.handle[to.handler] ! msg.str; ": cancel.session"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        int.dec.handle.array[chan.id][to.handler] ! cancel.session
                        -- Wait for reply
                        int.dec.handle.array[chan.id][from.handler] ? CASE cancel.confirm
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                int.msg.handle[to.handler] ! msg.int; chan.id
                                int.msg.handle[to.handler] ! msg.str; ": cancel.confirm"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        -- Update ULC-state
                        ulc.state.array[chan.id] := ULCSTATE.NONE
                    --}}}
                    --{{{  Acknowledge CLC
                    INT chan.id:
                    -- Carrying: channel-ID of the relevant channel
                    ack; chan.id
                      SEQ
                        --{{{  IN message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [to.handler]: ack; "
                                int.msg.handle[to.handler] ! msg.int; chan.id
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        -- Pass ack on to decode-handler
                        --{{{  OUT message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
                                int.msg.handle[to.handler] ! msg.int; chan.id
                                int.msg.handle[to.handler] ! msg.str; ": ack"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        int.dec.handle.array[chan.id][to.handler] ! ack
                        -- Send `cancel.session' to decode-handler
                        --{{{  OUT message
                        IF
                          output.msgs
                            CLAIM int.msg.handle
                              SEQ
                                int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                int.msg.handle[to.handler] ! msg.int; own.nct.id
                                int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
                                int.msg.handle[to.handler] ! msg.int; chan.id
                                int.msg.handle[to.handler] ! msg.str; ": cancel.session"
                                int.msg.handle[to.handler] ! msg.end; FALSE
                          TRUE
                            SKIP
                        --}}}
                        int.dec.handle.array[chan.id][to.handler] ! cancel.session
                        --{{{  Get confirmation
                        int.dec.handle.array[chan.id][from.handler] ? CASE
                          -- Confirmation
                          cancel.confirm
                            --{{{  IN message
                            IF
                              output.msgs
                                CLAIM int.msg.handle
                                  SEQ
                                    int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                    int.msg.handle[to.handler] ! msg.int; own.nct.id
                                    int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                    int.msg.handle[to.handler] ! msg.int; chan.id
                                    int.msg.handle[to.handler] ! msg.str; ": cancel.confirm"
                                    int.msg.handle[to.handler] ! msg.end; FALSE
                              TRUE
                                SKIP
                            --}}}
                          -- Attempted new ULC - ignore
                          INT di.nlcs.first, cte.nlcs.first:
                          BOOL has.rest.clcs:
                          -- Carrying: number of data-item NLCs in first CLC;
                          --           number of channel-type-end NLCs in first CLC;
                          --           are there remaining CLCs?
                          first.clc; di.nlcs.first; cte.nlcs.first; has.rest.clcs
                            SEQ
                              --{{{  IN message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; own.nct.id
                                      int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                      int.msg.handle[to.handler] ! msg.int; chan.id
                                      int.msg.handle[to.handler] ! msg.str; ": first.clc; "
                                      int.msg.handle[to.handler] ! msg.int; di.nlcs.first
                                      int.msg.handle[to.handler] ! msg.str; "; "
                                      int.msg.handle[to.handler] ! msg.int; cte.nlcs.first
                                      int.msg.handle[to.handler] ! msg.str; "; "
                                      int.msg.handle[to.handler] ! msg.bool; has.rest.clcs
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                              -- Get `real' confirmation
                              int.dec.handle.array[chan.id][from.handler] ? CASE cancel.confirm
                              --{{{  IN message
                              IF
                                output.msgs
                                  CLAIM int.msg.handle
                                    SEQ
                                      int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                                      int.msg.handle[to.handler] ! msg.int; own.nct.id
                                      int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                                      int.msg.handle[to.handler] ! msg.int; chan.id
                                      int.msg.handle[to.handler] ! msg.str; ": cancel.confirm"
                                      int.msg.handle[to.handler] ! msg.end; FALSE
                                TRUE
                                  SKIP
                              --}}}
                        --}}}
                        -- Update ULC-state
                        ulc.state.array[chan.id] := ULCSTATE.NONE
                    --}}}
                --}}}
                -- Send supend-session-confirmation to remote CTB-handler (via session-link-handle)
                CLAIM session.link.handle
                  SEQ
                    --{{{  OUT message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                            int.msg.handle[to.handler] ! msg.str; ": OUT linkh "
                            int.msg.handle[to.handler] ! msg.int; current.remote.node
                            int.msg.handle[to.handler] ! msg.str; ": insession.suspend.session.confirm; "
                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                    -- Carrying: NCT-ID of the CTB-handler making the request
                    session.link.handle[to.handler] ! insession.suspend.session.confirm; own.nct.id
                -- Update session-state
                session.state := SESSIONSTATE.SUSPENDED
            --}}}
            --{{{  Shutdown
            shutdown
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; ": IN ctbmainh [to.handler]: shutdown"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                -- Shut down all decode-handlers and encode-handlers
                SEQ i = 0 FOR num.chans
                  SEQ
                    -- Shut down decode-handler
                    --{{{  OUT message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                            int.msg.handle[to.handler] ! msg.str; ": OUT int.dech "
                            int.msg.handle[to.handler] ! msg.int; i
                            int.msg.handle[to.handler] ! msg.str; ": shutdown"
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                    int.dec.handle.array[i][to.handler] ! shutdown
                    -- Get reply
                    int.dec.handle.array[i][from.handler] ? CASE shutdown.confirm
                    --{{{  IN message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                            int.msg.handle[to.handler] ! msg.str; ": IN int.dech "
                            int.msg.handle[to.handler] ! msg.int; i
                            int.msg.handle[to.handler] ! msg.str; ": shutdown.confirm"
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                    -- Shut down encode-handler
                    --{{{  OUT message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                            int.msg.handle[to.handler] ! msg.str; ": OUT int.ench "
                            int.msg.handle[to.handler] ! msg.int; i
                            int.msg.handle[to.handler] ! msg.str; ": shutdown"
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                    int.enc.handle.array[i][to.handler] ! shutdown
                    -- Get reply
                    int.enc.handle.array[i][from.handler] ? CASE shutdown.confirm
                    --{{{  IN message
                    IF
                      output.msgs
                        CLAIM int.msg.handle
                          SEQ
                            int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                            int.msg.handle[to.handler] ! msg.int; own.nct.id
                            int.msg.handle[to.handler] ! msg.str; ": IN int.ench "
                            int.msg.handle[to.handler] ! msg.int; i
                            int.msg.handle[to.handler] ! msg.str; ": shutdown.confirm"
                            int.msg.handle[to.handler] ! msg.end; FALSE
                      TRUE
                        SKIP
                    --}}}
                -- Shutdown internal processes
                stop.cli.listener ! TRUE
                stop.svr.listener ! TRUE
                stop.instant.handler ! TRUE
                -- Leave main loop
                running := FALSE
                -- Send reply
                --{{{  OUT message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.hdlr "
                        int.msg.handle[to.handler] ! msg.int; own.nct.id
                        int.msg.handle[to.handler] ! msg.str; ": OUT ctbmainh: shutdown.confirm"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                ctb.main.handle.svr[from.handler] ! shutdown.confirm
            --}}}
      --}}}
:
--}}}
--{{{  PROC pony.int.ctb.mgr
-- CTB-manager
-- Parameters: own.node.id         | VAL: own node-ID
--             ctb.mgr.handle.svr  | server-end of CTB-manager-handle
--             ctb.mgr.handle      | CTB-manager-handle (client-end)
--             link.mgr.handle     | link-manager-handle (client-end)
--             master.link.handle  | link-handle for master node (client-end)
--             kernel.reply.handle | kernel-reply-handle (client-end)
--             output.msgs         | VAL: output messages?
--             int.msg.handle      | internal message-handle (client-end)
PROC pony.int.ctb.mgr (VAL INT own.node.id,
                       PONY.INT.CTBMGRHANDLE? ctb.mgr.handle.svr,
                       SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle,
                       SHARED PONY.INT.LINKMGRHANDLE! link.mgr.handle,
                       SHARED PONY.INT.LINKHANDLE! master.link.handle,
                       SHARED PONY.INT.KERNELREPLYHANDLE! kernel.reply.handle,
                       VAL BOOL output.msgs,
                       SHARED PONY.INT.MSGHANDLE! int.msg.handle)
  --{{{  Handles to CTB-handlers
  INITIAL MOBILE []SHARED PONY.INT.CTBMAINHANDLE! ctb.main.handle.array IS MOBILE [500]SHARED PONY.INT.CTBMAINHANDLE!:
  INITIAL MOBILE []SHARED PONY.INT.CTBINSTANTHANDLE! ctb.instant.handle.array IS MOBILE [500]SHARED PONY.INT.CTBINSTANTHANDLE!:
  INITIAL MOBILE []SHARED PONY.INT.CTBCLAIMHANDLE! ctb.cli.claim.handle.array IS MOBILE [500]SHARED PONY.INT.CTBCLAIMHANDLE!:
  INITIAL MOBILE []SHARED PONY.INT.CTBCLAIMHANDLE! ctb.svr.claim.handle.array IS MOBILE [500]SHARED PONY.INT.CTBCLAIMHANDLE!:
  --}}}
  --{{{  Variables
  INITIAL MOBILE []INT ctb.ptr.array IS MOBILE [500]INT:
  INITIAL INT num.ctbs IS 0:
  --}}}
  --{{{  Channels
  CHAN MOBILE []SHARED PONY.INT.CTBCLAIMHANDLE! pass.to.be.released.claim.handle.array:
  CHAN BOOL release.done:
  --}}}
  PAR
    --{{{  Releaser (used before shutdown)
    MOBILE []SHARED PONY.INT.CTBCLAIMHANDLE! to.be.released.claim.handle.array:
    SEQ
      -- Get array of claim-handles via internal channel
      pass.to.be.released.claim.handle.array ? to.be.released.claim.handle.array
      -- Release them all in parallel
      --{{{  OUT message
      IF
        output.msgs
          CLAIM int.msg.handle
            SEQ
              int.msg.handle[to.handler] ! msg.str; "ctb.mgr (releaser): OUT "
              int.msg.handle[to.handler] ! msg.int; (SIZE to.be.released.claim.handle.array)
              int.msg.handle[to.handler] ! msg.str; "x ctbclaimh: release"
              int.msg.handle[to.handler] ! msg.end; FALSE
        TRUE
          SKIP
      --}}}
      PAR i = 0 FOR (SIZE to.be.released.claim.handle.array)
        CLAIM to.be.released.claim.handle.array[i]
          to.be.released.claim.handle.array[i][to.handler] ! release
      -- Send confirmation
      release.done ! TRUE
    --}}}
    SEQ
      --{{{  Initialise CTB-pointer-array
      SEQ i = 0 FOR (SIZE ctb.ptr.array)
        ctb.ptr.array[i] := 0
      --}}}
      INITIAL BOOL running IS TRUE:
      WHILE running
        ALT
          ctb.mgr.handle.svr[to.mgr] ? CASE
            --{{{  Get CTB-main-handle for a given NCT-ID
            INT nct.id:
            -- Carrying: NCT-ID
            get.ctb.main.handle; nct.id
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.mgr: IN ctbmgrh: get.ctb.main.handle; "
                        int.msg.handle[to.handler] ! msg.int; nct.id
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                -- Return handle
                --{{{  OUT message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.mgr: OUT ctbmgrh: get.ctb.main.handle.confirm; [cli-end]"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                -- Carrying: CTB-main-handle
                ctb.mgr.handle.svr[from.mgr] ! get.ctb.main.handle.confirm; ctb.main.handle.array[nct.id]
            --}}}
            --{{{  Get CTB-instant-handle for a given NCT-ID
            INT nct.id:
            -- Carrying: NCT-ID
            get.ctb.instant.handle; nct.id
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.mgr: IN ctbmgrh: get.ctb.instant.handle; "
                        int.msg.handle[to.handler] ! msg.int; nct.id
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                IF
                  (nct.id >= (SIZE ctb.ptr.array)) OR (ctb.ptr.array[nct.id] = 0)
                    SEQ
                      -- Return error
                      --{{{  OUT message
                      IF
                        output.msgs
                          CLAIM int.msg.handle
                            SEQ
                              int.msg.handle[to.handler] ! msg.str; "ctb.mgr: OUT ctbmgrh: get.ctb.instant.handle.invalidnctid"
                              int.msg.handle[to.handler] ! msg.end; FALSE
                        TRUE
                          SKIP
                      --}}}
                      ctb.mgr.handle.svr[from.mgr] ! get.ctb.instant.handle.invalidnctid
                  TRUE
                    SEQ
                      -- Return handle
                      --{{{  OUT message
                      IF
                        output.msgs
                          CLAIM int.msg.handle
                            SEQ
                              int.msg.handle[to.handler] ! msg.str; "ctb.mgr: OUT ctbmgrh: get.ctb.instant.handle.confirm; [cli-end]"
                              int.msg.handle[to.handler] ! msg.end; FALSE
                        TRUE
                          SKIP
                      --}}}
                      -- Carrying: CTB-instant-handle
                      ctb.mgr.handle.svr[from.mgr] ! get.ctb.instant.handle.confirm; ctb.instant.handle.array[nct.id]
            --}}}
            --{{{  Get CTB-claim-handle for a given NCT-ID
            INT nct.id, dir.type:
            -- Carrying: NCT-ID;
            --           direction-type of the end to be claimed/released
            --             (0 = client-end, 1 = server-end)
            get.ctb.claim.handle; nct.id; dir.type
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.mgr: IN ctbmgrh: get.ctb.claim.handle; "
                        int.msg.handle[to.handler] ! msg.int; nct.id
                        int.msg.handle[to.handler] ! msg.str; "; "
                        int.msg.handle[to.handler] ! msg.int; dir.type
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                -- Return handle
                --{{{  OUT message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.mgr: OUT ctbmgrh: get.ctb.claim.handle.confirm; [cli-end]"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                IF
                  dir.type = PONYC.INT.DIRTYPE.CLI
                    -- Carrying: CTB-claim-handle
                    ctb.mgr.handle.svr[from.mgr] ! get.ctb.claim.handle.confirm; ctb.cli.claim.handle.array[nct.id]
                  TRUE
                    -- Carrying: CTB-claim-handle
                    ctb.mgr.handle.svr[from.mgr] ! get.ctb.claim.handle.confirm; ctb.svr.claim.handle.array[nct.id]
            --}}}
            --{{{  Allocate new channel-type-end
            INT nct.id:
            -- Carrying: NCT-ID
            alloc.ct.end; nct.id
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.mgr: IN ctbmgrh: alloc.ct.end; "
                        int.msg.handle[to.handler] ! msg.int; nct.id
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                --{{{  Adapt size of arrays if necessary
                IF
                  nct.id >= (SIZE ctb.ptr.array)
                    INITIAL INT old.size IS SIZE ctb.ptr.array:
                    INITIAL INT new.size IS 2 * (SIZE ctb.ptr.array):
                    MOBILE []INT new.ctb.ptr.array:
                    MOBILE []SHARED PONY.INT.CTBMAINHANDLE! new.ctb.main.handle.array:
                    MOBILE []SHARED PONY.INT.CTBINSTANTHANDLE! new.ctb.instant.handle.array:
                    MOBILE []SHARED PONY.INT.CTBCLAIMHANDLE! new.ctb.cli.claim.handle.array:
                    MOBILE []SHARED PONY.INT.CTBCLAIMHANDLE! new.ctb.svr.claim.handle.array:
                    SEQ
                      -- Double size until it fits
                      WHILE nct.id >= new.size
                        new.size := 2 * new.size
                      -- Allocate new arrays
                      new.ctb.ptr.array := MOBILE [new.size]INT
                      new.ctb.main.handle.array := MOBILE [new.size]SHARED PONY.INT.CTBMAINHANDLE!
                      new.ctb.instant.handle.array := MOBILE [new.size]SHARED PONY.INT.CTBINSTANTHANDLE!
                      new.ctb.cli.claim.handle.array := MOBILE [new.size]SHARED PONY.INT.CTBCLAIMHANDLE!
                      new.ctb.svr.claim.handle.array := MOBILE [new.size]SHARED PONY.INT.CTBCLAIMHANDLE!
                      -- Set existing elements in new arrays
                      SEQ i = 0 FOR old.size
                        IF
                          ctb.ptr.array[i] <> 0
                            SEQ
                              new.ctb.main.handle.array[i] := ctb.main.handle.array[i]
                              new.ctb.instant.handle.array[i] := ctb.instant.handle.array[i]
                              new.ctb.cli.claim.handle.array[i] := ctb.cli.claim.handle.array[i]
                              new.ctb.svr.claim.handle.array[i] := ctb.svr.claim.handle.array[i]
                          TRUE
                            SKIP
                      [new.ctb.ptr.array FOR old.size] := ctb.ptr.array
                      -- Initialise new fields of new CTB-pointer-array
                      SEQ i = old.size FOR (new.size - old.size)
                        new.ctb.ptr.array[i] := 0
                      -- Use new arrays
                      ctb.ptr.array := new.ctb.ptr.array
                      ctb.main.handle.array := new.ctb.main.handle.array
                      ctb.instant.handle.array := new.ctb.instant.handle.array
                      ctb.cli.claim.handle.array := new.ctb.cli.claim.handle.array
                      ctb.svr.claim.handle.array := new.ctb.svr.claim.handle.array
                  TRUE
                    SKIP
                --}}}
                IF
                  --{{{  Existing CTB
                  ctb.ptr.array[nct.id] <> 0
                    SEQ
                      -- Rend reply
                      --{{{  OUT message
                      IF
                        output.msgs
                          CLAIM int.msg.handle
                            SEQ
                              int.msg.handle[to.handler] ! msg.str; "ctb.mgr: OUT ctbmgrh: increase.ref.count; "
                              int.msg.handle[to.handler] ! msg.hex; ctb.ptr.array[nct.id]
                              int.msg.handle[to.handler] ! msg.end; FALSE
                        TRUE
                          SKIP
                      --}}}
                      -- Carrying: CTB-pointer
                      ctb.mgr.handle.svr[from.mgr] ! increase.ref.count; ctb.ptr.array[nct.id]
                  --}}}
                  --{{{  New CTB
                  TRUE
                    INT ctb.ptr, num.chans, num.readers.in.svr:
                    PONY.NETHOOKHANDLE! net.hook.handle:
                    PONY.NETHOOKHANDLE? net.hook.handle.svr:
                    MOBILE []PONY.DECODEHANDLE! dec.handle.array:
                    MOBILE []PONY.DECODEHANDLE? dec.handle.svr.array:
                    MOBILE []PONY.ENCODEHANDLE! enc.handle.array:
                    MOBILE []PONY.ENCODEHANDLE? enc.handle.svr.array:
                    PONY.INT.CTBMAINHANDLE? ctb.main.handle.svr:
                    PONY.INT.CTBINSTANTHANDLE? ctb.instant.handle.svr:
                    PONY.INT.CTBCLAIMHANDLE? ctb.cli.claim.handle.svr:
                    PONY.INT.CTBCLAIMHANDLE? ctb.svr.claim.handle.svr:
                    SEQ
                      -- Send reply
                      --{{{  OUT message
                      IF
                        output.msgs
                          CLAIM int.msg.handle
                            SEQ
                              int.msg.handle[to.handler] ! msg.str; "ctb.mgr: OUT ctbmgrh: alloc.new.ctb"
                              int.msg.handle[to.handler] ! msg.end; FALSE
                        TRUE
                          SKIP
                      --}}}
                      ctb.mgr.handle.svr[from.mgr] ! alloc.new.ctb
                      -- Get channel-counts
                      -- Carrying: number of channel-words in CTB;
                      --           number of reading-ends in server-end
                      ctb.mgr.handle.svr[to.mgr] ? CASE alloc.new.ctb.confirm.chancounts;
                                                        num.chans; num.readers.in.svr
                      --{{{  IN message
                      IF
                        output.msgs
                          CLAIM int.msg.handle
                            SEQ
                              int.msg.handle[to.handler] ! msg.str; "ctb.mgr: IN ctbmgrh: alloc.new.ctb.confirm.chancounts; "
                              int.msg.handle[to.handler] ! msg.int; num.chans
                              int.msg.handle[to.handler] ! msg.str; "; "
                              int.msg.handle[to.handler] ! msg.int; num.readers.in.svr
                              int.msg.handle[to.handler] ! msg.end; FALSE
                        TRUE
                          SKIP
                      --}}}
                      -- Initialise new handles
                      net.hook.handle, net.hook.handle.svr := MOBILE PONY.NETHOOKHANDLE
                      dec.handle.array := MOBILE [num.chans]PONY.DECODEHANDLE!
                      dec.handle.svr.array := MOBILE [num.chans]PONY.DECODEHANDLE?
                      enc.handle.array := MOBILE [num.chans]PONY.ENCODEHANDLE!
                      enc.handle.svr.array := MOBILE [num.chans]PONY.ENCODEHANDLE?
                      SEQ i = 0 FOR num.chans
                        SEQ
                          dec.handle.array[i], dec.handle.svr.array[i] := MOBILE PONY.DECODEHANDLE
                          enc.handle.array[i], enc.handle.svr.array[i] := MOBILE PONY.ENCODEHANDLE
                      ctb.main.handle.array[nct.id], ctb.main.handle.svr := MOBILE PONY.INT.CTBMAINHANDLE
                      ctb.instant.handle.array[nct.id], ctb.instant.handle.svr := MOBILE PONY.INT.CTBINSTANTHANDLE
                      ctb.cli.claim.handle.array[nct.id], ctb.cli.claim.handle.svr := MOBILE PONY.INT.CTBCLAIMHANDLE
                      ctb.svr.claim.handle.array[nct.id], ctb.svr.claim.handle.svr := MOBILE PONY.INT.CTBCLAIMHANDLE
                      -- Send reply
                      --{{{  OUT message
                      IF
                        output.msgs
                          CLAIM int.msg.handle
                            SEQ
                              int.msg.handle[to.handler] ! msg.str; "ctb.mgr: OUT ctbmgrh: alloc.new.ctb.confirm; [cli-end]; [array ("
                              int.msg.handle[to.handler] ! msg.int; SIZE dec.handle.array
                              int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                              int.msg.handle[to.handler] ! msg.int; SIZE enc.handle.array
                              int.msg.handle[to.handler] ! msg.str; ")]"
                              int.msg.handle[to.handler] ! msg.end; FALSE
                        TRUE
                          SKIP
                      --}}}
                      -- Carrying: network-hook-handle;
                      --           array of decode-handles;
                      --           array of encode-handles
                      ctb.mgr.handle.svr[from.mgr] ! alloc.new.ctb.confirm; 
                                                     net.hook.handle;
                                                     dec.handle.array; enc.handle.array
                      -- Get CTB-pointer
                      -- Carrying: CTB-pointer
                      ctb.mgr.handle.svr[to.mgr] ? CASE alloc.new.ctb.confirm.ctbptr; ctb.ptr
                      --{{{  IN message
                      IF
                        output.msgs
                          CLAIM int.msg.handle
                            SEQ
                              int.msg.handle[to.handler] ! msg.str; "ctb.mgr: IN ctbmgrh: alloc.new.ctb.confirm.ctbptr; "
                              int.msg.handle[to.handler] ! msg.hex; ctb.ptr
                              int.msg.handle[to.handler] ! msg.end; FALSE
                        TRUE
                          SKIP
                      --}}}
                      -- Update CTB-pointer-array
                      ctb.ptr.array[nct.id] := ctb.ptr
                      -- Increase `num.ctbs'
                      num.ctbs := num.ctbs + 1
                      -- Fork off new CTB-handler
                      --{{{  FORK message
                      IF
                        output.msgs
                          CLAIM int.msg.handle
                            SEQ
                              int.msg.handle[to.handler] ! msg.str; "ctb.mgr: FORK ctb.hdlr ("
                              int.msg.handle[to.handler] ! msg.int; own.node.id
                              int.msg.handle[to.handler] ! msg.str; ", "
                              int.msg.handle[to.handler] ! msg.int; nct.id
                              int.msg.handle[to.handler] ! msg.str; ", FALSE, FALSE, "
                              int.msg.handle[to.handler] ! msg.int; num.chans
                              int.msg.handle[to.handler] ! msg.str; ", "
                              int.msg.handle[to.handler] ! msg.int; num.readers.in.svr
                              int.msg.handle[to.handler] ! msg.str; ", [svr-end], [array ("
                              int.msg.handle[to.handler] ! msg.int; SIZE dec.handle.svr.array
                              int.msg.handle[to.handler] ! msg.str; ")], [array ("
                              int.msg.handle[to.handler] ! msg.int; SIZE enc.handle.svr.array
                              int.msg.handle[to.handler] ! msg.str; ")], [svr-end], [svr-end], [svr-end], [svr-end], [cli-end], [cli-end], [cli-end], "
                              int.msg.handle[to.handler] ! msg.bool; output.msgs
                              int.msg.handle[to.handler] ! msg.str; ", [cli-end])"
                              int.msg.handle[to.handler] ! msg.end; FALSE
                        TRUE
                          SKIP
                      --}}}
                      FORK pony.int.ctb.handler (own.node.id, nct.id, FALSE, FALSE,
                                                 num.chans, num.readers.in.svr,
                                                 net.hook.handle.svr,
                                                 dec.handle.svr.array, enc.handle.svr.array,
                                                 ctb.main.handle.svr, ctb.instant.handle.svr,
                                                 ctb.cli.claim.handle.svr, ctb.svr.claim.handle.svr,
                                                 ctb.mgr.handle,
                                                 link.mgr.handle, master.link.handle,
                                                 output.msgs, int.msg.handle)
                  --}}}
            --}}}
            --{{{  Make CTB networked
            INT nct.id, ctb.ptr, num.chans, num.readers.in.svr:
            BOOL initial.cli.claimed, initial.svr.claimed:
            -- Carrying: NCT-ID;
            --           CTB-pointer;
            --           client-end initially claimed?;
            --           server-end initially claimed?;
            --           number of channel-words;
            --           number of reading-ends in server-end
            make.ctb.networked; nct.id; ctb.ptr;
                                initial.cli.claimed; initial.svr.claimed;
                                num.chans; num.readers.in.svr
              PONY.NETHOOKHANDLE! net.hook.handle:
              PONY.NETHOOKHANDLE? net.hook.handle.svr:
              INITIAL MOBILE []PONY.DECODEHANDLE! dec.handle.array IS MOBILE [num.chans]PONY.DECODEHANDLE!:
              INITIAL MOBILE []PONY.DECODEHANDLE? dec.handle.svr.array IS MOBILE [num.chans]PONY.DECODEHANDLE?:
              INITIAL MOBILE []PONY.ENCODEHANDLE! enc.handle.array IS MOBILE [num.chans]PONY.ENCODEHANDLE!:
              INITIAL MOBILE []PONY.ENCODEHANDLE? enc.handle.svr.array IS MOBILE [num.chans]PONY.ENCODEHANDLE?:
              PONY.INT.CTBMAINHANDLE? ctb.main.handle.svr:
              PONY.INT.CTBINSTANTHANDLE? ctb.instant.handle.svr:
              PONY.INT.CTBCLAIMHANDLE? ctb.cli.claim.handle.svr:
              PONY.INT.CTBCLAIMHANDLE? ctb.svr.claim.handle.svr:
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.mgr: IN ctbmgrh: make.ctb.networked; "
                        int.msg.handle[to.handler] ! msg.int; nct.id
                        int.msg.handle[to.handler] ! msg.str; "; "
                        int.msg.handle[to.handler] ! msg.hex; ctb.ptr
                        int.msg.handle[to.handler] ! msg.str; "; "
                        int.msg.handle[to.handler] ! msg.bool; initial.cli.claimed
                        int.msg.handle[to.handler] ! msg.str; "; "
                        int.msg.handle[to.handler] ! msg.bool; initial.svr.claimed
                        int.msg.handle[to.handler] ! msg.str; "; "
                        int.msg.handle[to.handler] ! msg.int; num.chans
                        int.msg.handle[to.handler] ! msg.str; "; "
                        int.msg.handle[to.handler] ! msg.int; num.readers.in.svr
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                --{{{  Adapt size of arrays if necessary
                IF
                  nct.id >= (SIZE ctb.ptr.array)
                    INITIAL INT old.size IS SIZE ctb.ptr.array:
                    INITIAL INT new.size IS 2 * (SIZE ctb.ptr.array):
                    MOBILE []INT new.ctb.ptr.array:
                    MOBILE []SHARED PONY.INT.CTBMAINHANDLE! new.ctb.main.handle.array:
                    MOBILE []SHARED PONY.INT.CTBINSTANTHANDLE! new.ctb.instant.handle.array:
                    MOBILE []SHARED PONY.INT.CTBCLAIMHANDLE! new.ctb.cli.claim.handle.array:
                    MOBILE []SHARED PONY.INT.CTBCLAIMHANDLE! new.ctb.svr.claim.handle.array:
                    SEQ
                      -- Double size until it fits
                      WHILE nct.id >= new.size
                        new.size := 2 * new.size
                      -- Allocate new arrays
                      new.ctb.ptr.array := MOBILE [new.size]INT
                      new.ctb.main.handle.array := MOBILE [new.size]SHARED PONY.INT.CTBMAINHANDLE!
                      new.ctb.instant.handle.array := MOBILE [new.size]SHARED PONY.INT.CTBINSTANTHANDLE!
                      new.ctb.cli.claim.handle.array := MOBILE [new.size]SHARED PONY.INT.CTBCLAIMHANDLE!
                      new.ctb.svr.claim.handle.array := MOBILE [new.size]SHARED PONY.INT.CTBCLAIMHANDLE!
                      -- Set existing elements in new arrays
                      SEQ i = 0 FOR old.size
                        IF
                          ctb.ptr.array[i] <> 0
                            SEQ
                              new.ctb.main.handle.array[i] := ctb.main.handle.array[i]
                              new.ctb.instant.handle.array[i] := ctb.instant.handle.array[i]
                              new.ctb.cli.claim.handle.array[i] := ctb.cli.claim.handle.array[i]
                              new.ctb.svr.claim.handle.array[i] := ctb.svr.claim.handle.array[i]
                          TRUE
                            SKIP
                      [new.ctb.ptr.array FOR old.size] := ctb.ptr.array
                      -- Initialise new fields of new CTB-pointer-array
                      SEQ i = old.size FOR (new.size - old.size)
                        new.ctb.ptr.array[i] := 0
                      -- Use new arrays
                      ctb.ptr.array := new.ctb.ptr.array
                      ctb.main.handle.array := new.ctb.main.handle.array
                      ctb.instant.handle.array := new.ctb.instant.handle.array
                      ctb.cli.claim.handle.array := new.ctb.cli.claim.handle.array
                      ctb.svr.claim.handle.array := new.ctb.svr.claim.handle.array
                  TRUE
                    SKIP
                --}}}
                -- Initialise new handles
                net.hook.handle, net.hook.handle.svr := MOBILE PONY.NETHOOKHANDLE
                SEQ i = 0 FOR num.chans
                  SEQ
                    dec.handle.array[i], dec.handle.svr.array[i] := MOBILE PONY.DECODEHANDLE
                    enc.handle.array[i], enc.handle.svr.array[i] := MOBILE PONY.ENCODEHANDLE
                ctb.main.handle.array[nct.id], ctb.main.handle.svr := MOBILE PONY.INT.CTBMAINHANDLE
                ctb.instant.handle.array[nct.id], ctb.instant.handle.svr := MOBILE PONY.INT.CTBINSTANTHANDLE
                ctb.cli.claim.handle.array[nct.id], ctb.cli.claim.handle.svr := MOBILE PONY.INT.CTBCLAIMHANDLE
                ctb.svr.claim.handle.array[nct.id], ctb.svr.claim.handle.svr := MOBILE PONY.INT.CTBCLAIMHANDLE
                -- Update CTB-pointer-array
                ctb.ptr.array[nct.id] := ctb.ptr
                -- Increase `num.ctbs'
                num.ctbs := num.ctbs + 1
                -- Send reply
                --{{{  OUT message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.mgr: OUT ctbmgrh: make.ctb.networked.confirm; [cli-end]; [array ("
                        int.msg.handle[to.handler] ! msg.int; SIZE dec.handle.array
                        int.msg.handle[to.handler] ! msg.str; ")]; [array ("
                        int.msg.handle[to.handler] ! msg.int; SIZE enc.handle.array
                        int.msg.handle[to.handler] ! msg.str; ")]"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                -- Carrying: network-hook-handle;
                --           array of decode-handles;
                --           array of encode-handles
                ctb.mgr.handle.svr[from.mgr] ! make.ctb.networked.confirm; 
                                               net.hook.handle;
                                               dec.handle.array; enc.handle.array
                -- Fork off new CTB-handler
                --{{{  FORK message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.mgr: FORK ctb.hdlr ("
                        int.msg.handle[to.handler] ! msg.int; own.node.id
                        int.msg.handle[to.handler] ! msg.str; ", "
                        int.msg.handle[to.handler] ! msg.int; nct.id
                        int.msg.handle[to.handler] ! msg.str; ", "
                        int.msg.handle[to.handler] ! msg.bool; initial.cli.claimed
                        int.msg.handle[to.handler] ! msg.str; ", "
                        int.msg.handle[to.handler] ! msg.bool; initial.svr.claimed
                        int.msg.handle[to.handler] ! msg.str; ", "
                        int.msg.handle[to.handler] ! msg.int; num.chans
                        int.msg.handle[to.handler] ! msg.str; ", "
                        int.msg.handle[to.handler] ! msg.int; num.readers.in.svr
                        int.msg.handle[to.handler] ! msg.str; ", [svr-end], [array ("
                        int.msg.handle[to.handler] ! msg.int; SIZE dec.handle.svr.array
                        int.msg.handle[to.handler] ! msg.str; ")], [array ("
                        int.msg.handle[to.handler] ! msg.int; SIZE enc.handle.svr.array
                        int.msg.handle[to.handler] ! msg.str; ")], [svr-end], [svr-end], [svr-end], [svr-end], [cli-end], [cli-end], [cli-end], "
                        int.msg.handle[to.handler] ! msg.bool; output.msgs
                        int.msg.handle[to.handler] ! msg.str; ", [cli-end])"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                FORK pony.int.ctb.handler (own.node.id, nct.id,
                                           initial.cli.claimed, initial.svr.claimed,
                                           num.chans, num.readers.in.svr,
                                           net.hook.handle.svr,
                                           dec.handle.svr.array, enc.handle.svr.array,
                                           ctb.main.handle.svr, ctb.instant.handle.svr,
                                           ctb.cli.claim.handle.svr, ctb.svr.claim.handle.svr,
                                           ctb.mgr.handle,
                                           link.mgr.handle, master.link.handle,
                                           output.msgs, int.msg.handle)
            --}}}
            --{{{  Shutdown
            shutdown
              INITIAL MOBILE []SHARED PONY.INT.CTBCLAIMHANDLE! to.be.released.claim.handle.array IS MOBILE [2 * num.ctbs]SHARED PONY.INT.CTBCLAIMHANDLE!:
              SEQ
                --{{{  IN message
                IF
                  output.msgs
                    CLAIM int.msg.handle
                      SEQ
                        int.msg.handle[to.handler] ! msg.str; "ctb.mgr: IN ctbmgrh: shutdown"
                        int.msg.handle[to.handler] ! msg.end; FALSE
                  TRUE
                    SKIP
                --}}}
                --{{{  Fill `to.be.released.claim.handle.array'
                INITIAL INT array.index IS 0:
                SEQ i = 0 FOR (SIZE ctb.ptr.array)
                  IF
                    ctb.ptr.array[i] <> 0
                      SEQ
                        -- Update `to.be.released.claim.handle.array'
                        to.be.released.claim.handle.array[array.index] := ctb.cli.claim.handle.array[i]
                        to.be.released.claim.handle.array[array.index + 1] := ctb.svr.claim.handle.array[i]
                        -- Increase index
                        array.index := array.index + 2
                    TRUE
                      SKIP
                --}}}
                -- Pass `to.be.released.claim.handle.array' to releaser
                pass.to.be.released.claim.handle.array ! to.be.released.claim.handle.array
            --}}}
          --{{{  Releaser has finished
          BOOL any:
          release.done ? any
            INITIAL MOBILE []INT final.ctb.ptr.array IS MOBILE [num.ctbs]INT:
            SEQ
              --{{{  Fill `final.ctb.ptr.array' and shut down CTB-handlers
              INITIAL INT array.index IS 0:
              SEQ i = 0 FOR (SIZE ctb.ptr.array)
                IF
                  ctb.ptr.array[i] <> 0
                    SEQ
                      -- Update `final.ctb.ptr.array'
                      final.ctb.ptr.array[array.index] := ctb.ptr.array[i]
                      -- Increase index
                      array.index := array.index + 1
                      -- Send shutdown signal to CTB-handler
                      CLAIM ctb.main.handle.array[i]
                        SEQ
                          --{{{  OUT message
                          IF
                            output.msgs
                              CLAIM int.msg.handle
                                SEQ
                                  int.msg.handle[to.handler] ! msg.str; "ctb.mgr: OUT ctbmainh "
                                  int.msg.handle[to.handler] ! msg.int; i
                                  int.msg.handle[to.handler] ! msg.str; " [to.handler]: shutdown"
                                  int.msg.handle[to.handler] ! msg.end; FALSE
                            TRUE
                              SKIP
                          --}}}
                          ctb.main.handle.array[i][to.handler] ! shutdown
                          -- Get reply
                          ctb.main.handle.array[i][from.handler] ? CASE shutdown.confirm
                          --{{{  IN message
                          IF
                            output.msgs
                              CLAIM int.msg.handle
                                SEQ
                                  int.msg.handle[to.handler] ! msg.str; "ctb.mgr: IN ctbmainh "
                                  int.msg.handle[to.handler] ! msg.int; i
                                  int.msg.handle[to.handler] ! msg.str; ": shutdown.confirm"
                                  int.msg.handle[to.handler] ! msg.end; FALSE
                            TRUE
                              SKIP
                          --}}}
                  TRUE
                    SKIP
              --}}}
              -- Leave main loop
              running := FALSE
              -- Confirm shutdown
              CLAIM kernel.reply.handle
                SEQ
                  --{{{  OUT message
                  IF
                    output.msgs
                      CLAIM int.msg.handle
                        SEQ
                          int.msg.handle[to.handler] ! msg.str; "ctb.mgr: OUT kernelreplyh: fromctbmgr.shutdown.confirm; [array ("
                          int.msg.handle[to.handler] ! msg.int; SIZE final.ctb.ptr.array
                          int.msg.handle[to.handler] ! msg.str; ")]"
                          int.msg.handle[to.handler] ! msg.end; FALSE
                    TRUE
                      SKIP
                  --}}}
                  -- Carrying: array of formerly networked CTB-pointers
                  kernel.reply.handle[to.kernel] ! fromctbmgr.shutdown.confirm;
                                                   final.ctb.ptr.array
          --}}}
:
--}}}

--}}}

