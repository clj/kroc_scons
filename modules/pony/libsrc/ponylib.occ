-- Copyright: Mario Schweigler (C) 2005-2006
-- Institution: Computing Laboratory, University of Kent, Canterbury, UK
-- Description: pony public code file

-- This program is free software; you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 2 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program; if not, write to the Free Software
-- Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
-- MA 02110-1301, USA.

--{{{  Module documentation
--** Transparent networking library for occam-pi programs.
--
-- The documentation for pony has not yet been converted into OccamDoc format.
-- For an introduction to pony, please see
-- "[@link http://www.cs.kent.ac.uk/pubs/2006/2426/ pony - The occam-pi
-- Network Environment]".
--
-- To use this library:
--
-- [@code
-- #INCLUDE "pony.module"]
--
-- @module pony

--}}}

--{{{  Compiler declarations
#INCLUDE "course.module"
#INCLUDE "cif.module"
#INCLUDE "ponylib.inc"
#INCLUDE "ponyint.inc"
#USE "ponyint3.tce"
#INCLUDE "ponyintcif.inc"
--}}}

----------------------------------------------------------------------

--{{{  External processes

--{{{  PROCs pony.startup.*

--{{{  PROC pony.startup.unh
-- Start the pony kernel
-- Returns: unshared network-handle
-- Parameters: net.type    | VAL: network-type
--                           `PONYC.NETTYPE.TCPIP' | TCP/IP
--             ans.name    | VAL: name of the ANS
--             app.name    | VAL: name of the application
--             node.name   | VAL: name of the node
--             node.type   | VAL: node-type
--                           `PONYC.NODETYPE.MASTER'      | master
--                           `PONYC.NODETYPE.MASTERRESET' | master/reset
--                           `PONYC.NODETYPE.SLAVE'       | slave
--                           `PONYC.NODETYPE.SLAVEWAIT'   | slave/wait
--             own.node.id | RESULT: own node-ID
--             net.handle  | RESULT: network-handle
--             result      | RESULT: result
PROC pony.startup.unh (VAL INT net.type,
                       VAL []BYTE ans.name, app.name, node.name,
                       VAL INT node.type,
                       RESULT INT own.node.id,
                       RESULT PONY.NETHANDLE! net.handle,
                       RESULT INT result)
  --{{{  Internal handles
  SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle:
  PONY.INT.CTBMGRHANDLE? ctb.mgr.handle.svr:
  SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle:
  PONY.INT.NCTMGRHANDLE? nct.mgr.handle.svr:
  SHARED PONY.INT.KERNELREPLYHANDLE! kernel.reply.handle:
  PONY.INT.KERNELREPLYHANDLE? kernel.reply.handle.svr:
  SHARED PONY.INT.ERRHANDLE! int.err.handle:
  PONY.INT.ERRHANDLE? int.err.handle.svr:
  SHARED PONY.INT.MSGHANDLE! int.msg.handle:
  PONY.INT.MSGHANDLE? int.msg.handle.svr:
  SHARED PONY.INT.LINKMGRHANDLE! link.mgr.handle:
  --}}}
  SEQ
    --{{{  Allocate internal handles
    ctb.mgr.handle, ctb.mgr.handle.svr := MOBILE PONY.INT.CTBMGRHANDLE
    nct.mgr.handle, nct.mgr.handle.svr := MOBILE PONY.INT.NCTMGRHANDLE
    kernel.reply.handle, kernel.reply.handle.svr := MOBILE PONY.INT.KERNELREPLYHANDLE
    int.err.handle, int.err.handle.svr := MOBILE PONY.INT.ERRHANDLE
    int.msg.handle, int.msg.handle.svr := MOBILE PONY.INT.MSGHANDLE
    --}}}
    -- Start link-manager
    pony.int.startup.linkmgr (net.type, ans.name, app.name,
                              node.name, node.type,
                              ctb.mgr.handle, nct.mgr.handle,
                              kernel.reply.handle,
                              FALSE, int.err.handle,
                              -1, int.msg.handle,
                              own.node.id, link.mgr.handle, result)
    IF
      --{{{  Link-manager started successfully
      result = PONYC.RESULT.STARTUP.OK
        PONY.NETHANDLE? net.handle.svr:
        PONY.ERRHANDLE? err.handle.svr:
        PONY.MSGHANDLE? msg.handle.svr:
        SEQ
          -- Initialise parameters and return values
          net.handle, net.handle.svr := MOBILE PONY.NETHANDLE
          -- Fork off main kernel
          FORK pony.int.main.kernel (own.node.id, net.handle.svr,
                                     link.mgr.handle,
                                     ctb.mgr.handle, ctb.mgr.handle.svr,
                                     nct.mgr.handle, nct.mgr.handle.svr,
                                     kernel.reply.handle, kernel.reply.handle.svr,
                                     FALSE, FALSE, err.handle.svr,
                                     int.err.handle, int.err.handle.svr,
                                     -1, msg.handle.svr,
                                     int.msg.handle, int.msg.handle.svr)
      --}}}
      TRUE
        SKIP
:
--}}}
--{{{  PROC pony.startup.snh
-- Start the pony kernel
-- Returns: shared network-handle
-- Parameters: net.type    | VAL: network-type
--                           `PONYC.NETTYPE.TCPIP' | TCP/IP
--             ans.name    | VAL: name of the ANS
--             app.name    | VAL: name of the application
--             node.name   | VAL: name of the node
--             node.type   | VAL: node-type
--                           `PONYC.NODETYPE.MASTER'      | master
--                           `PONYC.NODETYPE.MASTERRESET' | master/reset
--                           `PONYC.NODETYPE.SLAVE'       | slave
--                           `PONYC.NODETYPE.SLAVEWAIT'   | slave/wait
--             own.node.id | RESULT: own node-ID
--             net.handle  | RESULT: network-handle (shared)
--             result      | RESULT: result
PROC pony.startup.snh (VAL INT net.type,
                       VAL []BYTE ans.name, app.name, node.name,
                       VAL INT node.type,
                       RESULT INT own.node.id,
                       RESULT SHARED PONY.NETHANDLE! net.handle,
                       RESULT INT result)
  --{{{  Internal handles
  SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle:
  PONY.INT.CTBMGRHANDLE? ctb.mgr.handle.svr:
  SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle:
  PONY.INT.NCTMGRHANDLE? nct.mgr.handle.svr:
  SHARED PONY.INT.KERNELREPLYHANDLE! kernel.reply.handle:
  PONY.INT.KERNELREPLYHANDLE? kernel.reply.handle.svr:
  SHARED PONY.INT.ERRHANDLE! int.err.handle:
  PONY.INT.ERRHANDLE? int.err.handle.svr:
  SHARED PONY.INT.MSGHANDLE! int.msg.handle:
  PONY.INT.MSGHANDLE? int.msg.handle.svr:
  SHARED PONY.INT.LINKMGRHANDLE! link.mgr.handle:
  --}}}
  SEQ
    --{{{  Allocate internal handles
    ctb.mgr.handle, ctb.mgr.handle.svr := MOBILE PONY.INT.CTBMGRHANDLE
    nct.mgr.handle, nct.mgr.handle.svr := MOBILE PONY.INT.NCTMGRHANDLE
    kernel.reply.handle, kernel.reply.handle.svr := MOBILE PONY.INT.KERNELREPLYHANDLE
    int.err.handle, int.err.handle.svr := MOBILE PONY.INT.ERRHANDLE
    int.msg.handle, int.msg.handle.svr := MOBILE PONY.INT.MSGHANDLE
    --}}}
    -- Start link-manager
    pony.int.startup.linkmgr (net.type, ans.name, app.name,
                              node.name, node.type,
                              ctb.mgr.handle, nct.mgr.handle,
                              kernel.reply.handle,
                              FALSE, int.err.handle,
                              -1, int.msg.handle,
                              own.node.id, link.mgr.handle, result)
    IF
      --{{{  Link-manager started successfully
      result = PONYC.RESULT.STARTUP.OK
        PONY.NETHANDLE? net.handle.svr:
        PONY.ERRHANDLE? err.handle.svr:
        PONY.MSGHANDLE? msg.handle.svr:
        SEQ
          -- Initialise parameters and return values
          net.handle, net.handle.svr := MOBILE PONY.NETHANDLE
          -- Fork off main kernel
          FORK pony.int.main.kernel (own.node.id, net.handle.svr,
                                     link.mgr.handle,
                                     ctb.mgr.handle, ctb.mgr.handle.svr,
                                     nct.mgr.handle, nct.mgr.handle.svr,
                                     kernel.reply.handle, kernel.reply.handle.svr,
                                     FALSE, FALSE, err.handle.svr,
                                     int.err.handle, int.err.handle.svr,
                                     -1, msg.handle.svr,
                                     int.msg.handle, int.msg.handle.svr)
      --}}}
      TRUE
        SKIP
:
--}}}
--{{{  PROC pony.startup.unh.ueh
-- Start the pony kernel
-- Returns: unshared network-handle
--          unshared error-handle
-- Parameters: net.type    | VAL: network-type
--                           `PONYC.NETTYPE.TCPIP' | TCP/IP
--             ans.name    | VAL: name of the ANS
--             app.name    | VAL: name of the application
--             node.name   | VAL: name of the node
--             node.type   | VAL: node-type
--                           `PONYC.NODETYPE.MASTER'      | master
--                           `PONYC.NODETYPE.MASTERRESET' | master/reset
--                           `PONYC.NODETYPE.SLAVE'       | slave
--                           `PONYC.NODETYPE.SLAVEWAIT'   | slave/wait
--             own.node.id | RESULT: own node-ID
--             net.handle  | RESULT: network-handle
--             err.handle  | RESULT: error-handle
--             result      | RESULT: result
PROC pony.startup.unh.ueh (VAL INT net.type,
                           VAL []BYTE ans.name, app.name, node.name,
                           VAL INT node.type,
                           RESULT INT own.node.id,
                           RESULT PONY.NETHANDLE! net.handle,
                           RESULT PONY.ERRHANDLE! err.handle,
                           RESULT INT result)
  --{{{  Internal handles
  SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle:
  PONY.INT.CTBMGRHANDLE? ctb.mgr.handle.svr:
  SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle:
  PONY.INT.NCTMGRHANDLE? nct.mgr.handle.svr:
  SHARED PONY.INT.KERNELREPLYHANDLE! kernel.reply.handle:
  PONY.INT.KERNELREPLYHANDLE? kernel.reply.handle.svr:
  SHARED PONY.INT.ERRHANDLE! int.err.handle:
  PONY.INT.ERRHANDLE? int.err.handle.svr:
  SHARED PONY.INT.MSGHANDLE! int.msg.handle:
  PONY.INT.MSGHANDLE? int.msg.handle.svr:
  SHARED PONY.INT.LINKMGRHANDLE! link.mgr.handle:
  --}}}
  SEQ
    --{{{  Allocate internal handles
    ctb.mgr.handle, ctb.mgr.handle.svr := MOBILE PONY.INT.CTBMGRHANDLE
    nct.mgr.handle, nct.mgr.handle.svr := MOBILE PONY.INT.NCTMGRHANDLE
    kernel.reply.handle, kernel.reply.handle.svr := MOBILE PONY.INT.KERNELREPLYHANDLE
    int.err.handle, int.err.handle.svr := MOBILE PONY.INT.ERRHANDLE
    int.msg.handle, int.msg.handle.svr := MOBILE PONY.INT.MSGHANDLE
    --}}}
    -- Start link-manager
    pony.int.startup.linkmgr (net.type, ans.name, app.name,
                              node.name, node.type,
                              ctb.mgr.handle, nct.mgr.handle,
                              kernel.reply.handle,
                              TRUE, int.err.handle,
                              -1, int.msg.handle,
                              own.node.id, link.mgr.handle, result)
    IF
      --{{{  Link-manager started successfully
      result = PONYC.RESULT.STARTUP.OK
        PONY.NETHANDLE? net.handle.svr:
        PONY.ERRHANDLE? err.handle.svr:
        PONY.MSGHANDLE? msg.handle.svr:
        SEQ
          -- Initialise parameters and return values
          net.handle, net.handle.svr := MOBILE PONY.NETHANDLE
          err.handle, err.handle.svr := MOBILE PONY.ERRHANDLE
          -- Fork off main kernel
          FORK pony.int.main.kernel (own.node.id, net.handle.svr,
                                     link.mgr.handle,
                                     ctb.mgr.handle, ctb.mgr.handle.svr,
                                     nct.mgr.handle, nct.mgr.handle.svr,
                                     kernel.reply.handle, kernel.reply.handle.svr,
                                     TRUE, FALSE, err.handle.svr,
                                     int.err.handle, int.err.handle.svr,
                                     -1, msg.handle.svr,
                                     int.msg.handle, int.msg.handle.svr)
      --}}}
      TRUE
        SKIP
:
--}}}
--{{{  PROC pony.startup.unh.ueh.iep
-- Start the pony kernel
-- Returns: unshared network-handle
--          unshared error-handle
--          initial error-point
-- Parameters: net.type    | VAL: network-type
--                           `PONYC.NETTYPE.TCPIP' | TCP/IP
--             ans.name    | VAL: name of the ANS
--             app.name    | VAL: name of the application
--             node.name   | VAL: name of the node
--             node.type   | VAL: node-type
--                           `PONYC.NODETYPE.MASTER'      | master
--                           `PONYC.NODETYPE.MASTERRESET' | master/reset
--                           `PONYC.NODETYPE.SLAVE'       | slave
--                           `PONYC.NODETYPE.SLAVEWAIT'   | slave/wait
--             own.node.id | RESULT: own node-ID
--             net.handle  | RESULT: network-handle
--             err.handle  | RESULT: error-handle
--             err.point   | RESULT: initial error-point
--             result      | RESULT: result
PROC pony.startup.unh.ueh.iep (VAL INT net.type,
                               VAL []BYTE ans.name, app.name, node.name,
                               VAL INT node.type,
                               RESULT INT own.node.id,
                               RESULT PONY.NETHANDLE! net.handle,
                               RESULT PONY.ERRHANDLE! err.handle,
                               RESULT INT err.point,
                               RESULT INT result)
  --{{{  Internal handles
  SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle:
  PONY.INT.CTBMGRHANDLE? ctb.mgr.handle.svr:
  SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle:
  PONY.INT.NCTMGRHANDLE? nct.mgr.handle.svr:
  SHARED PONY.INT.KERNELREPLYHANDLE! kernel.reply.handle:
  PONY.INT.KERNELREPLYHANDLE? kernel.reply.handle.svr:
  SHARED PONY.INT.ERRHANDLE! int.err.handle:
  PONY.INT.ERRHANDLE? int.err.handle.svr:
  SHARED PONY.INT.MSGHANDLE! int.msg.handle:
  PONY.INT.MSGHANDLE? int.msg.handle.svr:
  SHARED PONY.INT.LINKMGRHANDLE! link.mgr.handle:
  --}}}
  SEQ
    --{{{  Allocate internal handles
    ctb.mgr.handle, ctb.mgr.handle.svr := MOBILE PONY.INT.CTBMGRHANDLE
    nct.mgr.handle, nct.mgr.handle.svr := MOBILE PONY.INT.NCTMGRHANDLE
    kernel.reply.handle, kernel.reply.handle.svr := MOBILE PONY.INT.KERNELREPLYHANDLE
    int.err.handle, int.err.handle.svr := MOBILE PONY.INT.ERRHANDLE
    int.msg.handle, int.msg.handle.svr := MOBILE PONY.INT.MSGHANDLE
    --}}}
    -- Start link-manager
    pony.int.startup.linkmgr (net.type, ans.name, app.name,
                              node.name, node.type,
                              ctb.mgr.handle, nct.mgr.handle,
                              kernel.reply.handle,
                              TRUE, int.err.handle,
                              -1, int.msg.handle,
                              own.node.id, link.mgr.handle, result)
    IF
      --{{{  Link-manager started successfully
      result = PONYC.RESULT.STARTUP.OK
        PONY.NETHANDLE? net.handle.svr:
        PONY.ERRHANDLE? err.handle.svr:
        PONY.MSGHANDLE? msg.handle.svr:
        SEQ
          -- Initialise parameters and return values
          net.handle, net.handle.svr := MOBILE PONY.NETHANDLE
          err.handle, err.handle.svr := MOBILE PONY.ERRHANDLE
          err.point := PONYC.INT.INITIALERRPOINT
          -- Fork off main kernel
          FORK pony.int.main.kernel (own.node.id, net.handle.svr,
                                     link.mgr.handle,
                                     ctb.mgr.handle, ctb.mgr.handle.svr,
                                     nct.mgr.handle, nct.mgr.handle.svr,
                                     kernel.reply.handle, kernel.reply.handle.svr,
                                     TRUE, TRUE, err.handle.svr,
                                     int.err.handle, int.err.handle.svr,
                                     -1, msg.handle.svr,
                                     int.msg.handle, int.msg.handle.svr)
      --}}}
      TRUE
        SKIP
:
--}}}
--{{{  PROC pony.startup.unh.seh
-- Start the pony kernel
-- Returns: unshared network-handle
--          shared error-handle
-- Parameters: net.type    | VAL: network-type
--                           `PONYC.NETTYPE.TCPIP' | TCP/IP
--             ans.name    | VAL: name of the ANS
--             app.name    | VAL: name of the application
--             node.name   | VAL: name of the node
--             node.type   | VAL: node-type
--                           `PONYC.NODETYPE.MASTER'      | master
--                           `PONYC.NODETYPE.MASTERRESET' | master/reset
--                           `PONYC.NODETYPE.SLAVE'       | slave
--                           `PONYC.NODETYPE.SLAVEWAIT'   | slave/wait
--             own.node.id | RESULT: own node-ID
--             net.handle  | RESULT: network-handle
--             err.handle  | RESULT: error-handle (shared)
--             result      | RESULT: result
PROC pony.startup.unh.seh (VAL INT net.type,
                           VAL []BYTE ans.name, app.name, node.name,
                           VAL INT node.type,
                           RESULT INT own.node.id,
                           RESULT PONY.NETHANDLE! net.handle,
                           RESULT SHARED PONY.ERRHANDLE! err.handle,
                           RESULT INT result)
  --{{{  Internal handles
  SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle:
  PONY.INT.CTBMGRHANDLE? ctb.mgr.handle.svr:
  SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle:
  PONY.INT.NCTMGRHANDLE? nct.mgr.handle.svr:
  SHARED PONY.INT.KERNELREPLYHANDLE! kernel.reply.handle:
  PONY.INT.KERNELREPLYHANDLE? kernel.reply.handle.svr:
  SHARED PONY.INT.ERRHANDLE! int.err.handle:
  PONY.INT.ERRHANDLE? int.err.handle.svr:
  SHARED PONY.INT.MSGHANDLE! int.msg.handle:
  PONY.INT.MSGHANDLE? int.msg.handle.svr:
  SHARED PONY.INT.LINKMGRHANDLE! link.mgr.handle:
  --}}}
  SEQ
    --{{{  Allocate internal handles
    ctb.mgr.handle, ctb.mgr.handle.svr := MOBILE PONY.INT.CTBMGRHANDLE
    nct.mgr.handle, nct.mgr.handle.svr := MOBILE PONY.INT.NCTMGRHANDLE
    kernel.reply.handle, kernel.reply.handle.svr := MOBILE PONY.INT.KERNELREPLYHANDLE
    int.err.handle, int.err.handle.svr := MOBILE PONY.INT.ERRHANDLE
    int.msg.handle, int.msg.handle.svr := MOBILE PONY.INT.MSGHANDLE
    --}}}
    -- Start link-manager
    pony.int.startup.linkmgr (net.type, ans.name, app.name,
                              node.name, node.type,
                              ctb.mgr.handle, nct.mgr.handle,
                              kernel.reply.handle,
                              TRUE, int.err.handle,
                              -1, int.msg.handle,
                              own.node.id, link.mgr.handle, result)
    IF
      --{{{  Link-manager started successfully
      result = PONYC.RESULT.STARTUP.OK
        PONY.NETHANDLE? net.handle.svr:
        PONY.ERRHANDLE? err.handle.svr:
        PONY.MSGHANDLE? msg.handle.svr:
        SEQ
          -- Initialise parameters and return values
          net.handle, net.handle.svr := MOBILE PONY.NETHANDLE
          err.handle, err.handle.svr := MOBILE PONY.ERRHANDLE
          -- Fork off main kernel
          FORK pony.int.main.kernel (own.node.id, net.handle.svr,
                                     link.mgr.handle,
                                     ctb.mgr.handle, ctb.mgr.handle.svr,
                                     nct.mgr.handle, nct.mgr.handle.svr,
                                     kernel.reply.handle, kernel.reply.handle.svr,
                                     TRUE, FALSE, err.handle.svr,
                                     int.err.handle, int.err.handle.svr,
                                     -1, msg.handle.svr,
                                     int.msg.handle, int.msg.handle.svr)
      --}}}
      TRUE
        SKIP
:
--}}}
--{{{  PROC pony.startup.unh.seh.iep
-- Start the pony kernel
-- Returns: unshared network-handle
--          shared error-handle
--          initial error-point
-- Parameters: net.type    | VAL: network-type
--                           `PONYC.NETTYPE.TCPIP' | TCP/IP
--             ans.name    | VAL: name of the ANS
--             app.name    | VAL: name of the application
--             node.name   | VAL: name of the node
--             node.type   | VAL: node-type
--                           `PONYC.NODETYPE.MASTER'      | master
--                           `PONYC.NODETYPE.MASTERRESET' | master/reset
--                           `PONYC.NODETYPE.SLAVE'       | slave
--                           `PONYC.NODETYPE.SLAVEWAIT'   | slave/wait
--             own.node.id | RESULT: own node-ID
--             net.handle  | RESULT: network-handle
--             err.handle  | RESULT: error-handle (shared)
--             err.point   | RESULT: initial error-point
--             result      | RESULT: result
PROC pony.startup.unh.seh.iep (VAL INT net.type,
                               VAL []BYTE ans.name, app.name, node.name,
                               VAL INT node.type,
                               RESULT INT own.node.id,
                               RESULT PONY.NETHANDLE! net.handle,
                               RESULT SHARED PONY.ERRHANDLE! err.handle,
                               RESULT INT err.point,
                               RESULT INT result)
  --{{{  Internal handles
  SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle:
  PONY.INT.CTBMGRHANDLE? ctb.mgr.handle.svr:
  SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle:
  PONY.INT.NCTMGRHANDLE? nct.mgr.handle.svr:
  SHARED PONY.INT.KERNELREPLYHANDLE! kernel.reply.handle:
  PONY.INT.KERNELREPLYHANDLE? kernel.reply.handle.svr:
  SHARED PONY.INT.ERRHANDLE! int.err.handle:
  PONY.INT.ERRHANDLE? int.err.handle.svr:
  SHARED PONY.INT.MSGHANDLE! int.msg.handle:
  PONY.INT.MSGHANDLE? int.msg.handle.svr:
  SHARED PONY.INT.LINKMGRHANDLE! link.mgr.handle:
  --}}}
  SEQ
    --{{{  Allocate internal handles
    ctb.mgr.handle, ctb.mgr.handle.svr := MOBILE PONY.INT.CTBMGRHANDLE
    nct.mgr.handle, nct.mgr.handle.svr := MOBILE PONY.INT.NCTMGRHANDLE
    kernel.reply.handle, kernel.reply.handle.svr := MOBILE PONY.INT.KERNELREPLYHANDLE
    int.err.handle, int.err.handle.svr := MOBILE PONY.INT.ERRHANDLE
    int.msg.handle, int.msg.handle.svr := MOBILE PONY.INT.MSGHANDLE
    --}}}
    -- Start link-manager
    pony.int.startup.linkmgr (net.type, ans.name, app.name,
                              node.name, node.type,
                              ctb.mgr.handle, nct.mgr.handle,
                              kernel.reply.handle,
                              TRUE, int.err.handle,
                              -1, int.msg.handle,
                              own.node.id, link.mgr.handle, result)
    IF
      --{{{  Link-manager started successfully
      result = PONYC.RESULT.STARTUP.OK
        PONY.NETHANDLE? net.handle.svr:
        PONY.ERRHANDLE? err.handle.svr:
        PONY.MSGHANDLE? msg.handle.svr:
        SEQ
          -- Initialise parameters and return values
          net.handle, net.handle.svr := MOBILE PONY.NETHANDLE
          err.handle, err.handle.svr := MOBILE PONY.ERRHANDLE
          err.point := PONYC.INT.INITIALERRPOINT
          -- Fork off main kernel
          FORK pony.int.main.kernel (own.node.id, net.handle.svr,
                                     link.mgr.handle,
                                     ctb.mgr.handle, ctb.mgr.handle.svr,
                                     nct.mgr.handle, nct.mgr.handle.svr,
                                     kernel.reply.handle, kernel.reply.handle.svr,
                                     TRUE, TRUE, err.handle.svr,
                                     int.err.handle, int.err.handle.svr,
                                     -1, msg.handle.svr,
                                     int.msg.handle, int.msg.handle.svr)
      --}}}
      TRUE
        SKIP
:
--}}}
--{{{  PROC pony.startup.snh.ueh
-- Start the pony kernel
-- Returns: shared network-handle
--          unshared error-handle
-- Parameters: net.type    | VAL: network-type
--                           `PONYC.NETTYPE.TCPIP' | TCP/IP
--             ans.name    | VAL: name of the ANS
--             app.name    | VAL: name of the application
--             node.name   | VAL: name of the node
--             node.type   | VAL: node-type
--                           `PONYC.NODETYPE.MASTER'      | master
--                           `PONYC.NODETYPE.MASTERRESET' | master/reset
--                           `PONYC.NODETYPE.SLAVE'       | slave
--                           `PONYC.NODETYPE.SLAVEWAIT'   | slave/wait
--             own.node.id | RESULT: own node-ID
--             net.handle  | RESULT: network-handle (shared)
--             err.handle  | RESULT: error-handle
--             result      | RESULT: result
PROC pony.startup.snh.ueh (VAL INT net.type,
                           VAL []BYTE ans.name, app.name, node.name,
                           VAL INT node.type,
                           RESULT INT own.node.id,
                           RESULT SHARED PONY.NETHANDLE! net.handle,
                           RESULT PONY.ERRHANDLE! err.handle,
                           RESULT INT result)
  --{{{  Internal handles
  SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle:
  PONY.INT.CTBMGRHANDLE? ctb.mgr.handle.svr:
  SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle:
  PONY.INT.NCTMGRHANDLE? nct.mgr.handle.svr:
  SHARED PONY.INT.KERNELREPLYHANDLE! kernel.reply.handle:
  PONY.INT.KERNELREPLYHANDLE? kernel.reply.handle.svr:
  SHARED PONY.INT.ERRHANDLE! int.err.handle:
  PONY.INT.ERRHANDLE? int.err.handle.svr:
  SHARED PONY.INT.MSGHANDLE! int.msg.handle:
  PONY.INT.MSGHANDLE? int.msg.handle.svr:
  SHARED PONY.INT.LINKMGRHANDLE! link.mgr.handle:
  --}}}
  SEQ
    --{{{  Allocate internal handles
    ctb.mgr.handle, ctb.mgr.handle.svr := MOBILE PONY.INT.CTBMGRHANDLE
    nct.mgr.handle, nct.mgr.handle.svr := MOBILE PONY.INT.NCTMGRHANDLE
    kernel.reply.handle, kernel.reply.handle.svr := MOBILE PONY.INT.KERNELREPLYHANDLE
    int.err.handle, int.err.handle.svr := MOBILE PONY.INT.ERRHANDLE
    int.msg.handle, int.msg.handle.svr := MOBILE PONY.INT.MSGHANDLE
    --}}}
    -- Start link-manager
    pony.int.startup.linkmgr (net.type, ans.name, app.name,
                              node.name, node.type,
                              ctb.mgr.handle, nct.mgr.handle,
                              kernel.reply.handle,
                              TRUE, int.err.handle,
                              -1, int.msg.handle,
                              own.node.id, link.mgr.handle, result)
    IF
      --{{{  Link-manager started successfully
      result = PONYC.RESULT.STARTUP.OK
        PONY.NETHANDLE? net.handle.svr:
        PONY.ERRHANDLE? err.handle.svr:
        PONY.MSGHANDLE? msg.handle.svr:
        SEQ
          -- Initialise parameters and return values
          net.handle, net.handle.svr := MOBILE PONY.NETHANDLE
          err.handle, err.handle.svr := MOBILE PONY.ERRHANDLE
          -- Fork off main kernel
          FORK pony.int.main.kernel (own.node.id, net.handle.svr,
                                     link.mgr.handle,
                                     ctb.mgr.handle, ctb.mgr.handle.svr,
                                     nct.mgr.handle, nct.mgr.handle.svr,
                                     kernel.reply.handle, kernel.reply.handle.svr,
                                     TRUE, FALSE, err.handle.svr,
                                     int.err.handle, int.err.handle.svr,
                                     -1, msg.handle.svr,
                                     int.msg.handle, int.msg.handle.svr)
      --}}}
      TRUE
        SKIP
:
--}}}
--{{{  PROC pony.startup.snh.ueh.iep
-- Start the pony kernel
-- Returns: shared network-handle
--          unshared error-handle
--          initial error-point
-- Parameters: net.type    | VAL: network-type
--                           `PONYC.NETTYPE.TCPIP' | TCP/IP
--             ans.name    | VAL: name of the ANS
--             app.name    | VAL: name of the application
--             node.name   | VAL: name of the node
--             node.type   | VAL: node-type
--                           `PONYC.NODETYPE.MASTER'      | master
--                           `PONYC.NODETYPE.MASTERRESET' | master/reset
--                           `PONYC.NODETYPE.SLAVE'       | slave
--                           `PONYC.NODETYPE.SLAVEWAIT'   | slave/wait
--             own.node.id | RESULT: own node-ID
--             net.handle  | RESULT: network-handle (shared)
--             err.handle  | RESULT: error-handle
--             err.point   | RESULT: initial error-point
--             result      | RESULT: result
PROC pony.startup.snh.ueh.iep (VAL INT net.type,
                               VAL []BYTE ans.name, app.name, node.name,
                               VAL INT node.type,
                               RESULT INT own.node.id,
                               RESULT SHARED PONY.NETHANDLE! net.handle,
                               RESULT PONY.ERRHANDLE! err.handle,
                               RESULT INT err.point,
                               RESULT INT result)
  --{{{  Internal handles
  SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle:
  PONY.INT.CTBMGRHANDLE? ctb.mgr.handle.svr:
  SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle:
  PONY.INT.NCTMGRHANDLE? nct.mgr.handle.svr:
  SHARED PONY.INT.KERNELREPLYHANDLE! kernel.reply.handle:
  PONY.INT.KERNELREPLYHANDLE? kernel.reply.handle.svr:
  SHARED PONY.INT.ERRHANDLE! int.err.handle:
  PONY.INT.ERRHANDLE? int.err.handle.svr:
  SHARED PONY.INT.MSGHANDLE! int.msg.handle:
  PONY.INT.MSGHANDLE? int.msg.handle.svr:
  SHARED PONY.INT.LINKMGRHANDLE! link.mgr.handle:
  --}}}
  SEQ
    --{{{  Allocate internal handles
    ctb.mgr.handle, ctb.mgr.handle.svr := MOBILE PONY.INT.CTBMGRHANDLE
    nct.mgr.handle, nct.mgr.handle.svr := MOBILE PONY.INT.NCTMGRHANDLE
    kernel.reply.handle, kernel.reply.handle.svr := MOBILE PONY.INT.KERNELREPLYHANDLE
    int.err.handle, int.err.handle.svr := MOBILE PONY.INT.ERRHANDLE
    int.msg.handle, int.msg.handle.svr := MOBILE PONY.INT.MSGHANDLE
    --}}}
    -- Start link-manager
    pony.int.startup.linkmgr (net.type, ans.name, app.name,
                              node.name, node.type,
                              ctb.mgr.handle, nct.mgr.handle,
                              kernel.reply.handle,
                              TRUE, int.err.handle,
                              -1, int.msg.handle,
                              own.node.id, link.mgr.handle, result)
    IF
      --{{{  Link-manager started successfully
      result = PONYC.RESULT.STARTUP.OK
        PONY.NETHANDLE? net.handle.svr:
        PONY.ERRHANDLE? err.handle.svr:
        PONY.MSGHANDLE? msg.handle.svr:
        SEQ
          -- Initialise parameters and return values
          net.handle, net.handle.svr := MOBILE PONY.NETHANDLE
          err.handle, err.handle.svr := MOBILE PONY.ERRHANDLE
          err.point := PONYC.INT.INITIALERRPOINT
          -- Fork off main kernel
          FORK pony.int.main.kernel (own.node.id, net.handle.svr,
                                     link.mgr.handle,
                                     ctb.mgr.handle, ctb.mgr.handle.svr,
                                     nct.mgr.handle, nct.mgr.handle.svr,
                                     kernel.reply.handle, kernel.reply.handle.svr,
                                     TRUE, TRUE, err.handle.svr,
                                     int.err.handle, int.err.handle.svr,
                                     -1, msg.handle.svr,
                                     int.msg.handle, int.msg.handle.svr)
      --}}}
      TRUE
        SKIP
:
--}}}
--{{{  PROC pony.startup.snh.seh
-- Start the pony kernel
-- Returns: shared network-handle
--          shared error-handle
-- Parameters: net.type    | VAL: network-type
--                           `PONYC.NETTYPE.TCPIP' | TCP/IP
--             ans.name    | VAL: name of the ANS
--             app.name    | VAL: name of the application
--             node.name   | VAL: name of the node
--             node.type   | VAL: node-type
--                           `PONYC.NODETYPE.MASTER'      | master
--                           `PONYC.NODETYPE.MASTERRESET' | master/reset
--                           `PONYC.NODETYPE.SLAVE'       | slave
--                           `PONYC.NODETYPE.SLAVEWAIT'   | slave/wait
--             own.node.id | RESULT: own node-ID
--             net.handle  | RESULT: network-handle (shared)
--             err.handle  | RESULT: error-handle (shared)
--             result      | RESULT: result
PROC pony.startup.snh.seh (VAL INT net.type,
                           VAL []BYTE ans.name, app.name, node.name,
                           VAL INT node.type,
                           RESULT INT own.node.id,
                           RESULT SHARED PONY.NETHANDLE! net.handle,
                           RESULT SHARED PONY.ERRHANDLE! err.handle,
                           RESULT INT result)
  --{{{  Internal handles
  SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle:
  PONY.INT.CTBMGRHANDLE? ctb.mgr.handle.svr:
  SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle:
  PONY.INT.NCTMGRHANDLE? nct.mgr.handle.svr:
  SHARED PONY.INT.KERNELREPLYHANDLE! kernel.reply.handle:
  PONY.INT.KERNELREPLYHANDLE? kernel.reply.handle.svr:
  SHARED PONY.INT.ERRHANDLE! int.err.handle:
  PONY.INT.ERRHANDLE? int.err.handle.svr:
  SHARED PONY.INT.MSGHANDLE! int.msg.handle:
  PONY.INT.MSGHANDLE? int.msg.handle.svr:
  SHARED PONY.INT.LINKMGRHANDLE! link.mgr.handle:
  --}}}
  SEQ
    --{{{  Allocate internal handles
    ctb.mgr.handle, ctb.mgr.handle.svr := MOBILE PONY.INT.CTBMGRHANDLE
    nct.mgr.handle, nct.mgr.handle.svr := MOBILE PONY.INT.NCTMGRHANDLE
    kernel.reply.handle, kernel.reply.handle.svr := MOBILE PONY.INT.KERNELREPLYHANDLE
    int.err.handle, int.err.handle.svr := MOBILE PONY.INT.ERRHANDLE
    int.msg.handle, int.msg.handle.svr := MOBILE PONY.INT.MSGHANDLE
    --}}}
    -- Start link-manager
    pony.int.startup.linkmgr (net.type, ans.name, app.name,
                              node.name, node.type,
                              ctb.mgr.handle, nct.mgr.handle,
                              kernel.reply.handle,
                              TRUE, int.err.handle,
                              -1, int.msg.handle,
                              own.node.id, link.mgr.handle, result)
    IF
      --{{{  Link-manager started successfully
      result = PONYC.RESULT.STARTUP.OK
        PONY.NETHANDLE? net.handle.svr:
        PONY.ERRHANDLE? err.handle.svr:
        PONY.MSGHANDLE? msg.handle.svr:
        SEQ
          -- Initialise parameters and return values
          net.handle, net.handle.svr := MOBILE PONY.NETHANDLE
          err.handle, err.handle.svr := MOBILE PONY.ERRHANDLE
          -- Fork off main kernel
          FORK pony.int.main.kernel (own.node.id, net.handle.svr,
                                     link.mgr.handle,
                                     ctb.mgr.handle, ctb.mgr.handle.svr,
                                     nct.mgr.handle, nct.mgr.handle.svr,
                                     kernel.reply.handle, kernel.reply.handle.svr,
                                     TRUE, FALSE, err.handle.svr,
                                     int.err.handle, int.err.handle.svr,
                                     -1, msg.handle.svr,
                                     int.msg.handle, int.msg.handle.svr)
      --}}}
      TRUE
        SKIP
:
--}}}
--{{{  PROC pony.startup.snh.seh.iep
-- Start the pony kernel
-- Returns: shared network-handle
--          shared error-handle
--          initial error-point
-- Parameters: net.type    | VAL: network-type
--                           `PONYC.NETTYPE.TCPIP' | TCP/IP
--             ans.name    | VAL: name of the ANS
--             app.name    | VAL: name of the application
--             node.name   | VAL: name of the node
--             node.type   | VAL: node-type
--                           `PONYC.NODETYPE.MASTER'      | master
--                           `PONYC.NODETYPE.MASTERRESET' | master/reset
--                           `PONYC.NODETYPE.SLAVE'       | slave
--                           `PONYC.NODETYPE.SLAVEWAIT'   | slave/wait
--             own.node.id | RESULT: own node-ID
--             net.handle  | RESULT: network-handle (shared)
--             err.handle  | RESULT: error-handle (shared)
--             err.point   | RESULT: initial error-point
--             result      | RESULT: result
PROC pony.startup.snh.seh.iep (VAL INT net.type,
                               VAL []BYTE ans.name, app.name, node.name,
                               VAL INT node.type,
                               RESULT INT own.node.id,
                               RESULT SHARED PONY.NETHANDLE! net.handle,
                               RESULT SHARED PONY.ERRHANDLE! err.handle,
                               RESULT INT err.point,
                               RESULT INT result)
  --{{{  Internal handles
  SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle:
  PONY.INT.CTBMGRHANDLE? ctb.mgr.handle.svr:
  SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle:
  PONY.INT.NCTMGRHANDLE? nct.mgr.handle.svr:
  SHARED PONY.INT.KERNELREPLYHANDLE! kernel.reply.handle:
  PONY.INT.KERNELREPLYHANDLE? kernel.reply.handle.svr:
  SHARED PONY.INT.ERRHANDLE! int.err.handle:
  PONY.INT.ERRHANDLE? int.err.handle.svr:
  SHARED PONY.INT.MSGHANDLE! int.msg.handle:
  PONY.INT.MSGHANDLE? int.msg.handle.svr:
  SHARED PONY.INT.LINKMGRHANDLE! link.mgr.handle:
  --}}}
  SEQ
    --{{{  Allocate internal handles
    ctb.mgr.handle, ctb.mgr.handle.svr := MOBILE PONY.INT.CTBMGRHANDLE
    nct.mgr.handle, nct.mgr.handle.svr := MOBILE PONY.INT.NCTMGRHANDLE
    kernel.reply.handle, kernel.reply.handle.svr := MOBILE PONY.INT.KERNELREPLYHANDLE
    int.err.handle, int.err.handle.svr := MOBILE PONY.INT.ERRHANDLE
    int.msg.handle, int.msg.handle.svr := MOBILE PONY.INT.MSGHANDLE
    --}}}
    -- Start link-manager
    pony.int.startup.linkmgr (net.type, ans.name, app.name,
                              node.name, node.type,
                              ctb.mgr.handle, nct.mgr.handle,
                              kernel.reply.handle,
                              TRUE, int.err.handle,
                              -1, int.msg.handle,
                              own.node.id, link.mgr.handle, result)
    IF
      --{{{  Link-manager started successfully
      result = PONYC.RESULT.STARTUP.OK
        PONY.NETHANDLE? net.handle.svr:
        PONY.ERRHANDLE? err.handle.svr:
        PONY.MSGHANDLE? msg.handle.svr:
        SEQ
          -- Initialise parameters and return values
          net.handle, net.handle.svr := MOBILE PONY.NETHANDLE
          err.handle, err.handle.svr := MOBILE PONY.ERRHANDLE
          err.point := PONYC.INT.INITIALERRPOINT
          -- Fork off main kernel
          FORK pony.int.main.kernel (own.node.id, net.handle.svr,
                                     link.mgr.handle,
                                     ctb.mgr.handle, ctb.mgr.handle.svr,
                                     nct.mgr.handle, nct.mgr.handle.svr,
                                     kernel.reply.handle, kernel.reply.handle.svr,
                                     TRUE, TRUE, err.handle.svr,
                                     int.err.handle, int.err.handle.svr,
                                     -1, msg.handle.svr,
                                     int.msg.handle, int.msg.handle.svr)
      --}}}
      TRUE
        SKIP
:
--}}}
--{{{  PROC pony.startup.unh.mh
-- Start the pony kernel
-- Returns: unshared network-handle
--          message-handle
-- Parameters: msg.type    | VAL: message-type
--                           `PONYC.MSGTYPE.STATUS'    | status messages
--                           `PONYC.MSGTYPE.ERR'       | error messages
--                           `PONYC.MSGTYPE.STATUSERR' | both
--             net.type    | VAL: network-type
--                           `PONYC.NETTYPE.TCPIP' | TCP/IP
--             ans.name    | VAL: name of the ANS
--             app.name    | VAL: name of the application
--             node.name   | VAL: name of the node
--             node.type   | VAL: node-type
--                           `PONYC.NODETYPE.MASTER'      | master
--                           `PONYC.NODETYPE.MASTERRESET' | master/reset
--                           `PONYC.NODETYPE.SLAVE'       | slave
--                           `PONYC.NODETYPE.SLAVEWAIT'   | slave/wait
--             own.node.id | RESULT: own node-ID
--             net.handle  | RESULT: network-handle
--             msg.handle  | RESULT: message-handle
--             result      | RESULT: result
PROC pony.startup.unh.mh (VAL INT msg.type, net.type,
                          VAL []BYTE ans.name, app.name, node.name,
                          VAL INT node.type,
                          RESULT INT own.node.id,
                          RESULT PONY.NETHANDLE! net.handle,
                          RESULT PONY.MSGHANDLE! msg.handle,
                          RESULT INT result)
  --{{{  Internal handles
  SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle:
  PONY.INT.CTBMGRHANDLE? ctb.mgr.handle.svr:
  SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle:
  PONY.INT.NCTMGRHANDLE? nct.mgr.handle.svr:
  SHARED PONY.INT.KERNELREPLYHANDLE! kernel.reply.handle:
  PONY.INT.KERNELREPLYHANDLE? kernel.reply.handle.svr:
  SHARED PONY.INT.ERRHANDLE! int.err.handle:
  PONY.INT.ERRHANDLE? int.err.handle.svr:
  SHARED PONY.INT.MSGHANDLE! int.msg.handle:
  PONY.INT.MSGHANDLE? int.msg.handle.svr:
  SHARED PONY.INT.LINKMGRHANDLE! link.mgr.handle:
  --}}}
  SEQ
    CASE msg.type
      PONYC.MSGTYPE.STATUS, PONYC.MSGTYPE.ERR, PONYC.MSGTYPE.STATUSERR
        SEQ
          --{{{  Allocate internal handles
          ctb.mgr.handle, ctb.mgr.handle.svr := MOBILE PONY.INT.CTBMGRHANDLE
          nct.mgr.handle, nct.mgr.handle.svr := MOBILE PONY.INT.NCTMGRHANDLE
          kernel.reply.handle, kernel.reply.handle.svr := MOBILE PONY.INT.KERNELREPLYHANDLE
          int.err.handle, int.err.handle.svr := MOBILE PONY.INT.ERRHANDLE
          int.msg.handle, int.msg.handle.svr := MOBILE PONY.INT.MSGHANDLE
          --}}}
          -- Start link-manager
          pony.int.startup.linkmgr (net.type, ans.name, app.name,
                                    node.name, node.type,
                                    ctb.mgr.handle, nct.mgr.handle,
                                    kernel.reply.handle,
                                    FALSE, int.err.handle,
                                    msg.type, int.msg.handle,
                                    own.node.id, link.mgr.handle, result)
      ELSE
        result := PONYC.RESULT.STARTUP.ILLEGALMSGTYPE
    IF
      --{{{  Link-manager started successfully
      result = PONYC.RESULT.STARTUP.OK
        PONY.NETHANDLE? net.handle.svr:
        PONY.ERRHANDLE? err.handle.svr:
        PONY.MSGHANDLE? msg.handle.svr:
        SEQ
          -- Initialise parameters and return values
          net.handle, net.handle.svr := MOBILE PONY.NETHANDLE
          msg.handle, msg.handle.svr := MOBILE PONY.MSGHANDLE
          -- Fork off main kernel
          FORK pony.int.main.kernel (own.node.id, net.handle.svr,
                                     link.mgr.handle,
                                     ctb.mgr.handle, ctb.mgr.handle.svr,
                                     nct.mgr.handle, nct.mgr.handle.svr,
                                     kernel.reply.handle, kernel.reply.handle.svr,
                                     FALSE, FALSE, err.handle.svr,
                                     int.err.handle, int.err.handle.svr,
                                     msg.type, msg.handle.svr,
                                     int.msg.handle, int.msg.handle.svr)
      --}}}
      TRUE
        SKIP
:
--}}}
--{{{  PROC pony.startup.snh.mh
-- Start the pony kernel
-- Returns: shared network-handle
--          message-handle
-- Parameters: msg.type    | VAL: message-type
--                           `PONYC.MSGTYPE.STATUS'    | status messages
--                           `PONYC.MSGTYPE.ERR'       | error messages
--                           `PONYC.MSGTYPE.STATUSERR' | both
--             net.type    | VAL: network-type
--                           `PONYC.NETTYPE.TCPIP' | TCP/IP
--             ans.name    | VAL: name of the ANS
--             app.name    | VAL: name of the application
--             node.name   | VAL: name of the node
--             node.type   | VAL: node-type
--                           `PONYC.NODETYPE.MASTER'      | master
--                           `PONYC.NODETYPE.MASTERRESET' | master/reset
--                           `PONYC.NODETYPE.SLAVE'       | slave
--                           `PONYC.NODETYPE.SLAVEWAIT'   | slave/wait
--             own.node.id | RESULT: own node-ID
--             net.handle  | RESULT: network-handle (shared)
--             msg.handle  | RESULT: message-handle
--             result      | RESULT: result
PROC pony.startup.snh.mh (VAL INT msg.type, net.type,
                          VAL []BYTE ans.name, app.name, node.name,
                          VAL INT node.type,
                          RESULT INT own.node.id,
                          RESULT SHARED PONY.NETHANDLE! net.handle,
                          RESULT PONY.MSGHANDLE! msg.handle,
                          RESULT INT result)
  --{{{  Internal handles
  SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle:
  PONY.INT.CTBMGRHANDLE? ctb.mgr.handle.svr:
  SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle:
  PONY.INT.NCTMGRHANDLE? nct.mgr.handle.svr:
  SHARED PONY.INT.KERNELREPLYHANDLE! kernel.reply.handle:
  PONY.INT.KERNELREPLYHANDLE? kernel.reply.handle.svr:
  SHARED PONY.INT.ERRHANDLE! int.err.handle:
  PONY.INT.ERRHANDLE? int.err.handle.svr:
  SHARED PONY.INT.MSGHANDLE! int.msg.handle:
  PONY.INT.MSGHANDLE? int.msg.handle.svr:
  SHARED PONY.INT.LINKMGRHANDLE! link.mgr.handle:
  --}}}
  SEQ
    CASE msg.type
      PONYC.MSGTYPE.STATUS, PONYC.MSGTYPE.ERR, PONYC.MSGTYPE.STATUSERR
        SEQ
          --{{{  Allocate internal handles
          ctb.mgr.handle, ctb.mgr.handle.svr := MOBILE PONY.INT.CTBMGRHANDLE
          nct.mgr.handle, nct.mgr.handle.svr := MOBILE PONY.INT.NCTMGRHANDLE
          kernel.reply.handle, kernel.reply.handle.svr := MOBILE PONY.INT.KERNELREPLYHANDLE
          int.err.handle, int.err.handle.svr := MOBILE PONY.INT.ERRHANDLE
          int.msg.handle, int.msg.handle.svr := MOBILE PONY.INT.MSGHANDLE
          --}}}
          -- Start link-manager
          pony.int.startup.linkmgr (net.type, ans.name, app.name,
                                    node.name, node.type,
                                    ctb.mgr.handle, nct.mgr.handle,
                                    kernel.reply.handle,
                                    FALSE, int.err.handle,
                                    msg.type, int.msg.handle,
                                    own.node.id, link.mgr.handle, result)
      ELSE
        result := PONYC.RESULT.STARTUP.ILLEGALMSGTYPE
    IF
      --{{{  Link-manager started successfully
      result = PONYC.RESULT.STARTUP.OK
        PONY.NETHANDLE? net.handle.svr:
        PONY.ERRHANDLE? err.handle.svr:
        PONY.MSGHANDLE? msg.handle.svr:
        SEQ
          -- Initialise parameters and return values
          net.handle, net.handle.svr := MOBILE PONY.NETHANDLE
          msg.handle, msg.handle.svr := MOBILE PONY.MSGHANDLE
          -- Fork off main kernel
          FORK pony.int.main.kernel (own.node.id, net.handle.svr,
                                     link.mgr.handle,
                                     ctb.mgr.handle, ctb.mgr.handle.svr,
                                     nct.mgr.handle, nct.mgr.handle.svr,
                                     kernel.reply.handle, kernel.reply.handle.svr,
                                     FALSE, FALSE, err.handle.svr,
                                     int.err.handle, int.err.handle.svr,
                                     msg.type, msg.handle.svr,
                                     int.msg.handle, int.msg.handle.svr)
      --}}}
      TRUE
        SKIP
:
--}}}
--{{{  PROC pony.startup.unh.ueh.mh
-- Start the pony kernel
-- Returns: unshared network-handle
--          unshared error-handle
--          message-handle
-- Parameters: msg.type    | VAL: message-type
--                           `PONYC.MSGTYPE.STATUS'    | status messages
--                           `PONYC.MSGTYPE.ERR'       | error messages
--                           `PONYC.MSGTYPE.STATUSERR' | both
--             net.type    | VAL: network-type
--                           `PONYC.NETTYPE.TCPIP' | TCP/IP
--             ans.name    | VAL: name of the ANS
--             app.name    | VAL: name of the application
--             node.name   | VAL: name of the node
--             node.type   | VAL: node-type
--                           `PONYC.NODETYPE.MASTER'      | master
--                           `PONYC.NODETYPE.MASTERRESET' | master/reset
--                           `PONYC.NODETYPE.SLAVE'       | slave
--                           `PONYC.NODETYPE.SLAVEWAIT'   | slave/wait
--             own.node.id | RESULT: own node-ID
--             net.handle  | RESULT: network-handle
--             err.handle  | RESULT: error-handle
--             msg.handle  | RESULT: message-handle
--             result      | RESULT: result
PROC pony.startup.unh.ueh.mh (VAL INT msg.type, net.type,
                              VAL []BYTE ans.name, app.name, node.name,
                              VAL INT node.type,
                              RESULT INT own.node.id,
                              RESULT PONY.NETHANDLE! net.handle,
                              RESULT PONY.ERRHANDLE! err.handle,
                              RESULT PONY.MSGHANDLE! msg.handle,
                              RESULT INT result)
  --{{{  Internal handles
  SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle:
  PONY.INT.CTBMGRHANDLE? ctb.mgr.handle.svr:
  SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle:
  PONY.INT.NCTMGRHANDLE? nct.mgr.handle.svr:
  SHARED PONY.INT.KERNELREPLYHANDLE! kernel.reply.handle:
  PONY.INT.KERNELREPLYHANDLE? kernel.reply.handle.svr:
  SHARED PONY.INT.ERRHANDLE! int.err.handle:
  PONY.INT.ERRHANDLE? int.err.handle.svr:
  SHARED PONY.INT.MSGHANDLE! int.msg.handle:
  PONY.INT.MSGHANDLE? int.msg.handle.svr:
  SHARED PONY.INT.LINKMGRHANDLE! link.mgr.handle:
  --}}}
  SEQ
    CASE msg.type
      PONYC.MSGTYPE.STATUS, PONYC.MSGTYPE.ERR, PONYC.MSGTYPE.STATUSERR
        SEQ
          --{{{  Allocate internal handles
          ctb.mgr.handle, ctb.mgr.handle.svr := MOBILE PONY.INT.CTBMGRHANDLE
          nct.mgr.handle, nct.mgr.handle.svr := MOBILE PONY.INT.NCTMGRHANDLE
          kernel.reply.handle, kernel.reply.handle.svr := MOBILE PONY.INT.KERNELREPLYHANDLE
          int.err.handle, int.err.handle.svr := MOBILE PONY.INT.ERRHANDLE
          int.msg.handle, int.msg.handle.svr := MOBILE PONY.INT.MSGHANDLE
          --}}}
          -- Start link-manager
          pony.int.startup.linkmgr (net.type, ans.name, app.name,
                                    node.name, node.type,
                                    ctb.mgr.handle, nct.mgr.handle,
                                    kernel.reply.handle,
                                    TRUE, int.err.handle,
                                    msg.type, int.msg.handle,
                                    own.node.id, link.mgr.handle, result)
      ELSE
        result := PONYC.RESULT.STARTUP.ILLEGALMSGTYPE
    IF
      --{{{  Link-manager started successfully
      result = PONYC.RESULT.STARTUP.OK
        PONY.NETHANDLE? net.handle.svr:
        PONY.ERRHANDLE? err.handle.svr:
        PONY.MSGHANDLE? msg.handle.svr:
        SEQ
          -- Initialise parameters and return values
          net.handle, net.handle.svr := MOBILE PONY.NETHANDLE
          err.handle, err.handle.svr := MOBILE PONY.ERRHANDLE
          msg.handle, msg.handle.svr := MOBILE PONY.MSGHANDLE
          -- Fork off main kernel
          FORK pony.int.main.kernel (own.node.id, net.handle.svr,
                                     link.mgr.handle,
                                     ctb.mgr.handle, ctb.mgr.handle.svr,
                                     nct.mgr.handle, nct.mgr.handle.svr,
                                     kernel.reply.handle, kernel.reply.handle.svr,
                                     TRUE, FALSE, err.handle.svr,
                                     int.err.handle, int.err.handle.svr,
                                     msg.type, msg.handle.svr,
                                     int.msg.handle, int.msg.handle.svr)
      --}}}
      TRUE
        SKIP
:
--}}}
--{{{  PROC pony.startup.unh.ueh.iep.mh
-- Start the pony kernel
-- Returns: unshared network-handle
--          unshared error-handle
--          initial error-point
--          message-handle
-- Parameters: msg.type    | VAL: message-type
--                           `PONYC.MSGTYPE.STATUS'    | status messages
--                           `PONYC.MSGTYPE.ERR'       | error messages
--                           `PONYC.MSGTYPE.STATUSERR' | both
--             net.type    | VAL: network-type
--                           `PONYC.NETTYPE.TCPIP' | TCP/IP
--             ans.name    | VAL: name of the ANS
--             app.name    | VAL: name of the application
--             node.name   | VAL: name of the node
--             node.type   | VAL: node-type
--                           `PONYC.NODETYPE.MASTER'      | master
--                           `PONYC.NODETYPE.MASTERRESET' | master/reset
--                           `PONYC.NODETYPE.SLAVE'       | slave
--                           `PONYC.NODETYPE.SLAVEWAIT'   | slave/wait
--             own.node.id | RESULT: own node-ID
--             net.handle  | RESULT: network-handle
--             err.handle  | RESULT: error-handle
--             err.point   | RESULT: initial error-point
--             msg.handle  | RESULT: message-handle
--             result      | RESULT: result
PROC pony.startup.unh.ueh.iep.mh (VAL INT msg.type, net.type,
                                  VAL []BYTE ans.name, app.name, node.name,
                                  VAL INT node.type,
                                  RESULT INT own.node.id,
                                  RESULT PONY.NETHANDLE! net.handle,
                                  RESULT PONY.ERRHANDLE! err.handle,
                                  RESULT INT err.point,
                                  RESULT PONY.MSGHANDLE! msg.handle,
                                  RESULT INT result)
  --{{{  Internal handles
  SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle:
  PONY.INT.CTBMGRHANDLE? ctb.mgr.handle.svr:
  SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle:
  PONY.INT.NCTMGRHANDLE? nct.mgr.handle.svr:
  SHARED PONY.INT.KERNELREPLYHANDLE! kernel.reply.handle:
  PONY.INT.KERNELREPLYHANDLE? kernel.reply.handle.svr:
  SHARED PONY.INT.ERRHANDLE! int.err.handle:
  PONY.INT.ERRHANDLE? int.err.handle.svr:
  SHARED PONY.INT.MSGHANDLE! int.msg.handle:
  PONY.INT.MSGHANDLE? int.msg.handle.svr:
  SHARED PONY.INT.LINKMGRHANDLE! link.mgr.handle:
  --}}}
  SEQ
    CASE msg.type
      PONYC.MSGTYPE.STATUS, PONYC.MSGTYPE.ERR, PONYC.MSGTYPE.STATUSERR
        SEQ
          --{{{  Allocate internal handles
          ctb.mgr.handle, ctb.mgr.handle.svr := MOBILE PONY.INT.CTBMGRHANDLE
          nct.mgr.handle, nct.mgr.handle.svr := MOBILE PONY.INT.NCTMGRHANDLE
          kernel.reply.handle, kernel.reply.handle.svr := MOBILE PONY.INT.KERNELREPLYHANDLE
          int.err.handle, int.err.handle.svr := MOBILE PONY.INT.ERRHANDLE
          int.msg.handle, int.msg.handle.svr := MOBILE PONY.INT.MSGHANDLE
          --}}}
          -- Start link-manager
          pony.int.startup.linkmgr (net.type, ans.name, app.name,
                                    node.name, node.type,
                                    ctb.mgr.handle, nct.mgr.handle,
                                    kernel.reply.handle,
                                    TRUE, int.err.handle,
                                    msg.type, int.msg.handle,
                                    own.node.id, link.mgr.handle, result)
      ELSE
        result := PONYC.RESULT.STARTUP.ILLEGALMSGTYPE
    IF
      --{{{  Link-manager started successfully
      result = PONYC.RESULT.STARTUP.OK
        PONY.NETHANDLE? net.handle.svr:
        PONY.ERRHANDLE? err.handle.svr:
        PONY.MSGHANDLE? msg.handle.svr:
        SEQ
          -- Initialise parameters and return values
          net.handle, net.handle.svr := MOBILE PONY.NETHANDLE
          err.handle, err.handle.svr := MOBILE PONY.ERRHANDLE
          err.point := PONYC.INT.INITIALERRPOINT
          msg.handle, msg.handle.svr := MOBILE PONY.MSGHANDLE
          -- Fork off main kernel
          FORK pony.int.main.kernel (own.node.id, net.handle.svr,
                                     link.mgr.handle,
                                     ctb.mgr.handle, ctb.mgr.handle.svr,
                                     nct.mgr.handle, nct.mgr.handle.svr,
                                     kernel.reply.handle, kernel.reply.handle.svr,
                                     TRUE, TRUE, err.handle.svr,
                                     int.err.handle, int.err.handle.svr,
                                     msg.type, msg.handle.svr,
                                     int.msg.handle, int.msg.handle.svr)
      --}}}
      TRUE
        SKIP
:
--}}}
--{{{  PROC pony.startup.unh.seh.mh
-- Start the pony kernel
-- Returns: unshared network-handle
--          shared error-handle
--          message-handle
-- Parameters: msg.type    | VAL: message-type
--                           `PONYC.MSGTYPE.STATUS'    | status messages
--                           `PONYC.MSGTYPE.ERR'       | error messages
--                           `PONYC.MSGTYPE.STATUSERR' | both
--             net.type    | VAL: network-type
--                           `PONYC.NETTYPE.TCPIP' | TCP/IP
--             ans.name    | VAL: name of the ANS
--             app.name    | VAL: name of the application
--             node.name   | VAL: name of the node
--             node.type   | VAL: node-type
--                           `PONYC.NODETYPE.MASTER'      | master
--                           `PONYC.NODETYPE.MASTERRESET' | master/reset
--                           `PONYC.NODETYPE.SLAVE'       | slave
--                           `PONYC.NODETYPE.SLAVEWAIT'   | slave/wait
--             own.node.id | RESULT: own node-ID
--             net.handle  | RESULT: network-handle
--             err.handle  | RESULT: error-handle (shared)
--             msg.handle  | RESULT: message-handle
--             result      | RESULT: result
PROC pony.startup.unh.seh.mh (VAL INT msg.type, net.type,
                              VAL []BYTE ans.name, app.name, node.name,
                              VAL INT node.type,
                              RESULT INT own.node.id,
                              RESULT PONY.NETHANDLE! net.handle,
                              RESULT SHARED PONY.ERRHANDLE! err.handle,
                              RESULT PONY.MSGHANDLE! msg.handle,
                              RESULT INT result)
  --{{{  Internal handles
  SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle:
  PONY.INT.CTBMGRHANDLE? ctb.mgr.handle.svr:
  SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle:
  PONY.INT.NCTMGRHANDLE? nct.mgr.handle.svr:
  SHARED PONY.INT.KERNELREPLYHANDLE! kernel.reply.handle:
  PONY.INT.KERNELREPLYHANDLE? kernel.reply.handle.svr:
  SHARED PONY.INT.ERRHANDLE! int.err.handle:
  PONY.INT.ERRHANDLE? int.err.handle.svr:
  SHARED PONY.INT.MSGHANDLE! int.msg.handle:
  PONY.INT.MSGHANDLE? int.msg.handle.svr:
  SHARED PONY.INT.LINKMGRHANDLE! link.mgr.handle:
  --}}}
  SEQ
    CASE msg.type
      PONYC.MSGTYPE.STATUS, PONYC.MSGTYPE.ERR, PONYC.MSGTYPE.STATUSERR
        SEQ
          --{{{  Allocate internal handles
          ctb.mgr.handle, ctb.mgr.handle.svr := MOBILE PONY.INT.CTBMGRHANDLE
          nct.mgr.handle, nct.mgr.handle.svr := MOBILE PONY.INT.NCTMGRHANDLE
          kernel.reply.handle, kernel.reply.handle.svr := MOBILE PONY.INT.KERNELREPLYHANDLE
          int.err.handle, int.err.handle.svr := MOBILE PONY.INT.ERRHANDLE
          int.msg.handle, int.msg.handle.svr := MOBILE PONY.INT.MSGHANDLE
          --}}}
          -- Start link-manager
          pony.int.startup.linkmgr (net.type, ans.name, app.name,
                                    node.name, node.type,
                                    ctb.mgr.handle, nct.mgr.handle,
                                    kernel.reply.handle,
                                    TRUE, int.err.handle,
                                    msg.type, int.msg.handle,
                                    own.node.id, link.mgr.handle, result)
      ELSE
        result := PONYC.RESULT.STARTUP.ILLEGALMSGTYPE
    IF
      --{{{  Link-manager started successfully
      result = PONYC.RESULT.STARTUP.OK
        PONY.NETHANDLE? net.handle.svr:
        PONY.ERRHANDLE? err.handle.svr:
        PONY.MSGHANDLE? msg.handle.svr:
        SEQ
          -- Initialise parameters and return values
          net.handle, net.handle.svr := MOBILE PONY.NETHANDLE
          err.handle, err.handle.svr := MOBILE PONY.ERRHANDLE
          msg.handle, msg.handle.svr := MOBILE PONY.MSGHANDLE
          -- Fork off main kernel
          FORK pony.int.main.kernel (own.node.id, net.handle.svr,
                                     link.mgr.handle,
                                     ctb.mgr.handle, ctb.mgr.handle.svr,
                                     nct.mgr.handle, nct.mgr.handle.svr,
                                     kernel.reply.handle, kernel.reply.handle.svr,
                                     TRUE, FALSE, err.handle.svr,
                                     int.err.handle, int.err.handle.svr,
                                     msg.type, msg.handle.svr,
                                     int.msg.handle, int.msg.handle.svr)
      --}}}
      TRUE
        SKIP
:
--}}}
--{{{  PROC pony.startup.unh.seh.iep.mh
-- Start the pony kernel
-- Returns: unshared network-handle
--          shared error-handle
--          initial error-point
--          message-handle
-- Parameters: msg.type    | VAL: message-type
--                           `PONYC.MSGTYPE.STATUS'    | status messages
--                           `PONYC.MSGTYPE.ERR'       | error messages
--                           `PONYC.MSGTYPE.STATUSERR' | both
--             net.type    | VAL: network-type
--                           `PONYC.NETTYPE.TCPIP' | TCP/IP
--             ans.name    | VAL: name of the ANS
--             app.name    | VAL: name of the application
--             node.name   | VAL: name of the node
--             node.type   | VAL: node-type
--                           `PONYC.NODETYPE.MASTER'      | master
--                           `PONYC.NODETYPE.MASTERRESET' | master/reset
--                           `PONYC.NODETYPE.SLAVE'       | slave
--                           `PONYC.NODETYPE.SLAVEWAIT'   | slave/wait
--             own.node.id | RESULT: own node-ID
--             net.handle  | RESULT: network-handle
--             err.handle  | RESULT: error-handle (shared)
--             err.point   | RESULT: initial error-point
--             msg.handle  | RESULT: message-handle
--             result      | RESULT: result
PROC pony.startup.unh.seh.iep.mh (VAL INT msg.type, net.type,
                                  VAL []BYTE ans.name, app.name, node.name,
                                  VAL INT node.type,
                                  RESULT INT own.node.id,
                                  RESULT PONY.NETHANDLE! net.handle,
                                  RESULT SHARED PONY.ERRHANDLE! err.handle,
                                  RESULT INT err.point,
                                  RESULT PONY.MSGHANDLE! msg.handle,
                                  RESULT INT result)
  --{{{  Internal handles
  SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle:
  PONY.INT.CTBMGRHANDLE? ctb.mgr.handle.svr:
  SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle:
  PONY.INT.NCTMGRHANDLE? nct.mgr.handle.svr:
  SHARED PONY.INT.KERNELREPLYHANDLE! kernel.reply.handle:
  PONY.INT.KERNELREPLYHANDLE? kernel.reply.handle.svr:
  SHARED PONY.INT.ERRHANDLE! int.err.handle:
  PONY.INT.ERRHANDLE? int.err.handle.svr:
  SHARED PONY.INT.MSGHANDLE! int.msg.handle:
  PONY.INT.MSGHANDLE? int.msg.handle.svr:
  SHARED PONY.INT.LINKMGRHANDLE! link.mgr.handle:
  --}}}
  SEQ
    CASE msg.type
      PONYC.MSGTYPE.STATUS, PONYC.MSGTYPE.ERR, PONYC.MSGTYPE.STATUSERR
        SEQ
          --{{{  Allocate internal handles
          ctb.mgr.handle, ctb.mgr.handle.svr := MOBILE PONY.INT.CTBMGRHANDLE
          nct.mgr.handle, nct.mgr.handle.svr := MOBILE PONY.INT.NCTMGRHANDLE
          kernel.reply.handle, kernel.reply.handle.svr := MOBILE PONY.INT.KERNELREPLYHANDLE
          int.err.handle, int.err.handle.svr := MOBILE PONY.INT.ERRHANDLE
          int.msg.handle, int.msg.handle.svr := MOBILE PONY.INT.MSGHANDLE
          --}}}
          -- Start link-manager
          pony.int.startup.linkmgr (net.type, ans.name, app.name,
                                    node.name, node.type,
                                    ctb.mgr.handle, nct.mgr.handle,
                                    kernel.reply.handle,
                                    TRUE, int.err.handle,
                                    msg.type, int.msg.handle,
                                    own.node.id, link.mgr.handle, result)
      ELSE
        result := PONYC.RESULT.STARTUP.ILLEGALMSGTYPE
    IF
      --{{{  Link-manager started successfully
      result = PONYC.RESULT.STARTUP.OK
        PONY.NETHANDLE? net.handle.svr:
        PONY.ERRHANDLE? err.handle.svr:
        PONY.MSGHANDLE? msg.handle.svr:
        SEQ
          -- Initialise parameters and return values
          net.handle, net.handle.svr := MOBILE PONY.NETHANDLE
          err.handle, err.handle.svr := MOBILE PONY.ERRHANDLE
          err.point := PONYC.INT.INITIALERRPOINT
          msg.handle, msg.handle.svr := MOBILE PONY.MSGHANDLE
          -- Fork off main kernel
          FORK pony.int.main.kernel (own.node.id, net.handle.svr,
                                     link.mgr.handle,
                                     ctb.mgr.handle, ctb.mgr.handle.svr,
                                     nct.mgr.handle, nct.mgr.handle.svr,
                                     kernel.reply.handle, kernel.reply.handle.svr,
                                     TRUE, TRUE, err.handle.svr,
                                     int.err.handle, int.err.handle.svr,
                                     msg.type, msg.handle.svr,
                                     int.msg.handle, int.msg.handle.svr)
      --}}}
      TRUE
        SKIP
:
--}}}
--{{{  PROC pony.startup.snh.ueh.mh
-- Start the pony kernel
-- Returns: shared network-handle
--          unshared error-handle
--          message-handle
-- Parameters: msg.type    | VAL: message-type
--                           `PONYC.MSGTYPE.STATUS'    | status messages
--                           `PONYC.MSGTYPE.ERR'       | error messages
--                           `PONYC.MSGTYPE.STATUSERR' | both
--             net.type    | VAL: network-type
--                           `PONYC.NETTYPE.TCPIP' | TCP/IP
--             ans.name    | VAL: name of the ANS
--             app.name    | VAL: name of the application
--             node.name   | VAL: name of the node
--             node.type   | VAL: node-type
--                           `PONYC.NODETYPE.MASTER'      | master
--                           `PONYC.NODETYPE.MASTERRESET' | master/reset
--                           `PONYC.NODETYPE.SLAVE'       | slave
--                           `PONYC.NODETYPE.SLAVEWAIT'   | slave/wait
--             own.node.id | RESULT: own node-ID
--             net.handle  | RESULT: network-handle (shared)
--             err.handle  | RESULT: error-handle
--             msg.handle  | RESULT: message-handle
--             result      | RESULT: result
PROC pony.startup.snh.ueh.mh (VAL INT msg.type, net.type,
                              VAL []BYTE ans.name, app.name, node.name,
                              VAL INT node.type,
                              RESULT INT own.node.id,
                              RESULT SHARED PONY.NETHANDLE! net.handle,
                              RESULT PONY.ERRHANDLE! err.handle,
                              RESULT PONY.MSGHANDLE! msg.handle,
                              RESULT INT result)
  --{{{  Internal handles
  SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle:
  PONY.INT.CTBMGRHANDLE? ctb.mgr.handle.svr:
  SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle:
  PONY.INT.NCTMGRHANDLE? nct.mgr.handle.svr:
  SHARED PONY.INT.KERNELREPLYHANDLE! kernel.reply.handle:
  PONY.INT.KERNELREPLYHANDLE? kernel.reply.handle.svr:
  SHARED PONY.INT.ERRHANDLE! int.err.handle:
  PONY.INT.ERRHANDLE? int.err.handle.svr:
  SHARED PONY.INT.MSGHANDLE! int.msg.handle:
  PONY.INT.MSGHANDLE? int.msg.handle.svr:
  SHARED PONY.INT.LINKMGRHANDLE! link.mgr.handle:
  --}}}
  SEQ
    CASE msg.type
      PONYC.MSGTYPE.STATUS, PONYC.MSGTYPE.ERR, PONYC.MSGTYPE.STATUSERR
        SEQ
          --{{{  Allocate internal handles
          ctb.mgr.handle, ctb.mgr.handle.svr := MOBILE PONY.INT.CTBMGRHANDLE
          nct.mgr.handle, nct.mgr.handle.svr := MOBILE PONY.INT.NCTMGRHANDLE
          kernel.reply.handle, kernel.reply.handle.svr := MOBILE PONY.INT.KERNELREPLYHANDLE
          int.err.handle, int.err.handle.svr := MOBILE PONY.INT.ERRHANDLE
          int.msg.handle, int.msg.handle.svr := MOBILE PONY.INT.MSGHANDLE
          --}}}
          -- Start link-manager
          pony.int.startup.linkmgr (net.type, ans.name, app.name,
                                    node.name, node.type,
                                    ctb.mgr.handle, nct.mgr.handle,
                                    kernel.reply.handle,
                                    TRUE, int.err.handle,
                                    msg.type, int.msg.handle,
                                    own.node.id, link.mgr.handle, result)
      ELSE
        result := PONYC.RESULT.STARTUP.ILLEGALMSGTYPE
    IF
      --{{{  Link-manager started successfully
      result = PONYC.RESULT.STARTUP.OK
        PONY.NETHANDLE? net.handle.svr:
        PONY.ERRHANDLE? err.handle.svr:
        PONY.MSGHANDLE? msg.handle.svr:
        SEQ
          -- Initialise parameters and return values
          net.handle, net.handle.svr := MOBILE PONY.NETHANDLE
          err.handle, err.handle.svr := MOBILE PONY.ERRHANDLE
          msg.handle, msg.handle.svr := MOBILE PONY.MSGHANDLE
          -- Fork off main kernel
          FORK pony.int.main.kernel (own.node.id, net.handle.svr,
                                     link.mgr.handle,
                                     ctb.mgr.handle, ctb.mgr.handle.svr,
                                     nct.mgr.handle, nct.mgr.handle.svr,
                                     kernel.reply.handle, kernel.reply.handle.svr,
                                     TRUE, FALSE, err.handle.svr,
                                     int.err.handle, int.err.handle.svr,
                                     msg.type, msg.handle.svr,
                                     int.msg.handle, int.msg.handle.svr)
      --}}}
      TRUE
        SKIP
:
--}}}
--{{{  PROC pony.startup.snh.ueh.iep.mh
-- Start the pony kernel
-- Returns: shared network-handle
--          unshared error-handle
--          initial error-point
--          message-handle
-- Parameters: msg.type    | VAL: message-type
--                           `PONYC.MSGTYPE.STATUS'    | status messages
--                           `PONYC.MSGTYPE.ERR'       | error messages
--                           `PONYC.MSGTYPE.STATUSERR' | both
--             net.type    | VAL: network-type
--                           `PONYC.NETTYPE.TCPIP' | TCP/IP
--             ans.name    | VAL: name of the ANS
--             app.name    | VAL: name of the application
--             node.name   | VAL: name of the node
--             node.type   | VAL: node-type
--                           `PONYC.NODETYPE.MASTER'      | master
--                           `PONYC.NODETYPE.MASTERRESET' | master/reset
--                           `PONYC.NODETYPE.SLAVE'       | slave
--                           `PONYC.NODETYPE.SLAVEWAIT'   | slave/wait
--             own.node.id | RESULT: own node-ID
--             net.handle  | RESULT: network-handle (shared)
--             err.handle  | RESULT: error-handle
--             err.point   | RESULT: initial error-point
--             msg.handle  | RESULT: message-handle
--             result      | RESULT: result
PROC pony.startup.snh.ueh.iep.mh (VAL INT msg.type, net.type,
                                  VAL []BYTE ans.name, app.name, node.name,
                                  VAL INT node.type,
                                  RESULT INT own.node.id,
                                  RESULT SHARED PONY.NETHANDLE! net.handle,
                                  RESULT PONY.ERRHANDLE! err.handle,
                                  RESULT INT err.point,
                                  RESULT PONY.MSGHANDLE! msg.handle,
                                  RESULT INT result)
  --{{{  Internal handles
  SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle:
  PONY.INT.CTBMGRHANDLE? ctb.mgr.handle.svr:
  SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle:
  PONY.INT.NCTMGRHANDLE? nct.mgr.handle.svr:
  SHARED PONY.INT.KERNELREPLYHANDLE! kernel.reply.handle:
  PONY.INT.KERNELREPLYHANDLE? kernel.reply.handle.svr:
  SHARED PONY.INT.ERRHANDLE! int.err.handle:
  PONY.INT.ERRHANDLE? int.err.handle.svr:
  SHARED PONY.INT.MSGHANDLE! int.msg.handle:
  PONY.INT.MSGHANDLE? int.msg.handle.svr:
  SHARED PONY.INT.LINKMGRHANDLE! link.mgr.handle:
  --}}}
  SEQ
    CASE msg.type
      PONYC.MSGTYPE.STATUS, PONYC.MSGTYPE.ERR, PONYC.MSGTYPE.STATUSERR
        SEQ
          --{{{  Allocate internal handles
          ctb.mgr.handle, ctb.mgr.handle.svr := MOBILE PONY.INT.CTBMGRHANDLE
          nct.mgr.handle, nct.mgr.handle.svr := MOBILE PONY.INT.NCTMGRHANDLE
          kernel.reply.handle, kernel.reply.handle.svr := MOBILE PONY.INT.KERNELREPLYHANDLE
          int.err.handle, int.err.handle.svr := MOBILE PONY.INT.ERRHANDLE
          int.msg.handle, int.msg.handle.svr := MOBILE PONY.INT.MSGHANDLE
          --}}}
          -- Start link-manager
          pony.int.startup.linkmgr (net.type, ans.name, app.name,
                                    node.name, node.type,
                                    ctb.mgr.handle, nct.mgr.handle,
                                    kernel.reply.handle,
                                    TRUE, int.err.handle,
                                    msg.type, int.msg.handle,
                                    own.node.id, link.mgr.handle, result)
      ELSE
        result := PONYC.RESULT.STARTUP.ILLEGALMSGTYPE
    IF
      --{{{  Link-manager started successfully
      result = PONYC.RESULT.STARTUP.OK
        PONY.NETHANDLE? net.handle.svr:
        PONY.ERRHANDLE? err.handle.svr:
        PONY.MSGHANDLE? msg.handle.svr:
        SEQ
          -- Initialise parameters and return values
          net.handle, net.handle.svr := MOBILE PONY.NETHANDLE
          err.handle, err.handle.svr := MOBILE PONY.ERRHANDLE
          err.point := PONYC.INT.INITIALERRPOINT
          msg.handle, msg.handle.svr := MOBILE PONY.MSGHANDLE
          -- Fork off main kernel
          FORK pony.int.main.kernel (own.node.id, net.handle.svr,
                                     link.mgr.handle,
                                     ctb.mgr.handle, ctb.mgr.handle.svr,
                                     nct.mgr.handle, nct.mgr.handle.svr,
                                     kernel.reply.handle, kernel.reply.handle.svr,
                                     TRUE, TRUE, err.handle.svr,
                                     int.err.handle, int.err.handle.svr,
                                     msg.type, msg.handle.svr,
                                     int.msg.handle, int.msg.handle.svr)
      --}}}
      TRUE
        SKIP
:
--}}}
--{{{  PROC pony.startup.snh.seh.mh
-- Start the pony kernel
-- Returns: shared network-handle
--          shared error-handle
--          message-handle
-- Parameters: msg.type    | VAL: message-type
--                           `PONYC.MSGTYPE.STATUS'    | status messages
--                           `PONYC.MSGTYPE.ERR'       | error messages
--                           `PONYC.MSGTYPE.STATUSERR' | both
--             net.type    | VAL: network-type
--                           `PONYC.NETTYPE.TCPIP' | TCP/IP
--             ans.name    | VAL: name of the ANS
--             app.name    | VAL: name of the application
--             node.name   | VAL: name of the node
--             node.type   | VAL: node-type
--                           `PONYC.NODETYPE.MASTER'      | master
--                           `PONYC.NODETYPE.MASTERRESET' | master/reset
--                           `PONYC.NODETYPE.SLAVE'       | slave
--                           `PONYC.NODETYPE.SLAVEWAIT'   | slave/wait
--             own.node.id | RESULT: own node-ID
--             net.handle  | RESULT: network-handle (shared)
--             err.handle  | RESULT: error-handle (shared)
--             msg.handle  | RESULT: message-handle
--             result      | RESULT: result
PROC pony.startup.snh.seh.mh (VAL INT msg.type, net.type,
                              VAL []BYTE ans.name, app.name, node.name,
                              VAL INT node.type,
                              RESULT INT own.node.id,
                              RESULT SHARED PONY.NETHANDLE! net.handle,
                              RESULT SHARED PONY.ERRHANDLE! err.handle,
                              RESULT PONY.MSGHANDLE! msg.handle,
                              RESULT INT result)
  --{{{  Internal handles
  SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle:
  PONY.INT.CTBMGRHANDLE? ctb.mgr.handle.svr:
  SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle:
  PONY.INT.NCTMGRHANDLE? nct.mgr.handle.svr:
  SHARED PONY.INT.KERNELREPLYHANDLE! kernel.reply.handle:
  PONY.INT.KERNELREPLYHANDLE? kernel.reply.handle.svr:
  SHARED PONY.INT.ERRHANDLE! int.err.handle:
  PONY.INT.ERRHANDLE? int.err.handle.svr:
  SHARED PONY.INT.MSGHANDLE! int.msg.handle:
  PONY.INT.MSGHANDLE? int.msg.handle.svr:
  SHARED PONY.INT.LINKMGRHANDLE! link.mgr.handle:
  --}}}
  SEQ
    CASE msg.type
      PONYC.MSGTYPE.STATUS, PONYC.MSGTYPE.ERR, PONYC.MSGTYPE.STATUSERR
        SEQ
          --{{{  Allocate internal handles
          ctb.mgr.handle, ctb.mgr.handle.svr := MOBILE PONY.INT.CTBMGRHANDLE
          nct.mgr.handle, nct.mgr.handle.svr := MOBILE PONY.INT.NCTMGRHANDLE
          kernel.reply.handle, kernel.reply.handle.svr := MOBILE PONY.INT.KERNELREPLYHANDLE
          int.err.handle, int.err.handle.svr := MOBILE PONY.INT.ERRHANDLE
          int.msg.handle, int.msg.handle.svr := MOBILE PONY.INT.MSGHANDLE
          --}}}
          -- Start link-manager
          pony.int.startup.linkmgr (net.type, ans.name, app.name,
                                    node.name, node.type,
                                    ctb.mgr.handle, nct.mgr.handle,
                                    kernel.reply.handle,
                                    TRUE, int.err.handle,
                                    msg.type, int.msg.handle,
                                    own.node.id, link.mgr.handle, result)
      ELSE
        result := PONYC.RESULT.STARTUP.ILLEGALMSGTYPE
    IF
      --{{{  Link-manager started successfully
      result = PONYC.RESULT.STARTUP.OK
        PONY.NETHANDLE? net.handle.svr:
        PONY.ERRHANDLE? err.handle.svr:
        PONY.MSGHANDLE? msg.handle.svr:
        SEQ
          -- Initialise parameters and return values
          net.handle, net.handle.svr := MOBILE PONY.NETHANDLE
          err.handle, err.handle.svr := MOBILE PONY.ERRHANDLE
          msg.handle, msg.handle.svr := MOBILE PONY.MSGHANDLE
          -- Fork off main kernel
          FORK pony.int.main.kernel (own.node.id, net.handle.svr,
                                     link.mgr.handle,
                                     ctb.mgr.handle, ctb.mgr.handle.svr,
                                     nct.mgr.handle, nct.mgr.handle.svr,
                                     kernel.reply.handle, kernel.reply.handle.svr,
                                     TRUE, FALSE, err.handle.svr,
                                     int.err.handle, int.err.handle.svr,
                                     msg.type, msg.handle.svr,
                                     int.msg.handle, int.msg.handle.svr)
      --}}}
      TRUE
        SKIP
:
--}}}
--{{{  PROC pony.startup.snh.seh.iep.mh
-- Start the pony kernel
-- Returns: shared network-handle
--          shared error-handle
--          initial error-point
--          message-handle
-- Parameters: msg.type    | VAL: message-type
--                           `PONYC.MSGTYPE.STATUS'    | status messages
--                           `PONYC.MSGTYPE.ERR'       | error messages
--                           `PONYC.MSGTYPE.STATUSERR' | both
--             net.type    | VAL: network-type
--                           `PONYC.NETTYPE.TCPIP' | TCP/IP
--             ans.name    | VAL: name of the ANS
--             app.name    | VAL: name of the application
--             node.name   | VAL: name of the node
--             node.type   | VAL: node-type
--                           `PONYC.NODETYPE.MASTER'      | master
--                           `PONYC.NODETYPE.MASTERRESET' | master/reset
--                           `PONYC.NODETYPE.SLAVE'       | slave
--                           `PONYC.NODETYPE.SLAVEWAIT'   | slave/wait
--             own.node.id | RESULT: own node-ID
--             net.handle  | RESULT: network-handle (shared)
--             err.handle  | RESULT: error-handle (shared)
--             err.point   | RESULT: initial error-point
--             msg.handle  | RESULT: message-handle
--             result      | RESULT: result
PROC pony.startup.snh.seh.iep.mh (VAL INT msg.type, net.type,
                                  VAL []BYTE ans.name, app.name, node.name,
                                  VAL INT node.type,
                                  RESULT INT own.node.id,
                                  RESULT SHARED PONY.NETHANDLE! net.handle,
                                  RESULT SHARED PONY.ERRHANDLE! err.handle,
                                  RESULT INT err.point,
                                  RESULT PONY.MSGHANDLE! msg.handle,
                                  RESULT INT result)
  --{{{  Internal handles
  SHARED PONY.INT.CTBMGRHANDLE! ctb.mgr.handle:
  PONY.INT.CTBMGRHANDLE? ctb.mgr.handle.svr:
  SHARED PONY.INT.NCTMGRHANDLE! nct.mgr.handle:
  PONY.INT.NCTMGRHANDLE? nct.mgr.handle.svr:
  SHARED PONY.INT.KERNELREPLYHANDLE! kernel.reply.handle:
  PONY.INT.KERNELREPLYHANDLE? kernel.reply.handle.svr:
  SHARED PONY.INT.ERRHANDLE! int.err.handle:
  PONY.INT.ERRHANDLE? int.err.handle.svr:
  SHARED PONY.INT.MSGHANDLE! int.msg.handle:
  PONY.INT.MSGHANDLE? int.msg.handle.svr:
  SHARED PONY.INT.LINKMGRHANDLE! link.mgr.handle:
  --}}}
  SEQ
    CASE msg.type
      PONYC.MSGTYPE.STATUS, PONYC.MSGTYPE.ERR, PONYC.MSGTYPE.STATUSERR
        SEQ
          --{{{  Allocate internal handles
          ctb.mgr.handle, ctb.mgr.handle.svr := MOBILE PONY.INT.CTBMGRHANDLE
          nct.mgr.handle, nct.mgr.handle.svr := MOBILE PONY.INT.NCTMGRHANDLE
          kernel.reply.handle, kernel.reply.handle.svr := MOBILE PONY.INT.KERNELREPLYHANDLE
          int.err.handle, int.err.handle.svr := MOBILE PONY.INT.ERRHANDLE
          int.msg.handle, int.msg.handle.svr := MOBILE PONY.INT.MSGHANDLE
          --}}}
          -- Start link-manager
          pony.int.startup.linkmgr (net.type, ans.name, app.name,
                                    node.name, node.type,
                                    ctb.mgr.handle, nct.mgr.handle,
                                    kernel.reply.handle,
                                    TRUE, int.err.handle,
                                    msg.type, int.msg.handle,
                                    own.node.id, link.mgr.handle, result)
      ELSE
        result := PONYC.RESULT.STARTUP.ILLEGALMSGTYPE
    IF
      --{{{  Link-manager started successfully
      result = PONYC.RESULT.STARTUP.OK
        PONY.NETHANDLE? net.handle.svr:
        PONY.ERRHANDLE? err.handle.svr:
        PONY.MSGHANDLE? msg.handle.svr:
        SEQ
          -- Initialise parameters and return values
          net.handle, net.handle.svr := MOBILE PONY.NETHANDLE
          err.handle, err.handle.svr := MOBILE PONY.ERRHANDLE
          err.point := PONYC.INT.INITIALERRPOINT
          msg.handle, msg.handle.svr := MOBILE PONY.MSGHANDLE
          -- Fork off main kernel
          FORK pony.int.main.kernel (own.node.id, net.handle.svr,
                                     link.mgr.handle,
                                     ctb.mgr.handle, ctb.mgr.handle.svr,
                                     nct.mgr.handle, nct.mgr.handle.svr,
                                     kernel.reply.handle, kernel.reply.handle.svr,
                                     TRUE, TRUE, err.handle.svr,
                                     int.err.handle, int.err.handle.svr,
                                     msg.type, msg.handle.svr,
                                     int.msg.handle, int.msg.handle.svr)
      --}}}
      TRUE
        SKIP
:
--}}}

--}}}
--{{{  PROCs pony.alloc.*

--{{{  PROC pony.alloc.uc
-- Allocate an unshared client-end of an NCT
-- Parameters: net.handle | network-handle (client-end)
--             nct.name   | VAL: name of the NCT
--             svr.type   | VAL: share-type of the NCT's server-end
--                          `PONYC.SHARETYPE.UNKNOWN'  | unknown or not specified
--                          `PONYC.SHARETYPE.UNSHARED' | server-end unshared
--                          `PONYC.SHARETYPE.SHARED'   | server-end shared
--             cli        | RESULT: client-end variable to be allocated
--             result     | RESULT: result
PROC pony.alloc.uc (PONY.NETHANDLE! net.handle,
                    VAL []BYTE nct.name, VAL INT svr.type,
                    RESULT MOBILE.CHAN! cli, RESULT INT result)
  IF
    (SIZE nct.name) = 0
      result := PONYC.RESULT.ALLOC.ILLEGALNCTNAME
    TRUE
      INT num.chans, num.readers.in.svr, type.hash:
      SEQ
        -- Get type-descriptor data
        C.pony.int.get.tdesc.data.uc (cli, num.chans, num.readers.in.svr, type.hash)
        --{{{  Request explicit allocation
        -- Carrying: client-end to be allocated;
        --           client-end unshared;
        --           share-type of server-end;
        --           number of channel-words;
        --           number of reading-ends in server-end;
        --           type-hash of the NCT to be allocated;
        --           name of the NCT
        net.handle[to.kernel] ! alloc; PONYC.INT.DIRTYPE.CLI; PONYC.SHARETYPE.UNSHARED; svr.type;
                                       num.chans; num.readers.in.svr; type.hash; nct.name
        --}}}
        -- `result' is OK unless we get an `error' reply
        result := PONYC.RESULT.ALLOC.OK
        --{{{  Get reply from pony kernel
        net.handle[from.kernel] ? CASE
          --{{{  Error
          -- Carrying: result
          alloc.error; result
            -- Return error, nothing else to do
            SKIP
          --}}}
          --{{{  pony kernel wants reference-count of existing CTB increased
          INT ctb.ptr:
          -- Carrying: CTB-pointer
          increase.ref.count; ctb.ptr
            -- Increase reference-count and assign `cli'
            C.pony.int.increase.ref.count.uc (cli, ctb.ptr)
          --}}}
          --{{{  pony kernel wants new CTB allocated
          INT nct.id:
          PONY.NETHOOKHANDLE! net.hook.handle:
          MOBILE []PONY.DECODEHANDLE! dec.handle.array:
          MOBILE []PONY.ENCODEHANDLE! enc.handle.array:
          -- Carrying: NCT-ID;
          --           network-hook-handle;
          --           array of decode-handles;
          --           array of encode-handles
          alloc.new.ctb; nct.id; net.hook.handle; dec.handle.array; enc.handle.array
            INT paddr, ctb.ptr:
            SEQ
              -- Allocate new CTB for `cli'
              C.pony.int.alloc.ctb.uc (paddr, cli, nct.id, net.hook.handle,
                                       dec.handle.array, enc.handle.array,
                                       ctb.ptr)
              cifccsp.startprocess (paddr)
              C.pony.cleancifprocess (paddr)
              -- Return new CTB-pointer to pony kernel
              -- Carrying: CTB-pointer
              net.handle[to.kernel] ! alloc.new.ctb.confirm; ctb.ptr
          --}}}
        --}}}
:
--}}}
--{{{  PROC pony.alloc.sc
-- Allocate a shared client-end of an NCT
-- Parameters: net.handle | network-handle (client-end)
--             nct.name   | VAL: name of the NCT
--             svr.type   | VAL: share-type of the NCT's server-end
--                          `PONYC.SHARETYPE.UNKNOWN'  | unknown or not specified
--                          `PONYC.SHARETYPE.UNSHARED' | server-end unshared
--                          `PONYC.SHARETYPE.SHARED'   | server-end shared
--             cli        | RESULT: client-end variable to be allocated
--             result     | RESULT: result
PROC pony.alloc.sc (PONY.NETHANDLE! net.handle,
                    VAL []BYTE nct.name, VAL INT svr.type,
                    RESULT SHARED MOBILE.CHAN! cli, RESULT INT result)
  IF
    (SIZE nct.name) = 0
      result := PONYC.RESULT.ALLOC.ILLEGALNCTNAME
    TRUE
      INT num.chans, num.readers.in.svr, type.hash:
      SEQ
        -- Get type-descriptor data
        C.pony.int.get.tdesc.data.sc (cli, num.chans, num.readers.in.svr, type.hash)
        --{{{  Request explicit allocation
        -- Carrying: client-end to be allocated;
        --           client-end shared;
        --           share-type of server-end;
        --           number of channel-words;
        --           number of reading-ends in server-end;
        --           type-hash of the NCT to be allocated;
        --           name of the NCT
        net.handle[to.kernel] ! alloc; PONYC.INT.DIRTYPE.CLI; PONYC.SHARETYPE.SHARED; svr.type;
                                       num.chans; num.readers.in.svr; type.hash; nct.name
        --}}}
        -- `result' is OK unless we get an `error' reply
        result := PONYC.RESULT.ALLOC.OK
        --{{{  Get reply from pony kernel
        net.handle[from.kernel] ? CASE
          --{{{  Error
          -- Carrying: result
          alloc.error; result
            -- Return error, nothing else to do
            SKIP
          --}}}
          --{{{  pony kernel wants reference-count of existing CTB increased
          INT ctb.ptr:
          -- Carrying: CTB-pointer
          increase.ref.count; ctb.ptr
            -- Increase reference-count and assign `cli'
            C.pony.int.increase.ref.count.sc (cli, ctb.ptr)
          --}}}
          --{{{  pony kernel wants new CTB allocated
          INT nct.id:
          PONY.NETHOOKHANDLE! net.hook.handle:
          MOBILE []PONY.DECODEHANDLE! dec.handle.array:
          MOBILE []PONY.ENCODEHANDLE! enc.handle.array:
          -- Carrying: NCT-ID;
          --           network-hook-handle;
          --           array of decode-handles;
          --           array of encode-handles
          alloc.new.ctb; nct.id; net.hook.handle; dec.handle.array; enc.handle.array
            INT paddr, ctb.ptr:
            SEQ
              -- Allocate new CTB for `cli'
              C.pony.int.alloc.ctb.sc (paddr, cli, nct.id, net.hook.handle,
                                       dec.handle.array, enc.handle.array,
                                       ctb.ptr)
              cifccsp.startprocess (paddr)
              C.pony.cleancifprocess (paddr)
              -- Return new CTB-pointer to pony kernel
              -- Carrying: CTB-pointer
              net.handle[to.kernel] ! alloc.new.ctb.confirm; ctb.ptr
          --}}}
        --}}}
:
--}}}
--{{{  PROC pony.alloc.us
-- Allocate an unshared server-end of an NCT
-- Parameters: net.handle | network-handle (client-end)
--             nct.name   | VAL: name of the NCT
--             cli.type   | VAL: share-type of the NCT's client-end
--                          `PONYC.SHARETYPE.UNKNOWN'  | unknown or not specified
--                          `PONYC.SHARETYPE.UNSHARED' | client-end unshared
--                          `PONYC.SHARETYPE.SHARED'   | client-end shared
--             svr        | RESULT: server-end variable to be allocated
--             result     | RESULT: result
PROC pony.alloc.us (PONY.NETHANDLE! net.handle,
                    VAL []BYTE nct.name, VAL INT cli.type,
                    RESULT MOBILE.CHAN? svr, RESULT INT result)
  IF
    (SIZE nct.name) = 0
      result := PONYC.RESULT.ALLOC.ILLEGALNCTNAME
    TRUE
      INT num.chans, num.readers.in.svr, type.hash:
      SEQ
        -- Get type-descriptor data
        C.pony.int.get.tdesc.data.us (svr, num.chans, num.readers.in.svr, type.hash)
        --{{{  Request explicit allocation
        -- Carrying: server-end to be allocated;
        --           server-end unshared;
        --           share-type of client-end;
        --           number of channel-words;
        --           number of reading-ends in server-end;
        --           type-hash of the NCT to be allocated;
        --           name of the NCT
        net.handle[to.kernel] ! alloc; PONYC.INT.DIRTYPE.SVR; PONYC.SHARETYPE.UNSHARED; cli.type;
                                       num.chans; num.readers.in.svr; type.hash; nct.name
        --}}}
        -- `result' is OK unless we get an `error' reply
        result := PONYC.RESULT.ALLOC.OK
        --{{{  Get reply from pony kernel
        net.handle[from.kernel] ? CASE
          --{{{  Error
          -- Carrying: result
          alloc.error; result
            -- Return error, nothing else to do
            SKIP
          --}}}
          --{{{  pony kernel wants reference-count of existing CTB increased
          INT ctb.ptr:
          -- Carrying: CTB-pointer
          increase.ref.count; ctb.ptr
            -- Increase reference-count and assign `svr' if successful
            C.pony.int.increase.ref.count.us (svr, ctb.ptr)
          --}}}
          --{{{  pony kernel wants new CTB allocated
          INT nct.id:
          PONY.NETHOOKHANDLE! net.hook.handle:
          MOBILE []PONY.DECODEHANDLE! dec.handle.array:
          MOBILE []PONY.ENCODEHANDLE! enc.handle.array:
          -- Carrying: NCT-ID;
          --           network-hook-handle;
          --           array of decode-handles;
          --           array of encode-handles
          alloc.new.ctb; nct.id; net.hook.handle; dec.handle.array; enc.handle.array
            INT paddr, ctb.ptr:
            SEQ
              -- Allocate new CTB for `svr'
              C.pony.int.alloc.ctb.us (paddr, svr, nct.id, net.hook.handle,
                                       dec.handle.array, enc.handle.array,
                                       ctb.ptr)
              cifccsp.startprocess (paddr)
              C.pony.cleancifprocess (paddr)
              -- Return new CTB-pointer to pony kernel
              -- Carrying: CTB-pointer
              net.handle[to.kernel] ! alloc.new.ctb.confirm; ctb.ptr
          --}}}
        --}}}
:
--}}}
--{{{  PROC pony.alloc.ss
-- Allocate a shared server-end of an NCT
-- Parameters: net.handle | network-handle (client-end)
--             nct.name   | VAL: name of the NCT
--             cli.type   | VAL: share-type of the NCT's client-end
--                          `PONYC.SHARETYPE.UNKNOWN'  | unknown or not specified
--                          `PONYC.SHARETYPE.UNSHARED' | client-end unshared
--                          `PONYC.SHARETYPE.SHARED'   | client-end shared
--             svr        | RESULT: server-end variable to be allocated
--             result     | RESULT: result
PROC pony.alloc.ss (PONY.NETHANDLE! net.handle,
                    VAL []BYTE nct.name, VAL INT cli.type,
                    RESULT SHARED MOBILE.CHAN? svr, RESULT INT result)
  IF
    (SIZE nct.name) = 0
      result := PONYC.RESULT.ALLOC.ILLEGALNCTNAME
    TRUE
      INT num.chans, num.readers.in.svr, type.hash:
      SEQ
        -- Get type-descriptor data
        C.pony.int.get.tdesc.data.ss (svr, num.chans, num.readers.in.svr, type.hash)
        --{{{  Request explicit allocation
        -- Carrying: server-end to be allocated;
        --           server-end shared;
        --           share-type of client-end;
        --           number of channel-words;
        --           number of reading-ends in server-end;
        --           type-hash of the NCT to be allocated;
        --           name of the NCT
        net.handle[to.kernel] ! alloc; PONYC.INT.DIRTYPE.SVR; PONYC.SHARETYPE.SHARED; cli.type;
                                       num.chans; num.readers.in.svr; type.hash; nct.name
        --}}}
        -- `result' is OK unless we get an `error' reply
        result := PONYC.RESULT.ALLOC.OK
        --{{{  Get reply from pony kernel
        net.handle[from.kernel] ? CASE
          --{{{  Error
          -- Carrying: result
          alloc.error; result
            -- Return error, nothing else to do
            SKIP
          --}}}
          --{{{  pony kernel wants reference-count of existing CTB increased
          INT ctb.ptr:
          -- Carrying: CTB-pointer
          increase.ref.count; ctb.ptr
            -- Increase reference-count and assign `svr' if successful
            C.pony.int.increase.ref.count.ss (svr, ctb.ptr)
          --}}}
          --{{{  pony kernel wants new CTB allocated
          INT nct.id:
          PONY.NETHOOKHANDLE! net.hook.handle:
          MOBILE []PONY.DECODEHANDLE! dec.handle.array:
          MOBILE []PONY.ENCODEHANDLE! enc.handle.array:
          -- Carrying: NCT-ID;
          --           network-hook-handle;
          --           array of decode-handles;
          --           array of encode-handles
          alloc.new.ctb; nct.id; net.hook.handle; dec.handle.array; enc.handle.array
            INT paddr, ctb.ptr:
            SEQ
              -- Allocate new CTB for `svr'
              C.pony.int.alloc.ctb.ss (paddr, svr, nct.id, net.hook.handle,
                                       dec.handle.array, enc.handle.array,
                                       ctb.ptr)
              cifccsp.startprocess (paddr)
              C.pony.cleancifprocess (paddr)
              -- Return new CTB-pointer to pony kernel
              -- Carrying: CTB-pointer
              net.handle[to.kernel] ! alloc.new.ctb.confirm; ctb.ptr
          --}}}
        --}}}
:
--}}}

--}}}
--{{{  PROC pony.shutdown
-- Shut down pony kernel
-- Parameters: net.handle | network-handle (client-end)
PROC pony.shutdown (PONY.NETHANDLE! net.handle)
  MOBILE []INT ctb.ptr.array:
  SEQ
    -- Send shutdown request
    net.handle[to.kernel] ! shutdown
    -- Wait for reply
    -- Carrying: array of formerly networked CTB-pointers
    net.handle[from.kernel] ? CASE shutdown.confirm; ctb.ptr.array
    -- Shut down all formerly networked CTBs
    C.pony.int.shutdown.ctbs (ctb.ptr.array)
:
--}}}
--{{{  PROCs pony.err.*

--{{{  PROCs pony.err.get.nct.id.*

--{{{  PROC pony.err.get.nct.id.uc
-- Get NCT-ID for a given channel-type-end
-- (version for unshared client-ends)
-- Parameters: cli        | client-end variable to be checked
--             nct.id     | RESULT: NCT-ID
--             result     | RESULT: result
PROC pony.err.get.nct.id.uc (MOBILE.CHAN! cli,
                             RESULT INT nct.id, result)
  IF
    --{{{  `cli' is defined
    DEFINED cli
      INT ctb.ptr:
      SEQ
        -- Load CTB-pointer
        ASM
          LDL cli
          ST ctb.ptr
        -- Call CIF process
        C.pony.int.get.nct.id (ctb.ptr, nct.id, result)
    --}}}
    --{{{  `cli' is undefined
    TRUE
      -- Return error
      SEQ
        nct.id := -1
        result := PONYC.RESULT.ERR.GNI.CTENDUNDEFINED
    --}}}
:
--}}}
--{{{  PROC pony.err.get.nct.id.sc
-- Get NCT-ID for a given channel-type-end
-- (version for shared client-ends)
-- Parameters: cli        | client-end variable to be checked
--             nct.id     | RESULT: NCT-ID
--             result     | RESULT: result
PROC pony.err.get.nct.id.sc (SHARED MOBILE.CHAN! cli,
                             RESULT INT nct.id, result)
  IF
    --{{{  `cli' is defined
    DEFINED cli
      INT ctb.ptr:
      SEQ
        -- Load CTB-pointer
        ASM
          LDL cli
          ST ctb.ptr
        -- Call CIF process
        C.pony.int.get.nct.id (ctb.ptr, nct.id, result)
    --}}}
    --{{{  `cli' is undefined
    TRUE
      -- Return error
      SEQ
        nct.id := -1
        result := PONYC.RESULT.ERR.GNI.CTENDUNDEFINED
    --}}}
:
--}}}
--{{{  PROC pony.err.get.nct.id.us
-- Get NCT-ID for a given channel-type-end
-- (version for unshared server-ends)
-- Parameters: svr        | server-end variable to be checked
--             nct.id     | RESULT: NCT-ID
--             result     | RESULT: result
PROC pony.err.get.nct.id.us (MOBILE.CHAN? svr,
                             RESULT INT nct.id, result)
  IF
    --{{{  `svr' is defined
    DEFINED svr
      INT ctb.ptr:
      SEQ
        -- Load CTB-pointer
        ASM
          LDL svr
          ST ctb.ptr
        -- Call CIF process
        C.pony.int.get.nct.id (ctb.ptr, nct.id, result)
    --}}}
    --{{{  `svr' is undefined
    TRUE
      -- Return error
      SEQ
        nct.id := -1
        result := PONYC.RESULT.ERR.GNI.CTENDUNDEFINED
    --}}}
:
--}}}
--{{{  PROC pony.err.get.nct.id.ss
-- Get NCT-ID for a given channel-type-end
-- (version for shared server-ends)
-- Parameters: svr        | server-end variable to be checked
--             nct.id     | RESULT: NCT-ID
--             result     | RESULT: result
PROC pony.err.get.nct.id.ss (SHARED MOBILE.CHAN? svr,
                             RESULT INT nct.id, result)
  IF
    --{{{  `svr' is defined
    DEFINED svr
      INT ctb.ptr:
      SEQ
        -- Load CTB-pointer
        ASM
          LDL svr
          ST ctb.ptr
        -- Call CIF process
        C.pony.int.get.nct.id (ctb.ptr, nct.id, result)
    --}}}
    --{{{  `svr' is undefined
    TRUE
      -- Return error
      SEQ
        nct.id := -1
        result := PONYC.RESULT.ERR.GNI.CTENDUNDEFINED
    --}}}
:
--}}}

--}}}
--{{{  PROC pony.err.get.current.remote.node
-- Get ID of current remote node for a given NCT
-- Parameters: err.handle     | error-handle (client-end)
--             nct.id         | VAL: NCT-ID
--             remote.node.id | RESULT: ID of the remote node
--             result         | RESULT: result
PROC pony.err.get.current.remote.node (PONY.ERRHANDLE! err.handle,
                                       VAL INT nct.id,
                                       RESULT INT remote.node.id, result)
  SEQ
    -- Send request via error-handle
    -- Carrying: NCT-ID
    err.handle[to.handler] ! get.current.remote.node; nct.id
    -- Get reply
    -- Carrying: ID of remote node;
    --           result
    err.handle[from.handler] ? CASE get.current.remote.node.confirm; remote.node.id; result
:
--}}}
--{{{  PROC pony.err.new.err.point
-- Get new error-point
-- Parameters: err.handle | error-handle (client-end)
--             err.point  | RESULT: error-point
PROC pony.err.new.err.point (PONY.ERRHANDLE! err.handle,
                             RESULT INT err.point)
  SEQ
    -- Send request via error-handle
    err.handle[to.handler] ! new.err.point
    -- Get reply
    -- Carrying: error-point
    err.handle[from.handler] ? CASE new.err.point.confirm; err.point
:
--}}}
--{{{  PROC pony.err.delete.err.point
-- Delete a given error-point
-- Parameters: err.handle | error-handle (client-end)
--             err.point  | VAL: error-point
--             result     | RESULT: result
PROC pony.err.delete.err.point (PONY.ERRHANDLE! err.handle,
                                VAL INT err.point,
                                RESULT INT result)
  SEQ
    -- Send request via error-handle
    -- Carrying: error-point
    err.handle[to.handler] ! delete.err.point; err.point
    -- Get reply
    -- Carrying: result
    err.handle[from.handler] ? CASE delete.err.point.confirm; result
:
--}}}
--{{{  PROC pony.err.get.errs.after
-- Get errors after a given error-point
-- Parameters: err.handle      | error-handle (client-end)
--             err.point       | error-point
--             check.ans       | VAL: check ANS?
--             check.master    | VAL: check master?
--             check.all.nodes | VAL: check all nodes?
--             nodes.to.check  | VAL: array of nodes to check
--             err.array       | RESULT: array of errors
--             result          | RESULT: result
PROC pony.err.get.errs.after (PONY.ERRHANDLE! err.handle,
                              INT err.point,
                              VAL BOOL check.ans, check.master, check.all.nodes,
                              VAL []INT nodes.to.check,
                              RESULT MOBILE []PONY.ERROR err.array,
                              RESULT INT result)
  SEQ
    -- Send request via error-handle
    -- Carrying: error-point;
    --           check ANS?;
    --           check master?;
    --           check all nodes?;
    --           array of nodes to check
    err.handle[to.handler] ! get.errs.after; err.point;
                             check.ans; check.master; check.all.nodes; nodes.to.check
    -- Get reply
    -- Carrying: array of errors;
    --           new error-point;
    --           result
    err.handle[from.handler] ? CASE get.errs.after.confirm; err.array; err.point; result
:
--}}}
--{{{  PROC pony.err.shutdown
-- Shut down error-handler
-- Parameters: err.handle | error-handle (client-end)
PROC pony.err.shutdown (PONY.ERRHANDLE! err.handle)
  -- Send shutdown request
  err.handle[to.handler] ! shutdown
:
--}}}

--}}}
--{{{  PROCs pony.msg.out.*

--{{{  PROC pony.msg.out.uo
-- Output all messages
-- (version for unshared output channel)
-- Parameters: msg.handle | message-handle (client-end)
--             out!       | output channel
PROC pony.msg.out.uo (PONY.MSGHANDLE! msg.handle, CHAN BYTE out!)
  INT own.node.id, msg.type:
  SEQ
    -- Request initialisation
    msg.handle[to.handler] ! init
    -- Get reply
    -- Carrying: own node-ID;
    --           message-type
    msg.handle[from.handler] ? CASE init.confirm; own.node.id; msg.type
    --{{{  Output warnings
    CASE msg.type
      PONYC.MSGTYPE.STATUS
        SKIP
      PONYC.MSGTYPE.ERR
        SEQ
          out.string("PONY WARNING: pony kernel does not report status messages.*n", 0, out!)
          out.string("PONY WARNING: Discarding error messages from pony kernel.*n", 0, out!)
      ELSE
        out.string("PONY WARNING: Discarding error messages from pony kernel.*n", 0, out!)
    --}}}
    INITIAL BOOL running IS TRUE:
    WHILE running
      SEQ
        -- Get next message
        msg.handle[to.handler] ! get.msg
        -- Wait for reply
        msg.handle[from.handler] ? CASE
          --{{{  New message
          MOBILE []BYTE msg:
          BOOL err.flag:
          -- Carrying: message;
          --           error-flag
          get.msg.confirm; msg; err.flag
            IF
              err.flag
                SKIP
              TRUE
                SEQ
                  out.string("PONY MSG: node ", 0, out!)
                  out.int(own.node.id, 0, out!)
                  out.string(": ", 0, out!)
                  out.string(msg, 0, out!)
                  out.string(".*n", 0, out!)
          --}}}
          --{{{  Message-handler was shut down
          shutdown
            SEQ
              IF
                msg.type <> PONYC.MSGTYPE.ERR
                  SEQ
                    out.string("PONY MSG: node ", 0, out!)
                    out.int(own.node.id, 0, out!)
                    out.string(": shutdown.*n", 0, out!)
                TRUE
                  SKIP
              -- Leave main loop
              running := FALSE
          --}}}
:
--}}}
--{{{  PROC pony.msg.out.so
-- Output all messages
-- (version for shared output channel)
-- Parameters: msg.handle | message-handle (client-end)
--             out!       | output channel (shared)
PROC pony.msg.out.so (PONY.MSGHANDLE! msg.handle, SHARED CHAN BYTE out!)
  INT own.node.id, msg.type:
  SEQ
    -- Request initialisation
    msg.handle[to.handler] ! init
    -- Get reply
    -- Carrying: own node-ID;
    --           message-type
    msg.handle[from.handler] ? CASE init.confirm; own.node.id; msg.type
    --{{{  Output warnings
    CASE msg.type
      PONYC.MSGTYPE.STATUS
        SKIP
      PONYC.MSGTYPE.ERR
        CLAIM out!
          SEQ
            out.string("PONY WARNING: pony kernel does not report status messages.*n", 0, out!)
            out.string("PONY WARNING: Discarding error messages from pony kernel.*n", 0, out!)
      ELSE
        CLAIM out!
          out.string("PONY WARNING: Discarding error messages from pony kernel.*n", 0, out!)
    --}}}
    INITIAL BOOL running IS TRUE:
    WHILE running
      SEQ
        -- Get next message
        msg.handle[to.handler] ! get.msg
        -- Wait for reply
        msg.handle[from.handler] ? CASE
          --{{{  New message
          MOBILE []BYTE msg:
          BOOL err.flag:
          -- Carrying: message;
          --           error-flag
          get.msg.confirm; msg; err.flag
            IF
              err.flag
                SKIP
              TRUE
                CLAIM out!
                  SEQ
                    out.string("PONY MSG: node ", 0, out!)
                    out.int(own.node.id, 0, out!)
                    out.string(": ", 0, out!)
                    out.string(msg, 0, out!)
                    out.string(".*n", 0, out!)
          --}}}
          --{{{  Message-handler was shut down
          shutdown
            SEQ
              IF
                msg.type <> PONYC.MSGTYPE.ERR
                  CLAIM out!
                    SEQ
                      out.string("PONY MSG: node ", 0, out!)
                      out.int(own.node.id, 0, out!)
                      out.string(": shutdown.*n", 0, out!)
                TRUE
                  SKIP
              -- Leave main loop
              running := FALSE
          --}}}
:
--}}}
--{{{  PROC pony.msg.out.ue
-- Output all messages
-- (version for unshared error channel)
-- Parameters: msg.handle | message-handle (client-end)
--             err!       | error channel
PROC pony.msg.out.ue (PONY.MSGHANDLE! msg.handle, CHAN BYTE err!)
  INT own.node.id, msg.type:
  SEQ
    -- Request initialisation
    msg.handle[to.handler] ! init
    -- Get reply
    -- Carrying: own node-ID;
    --           message-type
    msg.handle[from.handler] ? CASE init.confirm; own.node.id; msg.type
    --{{{  Output warnings
    CASE msg.type
      PONYC.MSGTYPE.STATUS
        SEQ
          out.string("PONY WARNING: Discarding status messages from pony kernel.*n", 0, err!)
          out.string("PONY WARNING: pony kernel does not report error messages.*n", 0, err!)
      PONYC.MSGTYPE.ERR
        SKIP
      ELSE
        out.string("PONY WARNING: Discarding status messages from pony kernel.*n", 0, err!)
    --}}}
    INITIAL BOOL running IS TRUE:
    WHILE running
      SEQ
        -- Get next message
        msg.handle[to.handler] ! get.msg
        -- Wait for reply
        msg.handle[from.handler] ? CASE
          --{{{  New message
          MOBILE []BYTE msg:
          BOOL err.flag:
          -- Carrying: message;
          --           error-flag
          get.msg.confirm; msg; err.flag
            IF
              err.flag
                SEQ
                  out.string("PONY ERROR: node ", 0, err!)
                  out.int(own.node.id, 0, err!)
                  out.string(": ", 0, err!)
                  out.string(msg, 0, err!)
                  out.string(".*n", 0, err!)
              TRUE
                SKIP
          --}}}
          --{{{  Message-handler was shut down
          shutdown
            -- Leave main loop
            running := FALSE
          --}}}
:
--}}}
--{{{  PROC pony.msg.out.se
-- Output all messages
-- (version for shared error channel)
-- Parameters: msg.handle | message-handle (client-end)
--             err!       | error channel (shared)
PROC pony.msg.out.se (PONY.MSGHANDLE! msg.handle, SHARED CHAN BYTE err!)
  INT own.node.id, msg.type:
  SEQ
    -- Request initialisation
    msg.handle[to.handler] ! init
    -- Get reply
    -- Carrying: own node-ID;
    --           message-type
    msg.handle[from.handler] ? CASE init.confirm; own.node.id; msg.type
    --{{{  Output warnings
    CASE msg.type
      PONYC.MSGTYPE.STATUS
        CLAIM err!
          SEQ
            out.string("PONY WARNING: Discarding status messages from pony kernel.*n", 0, err!)
            out.string("PONY WARNING: pony kernel does not report error messages.*n", 0, err!)
      PONYC.MSGTYPE.ERR
        SKIP
      ELSE
        CLAIM err!
          out.string("PONY WARNING: Discarding status messages from pony kernel.*n", 0, err!)
    --}}}
    INITIAL BOOL running IS TRUE:
    WHILE running
      SEQ
        -- Get next message
        msg.handle[to.handler] ! get.msg
        -- Wait for reply
        msg.handle[from.handler] ? CASE
          --{{{  New message
          MOBILE []BYTE msg:
          BOOL err.flag:
          -- Carrying: message;
          --           error-flag
          get.msg.confirm; msg; err.flag
            IF
              err.flag
                CLAIM err!
                  SEQ
                    out.string("PONY ERROR: node ", 0, err!)
                    out.int(own.node.id, 0, err!)
                    out.string(": ", 0, err!)
                    out.string(msg, 0, err!)
                    out.string(".*n", 0, err!)
              TRUE
                SKIP
          --}}}
          --{{{  Message-handler was shut down
          shutdown
            -- Leave main loop
            running := FALSE
          --}}}
:
--}}}
--{{{  PROC pony.msg.out.uo.ue
-- Output all messages
-- (version for unshared output channel and unshared error channel)
-- Parameters: msg.handle | message-handle (client-end)
--             out!       | output channel
--             err!       | error channel
PROC pony.msg.out.uo.ue (PONY.MSGHANDLE! msg.handle, CHAN BYTE out!, err!)
  INT own.node.id, msg.type:
  SEQ
    -- Request initialisation
    msg.handle[to.handler] ! init
    -- Get reply
    -- Carrying: own node-ID;
    --           message-type
    msg.handle[from.handler] ? CASE init.confirm; own.node.id; msg.type
    --{{{  Output warnings
    CASE msg.type
      PONYC.MSGTYPE.STATUS
        out.string("PONY WARNING: pony kernel does not report error messages.*n", 0, err!)
      PONYC.MSGTYPE.ERR
        out.string("PONY WARNING: pony kernel does not report status messages.*n", 0, err!)
      ELSE
        SKIP
    --}}}
    INITIAL BOOL running IS TRUE:
    WHILE running
      SEQ
        -- Get next message
        msg.handle[to.handler] ! get.msg
        -- Wait for reply
        msg.handle[from.handler] ? CASE
          --{{{  New message
          MOBILE []BYTE msg:
          BOOL err.flag:
          -- Carrying: message;
          --           error-flag
          get.msg.confirm; msg; err.flag
            IF
              err.flag
                SEQ
                  out.string("PONY ERROR: node ", 0, err!)
                  out.int(own.node.id, 0, err!)
                  out.string(": ", 0, err!)
                  out.string(msg, 0, err!)
                  out.string(".*n", 0, err!)
              TRUE
                SEQ
                  out.string("PONY MSG: node ", 0, out!)
                  out.int(own.node.id, 0, out!)
                  out.string(": ", 0, out!)
                  out.string(msg, 0, out!)
                  out.string(".*n", 0, out!)
          --}}}
          --{{{  Message-handler was shut down
          shutdown
            SEQ
              IF
                msg.type <> PONYC.MSGTYPE.ERR
                  SEQ
                    out.string("PONY MSG: node ", 0, out!)
                    out.int(own.node.id, 0, out!)
                    out.string(": shutdown.*n", 0, out!)
                TRUE
                  SKIP
              -- Leave main loop
              running := FALSE
          --}}}
:
--}}}
--{{{  PROC pony.msg.out.so.ue
-- Output all messages
-- (version for shared output channel and unshared error channel)
-- Parameters: msg.handle | message-handle (client-end)
--             out!       | output channel (shared)
--             err!       | error channel
PROC pony.msg.out.so.ue (PONY.MSGHANDLE! msg.handle, SHARED CHAN BYTE out!, CHAN BYTE err!)
  INT own.node.id, msg.type:
  SEQ
    -- Request initialisation
    msg.handle[to.handler] ! init
    -- Get reply
    -- Carrying: own node-ID;
    --           message-type
    msg.handle[from.handler] ? CASE init.confirm; own.node.id; msg.type
    --{{{  Output warnings
    CASE msg.type
      PONYC.MSGTYPE.STATUS
        out.string("PONY WARNING: pony kernel does not report error messages.*n", 0, err!)
      PONYC.MSGTYPE.ERR
        out.string("PONY WARNING: pony kernel does not report status messages.*n", 0, err!)
      ELSE
        SKIP
    --}}}
    INITIAL BOOL running IS TRUE:
    WHILE running
      SEQ
        -- Get next message
        msg.handle[to.handler] ! get.msg
        -- Wait for reply
        msg.handle[from.handler] ? CASE
          --{{{  New message
          MOBILE []BYTE msg:
          BOOL err.flag:
          -- Carrying: message;
          --           error-flag
          get.msg.confirm; msg; err.flag
            IF
              err.flag
                SEQ
                  out.string("PONY ERROR: node ", 0, err!)
                  out.int(own.node.id, 0, err!)
                  out.string(": ", 0, err!)
                  out.string(msg, 0, err!)
                  out.string(".*n", 0, err!)
              TRUE
                CLAIM out!
                  SEQ
                    out.string("PONY MSG: node ", 0, out!)
                    out.int(own.node.id, 0, out!)
                    out.string(": ", 0, out!)
                    out.string(msg, 0, out!)
                    out.string(".*n", 0, out!)
          --}}}
          --{{{  Message-handler was shut down
          shutdown
            SEQ
              IF
                msg.type <> PONYC.MSGTYPE.ERR
                  CLAIM out!
                    SEQ
                      out.string("PONY MSG: node ", 0, out!)
                      out.int(own.node.id, 0, out!)
                      out.string(": shutdown.*n", 0, out!)
                TRUE
                  SKIP
              -- Leave main loop
              running := FALSE
          --}}}
:
--}}}
--{{{  PROC pony.msg.out.uo.se
-- Output all messages
-- (version for unshared output channel and shared error channel)
-- Parameters: msg.handle | message-handle (client-end)
--             out!       | output channel
--             err!       | error channel (shared)
PROC pony.msg.out.uo.se (PONY.MSGHANDLE! msg.handle, CHAN BYTE out!, SHARED CHAN BYTE err!)
  INT own.node.id, msg.type:
  SEQ
    -- Request initialisation
    msg.handle[to.handler] ! init
    -- Get reply
    -- Carrying: own node-ID;
    --           message-type
    msg.handle[from.handler] ? CASE init.confirm; own.node.id; msg.type
    --{{{  Output warnings
    CASE msg.type
      PONYC.MSGTYPE.STATUS
        CLAIM err!
          out.string("PONY WARNING: pony kernel does not report error messages.*n", 0, err!)
      PONYC.MSGTYPE.ERR
        CLAIM err!
          out.string("PONY WARNING: pony kernel does not report status messages.*n", 0, err!)
      ELSE
        SKIP
    --}}}
    INITIAL BOOL running IS TRUE:
    WHILE running
      SEQ
        -- Get next message
        msg.handle[to.handler] ! get.msg
        -- Wait for reply
        msg.handle[from.handler] ? CASE
          --{{{  New message
          MOBILE []BYTE msg:
          BOOL err.flag:
          -- Carrying: message;
          --           error-flag
          get.msg.confirm; msg; err.flag
            IF
              err.flag
                CLAIM err!
                  SEQ
                    out.string("PONY ERROR: node ", 0, err!)
                    out.int(own.node.id, 0, err!)
                    out.string(": ", 0, err!)
                    out.string(msg, 0, err!)
                    out.string(".*n", 0, err!)
              TRUE
                SEQ
                  out.string("PONY MSG: node ", 0, out!)
                  out.int(own.node.id, 0, out!)
                  out.string(": ", 0, out!)
                  out.string(msg, 0, out!)
                  out.string(".*n", 0, out!)
          --}}}
          --{{{  Message-handler was shut down
          shutdown
            SEQ
              IF
                msg.type <> PONYC.MSGTYPE.ERR
                  SEQ
                    out.string("PONY MSG: node ", 0, out!)
                    out.int(own.node.id, 0, out!)
                    out.string(": shutdown.*n", 0, out!)
                TRUE
                  SKIP
              -- Leave main loop
              running := FALSE
          --}}}
:
--}}}
--{{{  PROC pony.msg.out.so.se
-- Output all messages
-- (version for shared output channel and shared error channel)
-- Parameters: msg.handle | message-handle (client-end)
--             out!       | output channel (shared)
--             err!       | error channel (shared)
PROC pony.msg.out.so.se (PONY.MSGHANDLE! msg.handle, SHARED CHAN BYTE out!, err!)
  INT own.node.id, msg.type:
  SEQ
    -- Request initialisation
    msg.handle[to.handler] ! init
    -- Get reply
    -- Carrying: own node-ID;
    --           message-type
    msg.handle[from.handler] ? CASE init.confirm; own.node.id; msg.type
    --{{{  Output warnings
    CASE msg.type
      PONYC.MSGTYPE.STATUS
        CLAIM err!
          out.string("PONY WARNING: pony kernel does not report error messages.*n", 0, err!)
      PONYC.MSGTYPE.ERR
        CLAIM err!
          out.string("PONY WARNING: pony kernel does not report status messages.*n", 0, err!)
      ELSE
        SKIP
    --}}}
    INITIAL BOOL running IS TRUE:
    WHILE running
      SEQ
        -- Get next message
        msg.handle[to.handler] ! get.msg
        -- Wait for reply
        msg.handle[from.handler] ? CASE
          --{{{  New message
          MOBILE []BYTE msg:
          BOOL err.flag:
          -- Carrying: message;
          --           error-flag
          get.msg.confirm; msg; err.flag
            IF
              err.flag
                CLAIM err!
                  SEQ
                    out.string("PONY ERROR: node ", 0, err!)
                    out.int(own.node.id, 0, err!)
                    out.string(": ", 0, err!)
                    out.string(msg, 0, err!)
                    out.string(".*n", 0, err!)
              TRUE
                CLAIM out!
                  SEQ
                    out.string("PONY MSG: node ", 0, out!)
                    out.int(own.node.id, 0, out!)
                    out.string(": ", 0, out!)
                    out.string(msg, 0, out!)
                    out.string(".*n", 0, out!)
          --}}}
          --{{{  Message-handler was shut down
          shutdown
            SEQ
              IF
                msg.type <> PONYC.MSGTYPE.ERR
                  CLAIM out!
                    SEQ
                      out.string("PONY MSG: node ", 0, out!)
                      out.int(own.node.id, 0, out!)
                      out.string(": shutdown.*n", 0, out!)
                TRUE
                  SKIP
              -- Leave main loop
              running := FALSE
          --}}}
:
--}}}

--}}}

--}}}

