-- Copyright: Mario Schweigler, Adam Sampson (C) 2005-2006
-- Institution: Computing Laboratory, University of Kent, Canterbury, UK
-- Description: Testcase for pony: all types of supported communications

-- This program is free software; you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 2 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program; if not, write to the Free Software
-- Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
-- MA 02110-1301, USA.

--{{{  Tests to enable
--#DEFINE TEST.EXTENDED.WAIT.KEY

#DEFINE TEST.CANCEL
#DEFINE TEST.CANCEL.DELAY

#DEFINE TEST.INT
#DEFINE TEST.INT16
#DEFINE TEST.INT32
#DEFINE TEST.INT64
#DEFINE TEST.BYTE
#DEFINE TEST.BOOL
#DEFINE TEST.REAL32
#DEFINE TEST.REAL64

#DEFINE TEST.INT.EXTENDED
#DEFINE TEST.SIMPLE.RECORD
#DEFINE TEST.SIMPLE.PROTO
#DEFINE TEST.SIMPLE.PROTO.EXTENDED
#DEFINE TEST.ARRAY.1D
#DEFINE TEST.ARRAY.1D.OF.RECORD
#DEFINE TEST.ARRAY.2D
#DEFINE TEST.ARRAY.2D.OF.RECORD
#DEFINE TEST.TAGGED.PROTO
#DEFINE TEST.COUNTED.PROTO.SINGLE
#DEFINE TEST.COUNTED.PROTO.1ST
#DEFINE TEST.COUNTED.PROTO.2ND

#DEFINE TEST.MOBILE.INT
#DEFINE TEST.MOBILE.ARRAY.FIXED.1D
#DEFINE TEST.MOBILE.ARRAY.FIXED.1D.OF.RECORD
#DEFINE TEST.MOBILE.ARRAY.FIXED.2D
#DEFINE TEST.MOBILE.ARRAY.FIXED.2D.OF.RECORD
#DEFINE TEST.MOBILE.RECORD
#DEFINE TEST.MOBILE.ARRAY.DYN.1D
#DEFINE TEST.MOBILE.ARRAY.DYN.1D.OF.RECORD
#DEFINE TEST.MOBILE.ARRAY.DYN.2D
#DEFINE TEST.MOBILE.ARRAY.DYN.2D.OF.RECORD

#DEFINE TEST.CHANTYPE.UC
#DEFINE TEST.CHANTYPE.US
#DEFINE TEST.CHANTYPE.SC
#DEFINE TEST.CHANTYPE.SS

#DEFINE TEST.CHANTYPE.EOI
#DEFINE TEST.CHANTYPE.EOI.SHARED
#DEFINE TEST.CHANTYPE.EOI.SPROTO
#DEFINE TEST.CHANTYPE.EOI.SPROTO.2
--}}}

--{{{  Other settings
VAL INT Iterations IS 10:
#IF (DEFINED (TEST.CANCEL)) AND (DEFINED (TEST.CANCEL.DELAY))
-- Use 250...1000 for `cancel' only
-- Use 100000+ for `cancel.encode' and `cancel'
-- ATTENTION: Values may vary depending on hardware,
--            size of testcase, etc.
VAL INT Cancel.delay IS 100000:
#ENDIF
--}}}

--{{{  USE/INCLUDE declarations
#INCLUDE "course.module"
#INCLUDE "pony.module"
#INCLUDE "trace.inc"
--}}}

--{{{  Declarations

--{{{  RECORDs and PROTOCOLs
DATA TYPE SIMPLER.RECORD
  RECORD
    INT a:
    INT b:
    INT c:
:

DATA TYPE SIMPLE.RECORD
  RECORD
    INT a:
    INT b:
    INT c:
    [10]INT array:
    SIMPLER.RECORD record:
:

PROTOCOL SIMPLE.PROTO IS INT; INT; INT:

PROTOCOL TAGGED.PROTO
  CASE
    first ; INT
    second ; INT ; INT
    third ; INT ; INT ; INT
:

PROTOCOL COUNTED.PROTO.1ST IS INT::[]INT; INT:

PROTOCOL COUNTED.PROTO.2ND IS INT; INT::[]INT; INT:

DATA TYPE MOBILE.RECORD
  MOBILE RECORD
    INT a:
    INT b:
    INT c:
    [10]INT array:
    SIMPLER.RECORD record:
:

CHAN TYPE SIMPLE.CHANTYPE
  MOBILE RECORD
    CHAN INT c?:
:

CHAN TYPE SIMPLER.CHANTYPE
  MOBILE RECORD
    CHAN INT c!:
:
--}}}

--{{{  CHAN TYPE THING
CHAN TYPE THING
  MOBILE RECORD
    #IF (DEFINED (TEST.INT)) OR (DEFINED (TEST.CANCEL))
    CHAN INT int?:
    #ENDIF
    #IF DEFINED (TEST.INT16)
    CHAN INT16 int16?:
    #ENDIF
    #IF DEFINED (TEST.INT32)
    CHAN INT32 int32?:
    #ENDIF
    #IF DEFINED (TEST.INT64)
    CHAN INT64 int64?:
    #ENDIF
    #IF DEFINED (TEST.BYTE)
    CHAN BYTE byte?:
    #ENDIF
    #IF DEFINED (TEST.BOOL)
    CHAN BOOL bool?:
    #ENDIF
    #IF DEFINED (TEST.REAL32)
    CHAN REAL32 real32?:
    #ENDIF
    #IF DEFINED (TEST.REAL64)
    CHAN REAL64 real64?:
    #ENDIF
    #IF DEFINED (TEST.INT.EXTENDED)
    CHAN INT int.e?:
    #ENDIF
    #IF DEFINED (TEST.SIMPLE.RECORD)
    CHAN SIMPLE.RECORD simple.record?:
    #ENDIF
    #IF DEFINED (TEST.SIMPLE.PROTO)
    CHAN SIMPLE.PROTO simple.proto?:
    #ENDIF
    #IF DEFINED (TEST.SIMPLE.PROTO.EXTENDED)
    CHAN SIMPLE.PROTO simple.proto.e?:
    #ENDIF
    #IF DEFINED (TEST.ARRAY.1D)
    CHAN [10]INT array.1d?:
    #ENDIF
    #IF DEFINED (TEST.ARRAY.1D.OF.RECORD)
    CHAN [10]SIMPLE.RECORD array.1d.of.record?:
    #ENDIF
    #IF DEFINED (TEST.ARRAY.2D)
    CHAN [3][3]INT array.2d?:
    #ENDIF
    #IF DEFINED (TEST.ARRAY.2D.OF.RECORD)
    CHAN [3][3]SIMPLE.RECORD array.2d.of.record?:
    #ENDIF
    #IF DEFINED (TEST.TAGGED.PROTO)
    CHAN TAGGED.PROTO tagged.proto?:
    #ENDIF
    #IF DEFINED (TEST.COUNTED.PROTO.SINGLE)
    CHAN INT::[]INT counted.proto.single?:
    #ENDIF
    #IF DEFINED (TEST.COUNTED.PROTO.1ST)
    CHAN COUNTED.PROTO.1ST counted.proto.1st?:
    #ENDIF
    #IF DEFINED (TEST.COUNTED.PROTO.2ND)
    CHAN COUNTED.PROTO.2ND counted.proto.2nd?:
    #ENDIF
    #IF DEFINED (TEST.MOBILE.INT)
    CHAN MOBILE INT mobile.int?:
    #ENDIF
    #IF DEFINED (TEST.MOBILE.ARRAY.FIXED.1D)
    CHAN MOBILE [10]INT mobile.array.fixed.1d?:
    #ENDIF
    #IF DEFINED (TEST.MOBILE.ARRAY.FIXED.1D.OF.RECORD)
    CHAN MOBILE [10]SIMPLE.RECORD mobile.array.fixed.1d.of.record?:
    #ENDIF
    #IF DEFINED (TEST.MOBILE.ARRAY.FIXED.2D)
    CHAN MOBILE [3][3]INT mobile.array.fixed.2d?:
    #ENDIF
    #IF DEFINED (TEST.MOBILE.ARRAY.FIXED.2D.OF.RECORD)
    CHAN MOBILE [3][3]SIMPLE.RECORD mobile.array.fixed.2d.of.record?:
    #ENDIF
    #IF DEFINED (TEST.MOBILE.RECORD)
    CHAN MOBILE.RECORD mobile.record?:
    #ENDIF
    #IF DEFINED (TEST.MOBILE.ARRAY.DYN.1D)
    CHAN MOBILE []INT mobile.array.dyn.1d?:
    #ENDIF
    #IF DEFINED (TEST.MOBILE.ARRAY.DYN.1D.OF.RECORD)
    CHAN MOBILE []SIMPLE.RECORD mobile.array.dyn.1d.of.record?:
    #ENDIF
    #IF DEFINED (TEST.MOBILE.ARRAY.DYN.2D)
    CHAN MOBILE [][]INT mobile.array.dyn.2d?:
    #ENDIF
    #IF DEFINED (TEST.MOBILE.ARRAY.DYN.2D.OF.RECORD)
    CHAN MOBILE [][]SIMPLE.RECORD mobile.array.dyn.2d.of.record?:
    #ENDIF
    #IF DEFINED (TEST.CHANTYPE.US)
    CHAN SIMPLE.CHANTYPE? chantype.us?:
    CHAN SIMPLE.CHANTYPE? chantype.us.return!:
    #ENDIF
    #IF DEFINED (TEST.CHANTYPE.UC)
    CHAN SIMPLER.CHANTYPE! chantype.uc?:
    CHAN SIMPLER.CHANTYPE! chantype.uc.return!:
    #ENDIF
    #IF DEFINED (TEST.CHANTYPE.SS)
    CHAN SHARED SIMPLE.CHANTYPE? chantype.ss?:
    CHAN SHARED SIMPLE.CHANTYPE? chantype.ss.return!:
    #ENDIF
    #IF DEFINED (TEST.CHANTYPE.SC)
    CHAN SHARED SIMPLER.CHANTYPE! chantype.sc?:
    CHAN SHARED SIMPLER.CHANTYPE! chantype.sc.return!:
    #ENDIF
:
--}}}

--{{{  End-over-itself stuff
#IF DEFINED (TEST.CHANTYPE.EOI)
RECURSIVE CHAN TYPE THING.EOI
  MOBILE RECORD
    CHAN INT int?:
    CHAN BYTE reverse.test.1!:
    CHAN THING.EOI! chantype.eoi?:
    CHAN BYTE reverse.test.2!:
:
CHAN TYPE THING.EOI.RETURN
  MOBILE RECORD
    CHAN THING.EOI! chantype.eoi.return!:
:
#ENDIF

#IF DEFINED (TEST.CHANTYPE.EOI.SHARED)
RECURSIVE CHAN TYPE THING.EOI.SHARED
  MOBILE RECORD
    CHAN INT int?:
    CHAN SHARED THING.EOI.SHARED! chantype.eoi.shared?:
:
CHAN TYPE THING.EOI.SHARED.RETURN
  MOBILE RECORD
    CHAN SHARED THING.EOI.SHARED! chantype.eoi.shared.return!:
:
#ENDIF

#IF DEFINED (TEST.CHANTYPE.EOI.SPROTO)
CHAN TYPE THING.EOI.SPROTO:
PROTOCOL EOI.PROTO IS INT; THING.EOI.SPROTO!:
CHAN TYPE THING.EOI.SPROTO
  MOBILE RECORD
    CHAN INT int?:
    CHAN EOI.PROTO chantype.eoi.sproto?:
:
CHAN TYPE THING.EOI.SPROTO.RETURN
  MOBILE RECORD
    CHAN THING.EOI.SPROTO! chantype.eoi.sproto.return!:
:
#ENDIF

#IF DEFINED (TEST.CHANTYPE.EOI.SPROTO.2)
CHAN TYPE THING.EOI.SPROTO.2:
PROTOCOL EOI.PROTO.2 IS THING.EOI.SPROTO.2!; INT:
CHAN TYPE THING.EOI.SPROTO.2
  MOBILE RECORD
    CHAN INT int?:
    CHAN EOI.PROTO.2 chantype.eoi.sproto.2?:
:
CHAN TYPE THING.EOI.SPROTO.2.RETURN
  MOBILE RECORD
    CHAN THING.EOI.SPROTO.2! chantype.eoi.sproto.2.return!:
:
#ENDIF
--}}}

--}}}

--{{{  String utilities (from ponyintaux.occ)
--{{{  PROC strutil.concat.str
-- Concatenate two strings
-- Parameters: str  | RESULT: string to be returned
--             str1 | VAL: first string
--             str1 | VAL: second string
PROC strutil.concat.str (RESULT MOBILE []BYTE str, VAL []BYTE str1, str2)
  SEQ
    str := MOBILE [(SIZE str1) + (SIZE str2)]BYTE
    [str FOR SIZE str1] := str1
    [str FROM SIZE str1 FOR SIZE str2] := str2
:
--}}}
--{{{  PROC strutil.append.str
-- Append a string to a string
-- Parameters: str     | string to be extended
--             app.str | VAL: string to be appended
PROC strutil.append.str (MOBILE []BYTE str, VAL []BYTE app.str)
  INITIAL MOBILE []BYTE old.str IS str:
  strutil.concat.str (str, old.str, app.str)
:
--}}}
--{{{  PROC strutil.append.int
-- Append an integer to a string
-- Parameters: str     | string to be extended
--             app.int | VAL: integer to be appended
PROC strutil.append.int (MOBILE []BYTE str, VAL INT app.int)
  IF
    --{{{  Most negative integer
    app.int = (MOSTNEG INT)
      strutil.append.str (str, "-2147483648")
    --}}}
    --{{{  Zero
    app.int = 0
      strutil.append.str (str, "0")
    --}}}
    --{{{  Else
    TRUE
      INT abs:
      INT neg.offset:
      [10]INT digits:
      INITIAL INT num.digits IS 0:
      MOBILE []BYTE int.str:
      SEQ
        --{{{  Get absolute
        IF
          app.int < 0
            SEQ
              abs := -app.int
              neg.offset := 1
          TRUE
            SEQ
              abs := app.int
              neg.offset := 0
        --}}}
        --{{{  Get digits
        WHILE abs > 0
          SEQ
            digits[num.digits] := abs \ 10
            abs := abs / 10
            num.digits := num.digits + 1
        --}}}
        --{{{  Concat digits (and sign if applicable)
        int.str := MOBILE [num.digits + neg.offset]BYTE
        IF
          app.int < 0
            int.str[0] := '-'
          TRUE
            SKIP
        SEQ i = neg.offset FOR num.digits
          int.str[i] := (BYTE ((INT '0') + digits[((num.digits - i) - 1) + neg.offset]))
        --}}}
        strutil.append.str (str, int.str)
    --}}}
:
--}}}
--}}}

PROC commstest (CHAN BYTE key?, SHARED CHAN BYTE scr!, CHAN BYTE err!)
  MOBILE []BYTE ans.name, app.name, node.name:
  INT node.type, own.node.id, result:
  SHARED PONY.NETHANDLE! net.handle:
  PONY.ERRHANDLE! err.handle:
  INT err.point:
  PONY.MSGHANDLE! msg.handle:
  SEQ
    ans.name := ""
    app.name := "commstest"
    node.name := ""
    --{{{  Get node-type
    node.type := -1
    CHAN GETOPT opts:
    PAR
      file.get.options ("ms", opts!)
      INITIAL BOOL running IS TRUE:
      WHILE running
        BYTE b:
        MOBILE []BYTE s:
        opts ? CASE
          opt ; b
            CASE b
              'm'
                SEQ
                  C.trace ("commstest: will be master")
                  node.type := PONYC.NODETYPE.MASTERRESET
              's'
                SEQ
                  C.trace ("commstest: will be slave")
                  node.type := PONYC.NODETYPE.SLAVEWAIT
          done
            running := FALSE
    IF
      node.type = (-1)
        SEQ
          C.trace ("commstest: you must specify either master (-m) or slave (-s) mode")
          STOP
      TRUE
        SKIP
    --}}}
    --{{{  Startup
    pony.startup.snh.ueh.iep.mh (PONYC.MSGTYPE.STATUSERR,
                                 PONYC.NETTYPE.TCPIP, ans.name,
                                 app.name, node.name, node.type,
                                 own.node.id,
                                 net.handle,
                                 err.handle, err.point,
                                 msg.handle, result)
    C.trace.i ("commstest: pony startup result: ", result)
    --}}}
    IF
      result = PONYC.RESULT.STARTUP.OK
        PAR
          --{{{  Message outputter
          SEQ
            C.trace ("commstest: starting message outputter")
            pony.msg.out.so.ue (msg.handle, scr!, err!)
            C.trace ("commstest: message outputter finished")
          --}}}
          SEQ
            C.trace.i ("commstest: own node-ID: ", own.node.id)
            CASE node.type
              --{{{  PONYC.NODETYPE.MASTERRESET
              PONYC.NODETYPE.MASTERRESET
                #IF DEFINED (TEST.CANCEL)
                SHARED THING? svr:
                #ELSE
                THING? svr:
                #ENDIF
                SEQ
                  --{{{  Startup
                  C.trace ("commstest: master starting, alloc...")
                  CLAIM net.handle!
                    SEQ
                      #IF DEFINED (TEST.CANCEL)
                      pony.alloc.ss (net.handle, "thing", PONYC.SHARETYPE.SHARED, svr, result)
                      #ELSE
                      pony.alloc.us (net.handle, "thing", PONYC.SHARETYPE.SHARED, svr, result)
                      C.printarg (svr)
                      #ENDIF
                  C.trace.i ("commstest: ... done, alloc result: ", result)
                  ASSERT (DEFINED svr)
                  ASSERT (result = PONYC.RESULT.ALLOC.OK)
                  --}}}

                  --{{{  brief delay, to reduce error message confusion
                  TIMER tim:
                  INT t:
                  SEQ
                    tim ? t
                    tim ? AFTER t PLUS 500000
                  --}}}

                  SEQ i = 0 FOR Iterations
                    INT x, y, z:
                    SEQ
                      C.trace.i ("commstest: starting input cycle ", i)

                      --{{{  TEST.INT
                      #IF DEFINED (TEST.INT)
                      C.trace ("commstest: input int...")
                      x := MOSTNEG INT
                      #IF DEFINED (TEST.CANCEL)
                      INT x:
                      CLAIM svr
                        SEQ
                          C.trace ("commstest: ... claimed { input dummy INT...")
                          svr[int] ? x
                          ASSERT (x = i)
                          #IF DEFINED (TEST.CANCEL.DELAY)
                          TIMER tim:
                          INT t:
                          SEQ
                            tim ? t
                            tim ? AFTER t PLUS Cancel.delay
                          #ENDIF
                          C.trace ("commstest: ... dummy INT inputted } ...")
                      CLAIM svr
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                      #ELSE
                      SEQ
                        SEQ
                      #ENDIF
                          svr[int] ? x
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... } ...")
                          #ENDIF
                      C.trace.i ("commstest: ... done, read: ", x)
                      ASSERT (x = i)
                      #ENDIF
                      --}}}

                      --{{{  TEST.INT16
                      #IF DEFINED (TEST.INT16)
                      INITIAL INT16 x IS MOSTNEG INT16:
                      SEQ
                        C.trace ("commstest: input int16...")
                        #IF DEFINED (TEST.CANCEL)
                        INT x:
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { input dummy INT...")
                            svr[int] ? x
                            ASSERT (x = i)
                            #IF DEFINED (TEST.CANCEL.DELAY)
                            TIMER tim:
                            INT t:
                            SEQ
                              tim ? t
                              tim ? AFTER t PLUS Cancel.delay
                            #ENDIF
                            C.trace ("commstest: ... dummy INT inputted } ...")
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                        #ELSE
                        SEQ
                          SEQ
                        #ENDIF
                            svr[int16] ? x
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                        C.trace ("commstest: ... done")
                        ASSERT (x = (INT16 i))
                      #ENDIF
                      --}}}

                      --{{{  TEST.INT32
                      #IF DEFINED (TEST.INT32)
                      INITIAL INT32 x IS MOSTNEG INT32:
                      SEQ
                        C.trace ("commstest: input int32...")
                        #IF DEFINED (TEST.CANCEL)
                        INT x:
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { input dummy INT...")
                            svr[int] ? x
                            ASSERT (x = i)
                            #IF DEFINED (TEST.CANCEL.DELAY)
                            TIMER tim:
                            INT t:
                            SEQ
                              tim ? t
                              tim ? AFTER t PLUS Cancel.delay
                            #ENDIF
                            C.trace ("commstest: ... dummy INT inputted } ...")
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                        #ELSE
                        SEQ
                          SEQ
                        #ENDIF
                            svr[int32] ? x
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                        C.trace ("commstest: ... done")
                        ASSERT (x = (INT32 i))
                      #ENDIF
                      --}}}

                      --{{{  TEST.INT64
                      #IF DEFINED (TEST.INT64)
                      INITIAL INT64 x IS MOSTNEG INT64:
                      SEQ
                        C.trace ("commstest: input int64...")
                        #IF DEFINED (TEST.CANCEL)
                        INT x:
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { input dummy INT...")
                            svr[int] ? x
                            ASSERT (x = i)
                            #IF DEFINED (TEST.CANCEL.DELAY)
                            TIMER tim:
                            INT t:
                            SEQ
                              tim ? t
                              tim ? AFTER t PLUS Cancel.delay
                            #ENDIF
                            C.trace ("commstest: ... dummy INT inputted } ...")
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                        #ELSE
                        SEQ
                          SEQ
                        #ENDIF
                            svr[int64] ? x
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                        C.trace ("commstest: ... done")
                        ASSERT (x = (INT64 i))
                      #ENDIF
                      --}}}

                      --{{{  TEST.BYTE
                      #IF DEFINED (TEST.BYTE)
                      INITIAL BYTE x IS MOSTNEG BYTE:
                      SEQ
                        C.trace ("commstest: input byte...")
                        #IF DEFINED (TEST.CANCEL)
                        INT x:
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { input dummy INT...")
                            svr[int] ? x
                            ASSERT (x = i)
                            #IF DEFINED (TEST.CANCEL.DELAY)
                            TIMER tim:
                            INT t:
                            SEQ
                              tim ? t
                              tim ? AFTER t PLUS Cancel.delay
                            #ENDIF
                            C.trace ("commstest: ... dummy INT inputted } ...")
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                        #ELSE
                        SEQ
                          SEQ
                        #ENDIF
                            svr[byte] ? x
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                        C.trace ("commstest: ... done")
                        ASSERT (x = (BYTE i))
                      #ENDIF
                      --}}}

                      --{{{  TEST.BOOL
                      #IF DEFINED (TEST.BOOL)
                      BOOL x:
                      SEQ
                        IF
                          (i \ 2) = 0
                            x := TRUE
                          TRUE
                            x := FALSE
                        C.trace ("commstest: input bool...")
                        #IF DEFINED (TEST.CANCEL)
                        INT x:
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { input dummy INT...")
                            svr[int] ? x
                            ASSERT (x = i)
                            #IF DEFINED (TEST.CANCEL.DELAY)
                            TIMER tim:
                            INT t:
                            SEQ
                              tim ? t
                              tim ? AFTER t PLUS Cancel.delay
                            #ENDIF
                            C.trace ("commstest: ... dummy INT inputted } ...")
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                        #ELSE
                        SEQ
                          SEQ
                        #ENDIF
                            svr[bool] ? x
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                        C.trace ("commstest: ... done")
                        IF
                          (i \ 2) = 0
                            ASSERT (x = FALSE)
                          TRUE
                            ASSERT (x = TRUE)
                      #ENDIF
                      --}}}

                      --{{{  TEST.REAL32
                      #IF DEFINED (TEST.REAL32)
                      INITIAL REAL32 x IS 999.0:
                      SEQ
                        C.trace ("commstest: input real32...")
                        #IF DEFINED (TEST.CANCEL)
                        INT x:
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { input dummy INT...")
                            svr[int] ? x
                            ASSERT (x = i)
                            #IF DEFINED (TEST.CANCEL.DELAY)
                            TIMER tim:
                            INT t:
                            SEQ
                              tim ? t
                              tim ? AFTER t PLUS Cancel.delay
                            #ENDIF
                            C.trace ("commstest: ... dummy INT inputted } ...")
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                        #ELSE
                        SEQ
                          SEQ
                        #ENDIF
                            svr[real32] ? x
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                        C.trace ("commstest: ... done")
                        ASSERT (x = 555.666)
                      #ENDIF
                      --}}}

                      --{{{  TEST.REAL64
                      #IF DEFINED (TEST.REAL64)
                      INITIAL REAL64 x IS 999.0:
                      SEQ
                        C.trace ("commstest: input real64...")
                        #IF DEFINED (TEST.CANCEL)
                        INT x:
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { input dummy INT...")
                            svr[int] ? x
                            ASSERT (x = i)
                            #IF DEFINED (TEST.CANCEL.DELAY)
                            TIMER tim:
                            INT t:
                            SEQ
                              tim ? t
                              tim ? AFTER t PLUS Cancel.delay
                            #ENDIF
                            C.trace ("commstest: ... dummy INT inputted } ...")
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                        #ELSE
                        SEQ
                          SEQ
                        #ENDIF
                            svr[real64] ? x
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                        C.trace ("commstest: ... done")
                        ASSERT (x = 777.888)
                      #ENDIF
                      --}}}

                      --{{{  TEST.INT.EXTENDED
                      #IF DEFINED (TEST.INT.EXTENDED)
                      C.trace ("commstest: input int (extended input)...")
                      x := MOSTNEG INT
                      C.trace ("commstest: ... before input ...")
                      #IF DEFINED (TEST.CANCEL)
                      INT x:
                      CLAIM svr
                        SEQ
                          C.trace ("commstest: ... claimed { input dummy INT...")
                          svr[int] ? x
                          ASSERT (x = i)
                          #IF DEFINED (TEST.CANCEL.DELAY)
                          TIMER tim:
                          INT t:
                          SEQ
                            tim ? t
                            tim ? AFTER t PLUS Cancel.delay
                          #ENDIF
                          C.trace ("commstest: ... dummy INT inputted } ...")
                      CLAIM svr
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                      #ELSE
                      SEQ
                        SEQ
                      #ENDIF
                          svr[int.e] ?? x
                            SEQ
                              C.trace ("commstest: ... inside input ...")
                              #IF DEFINED (TEST.EXTENDED.WAIT.KEY)
                              C.trace ("commstest: hit a key:")
                              BYTE b:
                              key ? b
                              #ENDIF
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                      C.trace.i ("commstest: ... done, read: ", x)
                      ASSERT (x = i)
                      #ENDIF
                      --}}}

                      --{{{  TEST.SIMPLE.RECORD
                      #IF DEFINED (TEST.SIMPLE.RECORD)
                      C.trace ("commstest: input simple.record...")
                      SIMPLE.RECORD r:
                      SEQ
                        r := [MOSTNEG INT, MOSTNEG INT, MOSTNEG INT, [i = 0 FOR 10 | MOSTNEG INT], [MOSTNEG INT, MOSTNEG INT, MOSTNEG INT]]
                        #IF DEFINED (TEST.CANCEL)
                        INT x:
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { input dummy INT...")
                            svr[int] ? x
                            ASSERT (x = i)
                            #IF DEFINED (TEST.CANCEL.DELAY)
                            TIMER tim:
                            INT t:
                            SEQ
                              tim ? t
                              tim ? AFTER t PLUS Cancel.delay
                            #ENDIF
                            C.trace ("commstest: ... dummy INT inputted } ...")
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                        #ELSE
                        SEQ
                          SEQ
                        #ENDIF
                            svr[simple.record] ? r
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                        C.trace.i ("commstest: ... done, read 1: ", r[a])
                        C.trace.i ("commstest:           read 2: ", r[b])
                        C.trace.i ("commstest:           read 3: ", r[c])
                        C.trace.i ("commstest:    read array[0]: ", r[array][0])
                        C.trace.i ("commstest: ...read array[9]: ", r[array][9])
                        C.trace.i ("commstest:   read record[a]: ", r[record][a])
                        C.trace.i ("commstest:   read record[b]: ", r[record][b])
                        C.trace.i ("commstest: ..read record[c]: ", r[record][c])
                        ASSERT (r[a] = i)
                        ASSERT (r[b] = (i + 1))
                        ASSERT (r[c] = (i + 2))
                        SEQ j = 0 FOR SIZE r[array]
                          ASSERT (r[array][j]= (i + j))
                        ASSERT (r[record][a] = i)
                        ASSERT (r[record][b] = (i + 1))
                        ASSERT (r[record][c] = (i + 2))
                      #ENDIF
                      --}}}

                      --{{{  TEST.SIMPLE.PROTO
                      #IF DEFINED (TEST.SIMPLE.PROTO)
                      C.trace ("commstest: input simple.proto...")
                      x, y, z := MOSTNEG INT, MOSTNEG INT, MOSTNEG INT
                      #IF DEFINED (TEST.CANCEL)
                      INT x:
                      CLAIM svr
                        SEQ
                          C.trace ("commstest: ... claimed { input dummy INT...")
                          svr[int] ? x
                          ASSERT (x = i)
                          #IF DEFINED (TEST.CANCEL.DELAY)
                          TIMER tim:
                          INT t:
                          SEQ
                            tim ? t
                            tim ? AFTER t PLUS Cancel.delay
                          #ENDIF
                          C.trace ("commstest: ... dummy INT inputted } ...")
                      CLAIM svr
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                      #ELSE
                      SEQ
                        SEQ
                      #ENDIF
                          svr[simple.proto] ? x ; y ; z
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... } ...")
                          #ENDIF
                      C.trace.i ("commstest: ... done, read 1: ", x)
                      C.trace.i ("commstest:           read 2: ", y)
                      C.trace.i ("commstest:           read 3: ", z)
                      ASSERT (x = i)
                      ASSERT (y = (i + 1))
                      ASSERT (z = (i + 2))
                      #ENDIF
                      --}}}

                      --{{{  TEST.SIMPLE.PROTO.EXTENDED
                      #IF DEFINED (TEST.SIMPLE.PROTO.EXTENDED)
                      C.trace ("commstest: input simple.proto (extended input)...")
                      x, y, z := MOSTNEG INT, MOSTNEG INT, MOSTNEG INT
                      C.trace ("commstest: ... before input ...")
                      #IF DEFINED (TEST.CANCEL)
                      INT x:
                      CLAIM svr
                        SEQ
                          C.trace ("commstest: ... claimed { input dummy INT...")
                          svr[int] ? x
                          ASSERT (x = i)
                          #IF DEFINED (TEST.CANCEL.DELAY)
                          TIMER tim:
                          INT t:
                          SEQ
                            tim ? t
                            tim ? AFTER t PLUS Cancel.delay
                          #ENDIF
                          C.trace ("commstest: ... dummy INT inputted } ...")
                      CLAIM svr
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                      #ELSE
                      SEQ
                        SEQ
                      #ENDIF
                          svr[simple.proto.e] ?? x ; y ; z
                            SEQ
                              C.trace ("commstest: ... inside input ...")
                              #IF DEFINED (TEST.EXTENDED.WAIT.KEY)
                              C.trace ("commstest: hit a key:")
                              BYTE b:
                              key ? b
                              #ENDIF
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                      C.trace.i ("commstest: ... done, read 1: ", x)
                      C.trace.i ("commstest:           read 2: ", y)
                      C.trace.i ("commstest:           read 3: ", z)
                      ASSERT (x = i)
                      ASSERT (y = (i + 1))
                      ASSERT (z = (i + 2))
                      #ENDIF
                      --}}}

                      --{{{  TEST.ARRAY.1D
                      #IF DEFINED (TEST.ARRAY.1D)
                      C.trace ("commstest: input array.1d...")
                      INITIAL [10]INT a IS [i = 0 FOR 10 | MOSTNEG INT]:
                      SEQ
                        #IF DEFINED (TEST.CANCEL)
                        INT x:
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { input dummy INT...")
                            svr[int] ? x
                            ASSERT (x = i)
                            #IF DEFINED (TEST.CANCEL.DELAY)
                            TIMER tim:
                            INT t:
                            SEQ
                              tim ? t
                              tim ? AFTER t PLUS Cancel.delay
                            #ENDIF
                            C.trace ("commstest: ... dummy INT inputted } ...")
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                        #ELSE
                        SEQ
                          SEQ
                        #ENDIF
                            svr[array.1d] ? a
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                        C.trace.i ("commstest: ... done, read 0: ", a[0])
                        C.trace.i ("commstest:       ... read 9: ", a[9])
                        SEQ j = 0 FOR SIZE a
                          ASSERT (a[j] = (i + j))
                      #ENDIF
                      --}}}

                      --{{{  TEST.ARRAY.1D.OF.RECORD
                      #IF DEFINED (TEST.ARRAY.1D.OF.RECORD)
                      C.trace ("commstest: input array.1d.of.record...")
                      [10]SIMPLE.RECORD a:
                      SEQ
                        #IF DEFINED (TEST.CANCEL)
                        INT x:
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { input dummy INT...")
                            svr[int] ? x
                            ASSERT (x = i)
                            #IF DEFINED (TEST.CANCEL.DELAY)
                            TIMER tim:
                            INT t:
                            SEQ
                              tim ? t
                              tim ? AFTER t PLUS Cancel.delay
                            #ENDIF
                            C.trace ("commstest: ... dummy INT inputted } ...")
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                        #ELSE
                        SEQ
                          SEQ
                        #ENDIF
                            svr[array.1d.of.record] ? a
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                        C.trace ("commstest: ... done")
                        SEQ j = 0 FOR SIZE a
                          SEQ
                            ASSERT (a[j][a] = (i + j))
                            ASSERT (a[j][b] = ((i + j) + 1))
                            ASSERT (a[j][c] = ((i + j) + 2))
                            SEQ k = 0 FOR SIZE a[j][array]
                              ASSERT (a[j][array][k] = ((i + j) + k))
                            ASSERT (a[j][record][a] = (i + j))
                            ASSERT (a[j][record][b] = ((i + j) + 1))
                            ASSERT (a[j][record][c] = ((i + j) + 2))
                      #ENDIF
                      --}}}

                      --{{{  TEST.ARRAY.2D
                      #IF DEFINED (TEST.ARRAY.2D)
                      C.trace ("commstest: input array.2d...")
                      [3][3]INT a:
                      SEQ
                        #IF DEFINED (TEST.CANCEL)
                        INT x:
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { input dummy INT...")
                            svr[int] ? x
                            ASSERT (x = i)
                            #IF DEFINED (TEST.CANCEL.DELAY)
                            TIMER tim:
                            INT t:
                            SEQ
                              tim ? t
                              tim ? AFTER t PLUS Cancel.delay
                            #ENDIF
                            C.trace ("commstest: ... dummy INT inputted } ...")
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                        #ELSE
                        SEQ
                          SEQ
                        #ENDIF
                            svr[array.2d] ? a
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                        C.trace.i ("commstest: ... done, read 0, 0: ", a[0][0])
                        C.trace.i ("commstest:       ... read 2, 2: ", a[2][2])
                        SEQ j = 0 FOR 3
                          SEQ k = 0 FOR 3
                            ASSERT (a[j][k] = ((i + j) + k))
                      #ENDIF
                      --}}}

                      --{{{  TEST.ARRAY.2D.OF.RECORD
                      #IF DEFINED (TEST.ARRAY.2D.OF.RECORD)
                      C.trace ("commstest: input array.2d.of.record...")
                      [3][3]SIMPLE.RECORD a:
                      SEQ
                        #IF DEFINED (TEST.CANCEL)
                        INT x:
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { input dummy INT...")
                            svr[int] ? x
                            ASSERT (x = i)
                            #IF DEFINED (TEST.CANCEL.DELAY)
                            TIMER tim:
                            INT t:
                            SEQ
                              tim ? t
                              tim ? AFTER t PLUS Cancel.delay
                            #ENDIF
                            C.trace ("commstest: ... dummy INT inputted } ...")
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                        #ELSE
                        SEQ
                          SEQ
                        #ENDIF
                            svr[array.2d.of.record] ? a
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                        C.trace ("commstest: ... done")
                        SEQ j = 0 FOR 3
                          SEQ k = 0 FOR 3
                            SEQ
                              ASSERT (a[j][k][a] = (i + (j + k)))
                              ASSERT (a[j][k][b] = ((i + (j + k)) + 1))
                              ASSERT (a[j][k][c] = ((i + (j + k)) + 2))
                              SEQ l = 0 FOR SIZE a[j][k][array]
                                ASSERT (a[j][k][array][l] = ((i + (j + k)) + l))
                              ASSERT (a[j][k][record][a] = (i + (j + k)))
                              ASSERT (a[j][k][record][b] = ((i + (j + k)) + 1))
                              ASSERT (a[j][k][record][c] = ((i + (j + k)) + 2))
                      #ENDIF
                      --}}}

                      --{{{  TEST.TAGGED.PROTO
                      #IF DEFINED (TEST.TAGGED.PROTO)
                      C.trace ("commstest: input tagged.proto...")
                      x, y, z := MOSTNEG INT, MOSTNEG INT, MOSTNEG INT
                      #IF DEFINED (TEST.CANCEL)
                      INT x:
                      CLAIM svr
                        SEQ
                          C.trace ("commstest: ... claimed { input dummy INT...")
                          svr[int] ? x
                          ASSERT (x = i)
                          #IF DEFINED (TEST.CANCEL.DELAY)
                          TIMER tim:
                          INT t:
                          SEQ
                            tim ? t
                            tim ? AFTER t PLUS Cancel.delay
                          #ENDIF
                          C.trace ("commstest: ... dummy INT inputted } ...")
                      CLAIM svr
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                      #ELSE
                      SEQ
                        SEQ
                      #ENDIF
                          svr[tagged.proto] ? CASE
                            first ; x
                              SEQ
                                ASSERT ((i \ 3) = 0)
                                ASSERT (x = i)
                            second ; x ; y
                              SEQ
                                ASSERT ((i \ 3) = 1)
                                ASSERT (x = i)
                                ASSERT (y = (i + 1))
                            third ; x ; y ; z
                              SEQ
                                ASSERT ((i \ 3) = 2)
                                ASSERT (x = i)
                                ASSERT (y = (i + 1))
                                ASSERT (z = (i + 2))
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... } ...")
                          #ENDIF
                      C.trace.i ("commstest: ... done, read: ", x)
                      #ENDIF
                      --}}}

                      --{{{  TEST.COUNTED.PROTO.SINGLE
                      #IF DEFINED (TEST.COUNTED.PROTO.SINGLE)
                      C.trace ("commstest: input counted.proto.single...")
                      VAL INT want.len IS i \ 10:
                      INT len:
                      INITIAL [10]INT a IS [i = 0 FOR 10 | MOSTNEG INT]:
                      SEQ
                        #IF DEFINED (TEST.CANCEL)
                        INT x:
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { input dummy INT...")
                            svr[int] ? x
                            ASSERT (x = i)
                            #IF DEFINED (TEST.CANCEL.DELAY)
                            TIMER tim:
                            INT t:
                            SEQ
                              tim ? t
                              tim ? AFTER t PLUS Cancel.delay
                            #ENDIF
                            C.trace ("commstest: ... dummy INT inputted } ...")
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                        #ELSE
                        SEQ
                          SEQ
                        #ENDIF
                            svr[counted.proto.single] ? len::a
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                        C.trace.i ("commstest: ... done, read len: ", len)
                        ASSERT (len = want.len)
                        SEQ j = 0 FOR want.len
                          ASSERT (a[j] = (i + j))
                      #ENDIF
                      --}}}

                      --{{{  TEST.COUNTED.PROTO.1ST
                      #IF DEFINED (TEST.COUNTED.PROTO.1ST)
                      C.trace ("commstest: input counted.proto.1st...")
                      VAL INT want.len IS i \ 10:
                      INT len:
                      INITIAL [10]INT a IS [i = 0 FOR 10 | MOSTNEG INT]:
                      SEQ
                        #IF DEFINED (TEST.CANCEL)
                        INT x:
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { input dummy INT...")
                            svr[int] ? x
                            ASSERT (x = i)
                            #IF DEFINED (TEST.CANCEL.DELAY)
                            TIMER tim:
                            INT t:
                            SEQ
                              tim ? t
                              tim ? AFTER t PLUS Cancel.delay
                            #ENDIF
                            C.trace ("commstest: ... dummy INT inputted } ...")
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                        #ELSE
                        SEQ
                          SEQ
                        #ENDIF
                            svr[counted.proto.1st] ? len::a; y
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                        C.trace.i ("commstest: ... done, read len: ", len)
                        ASSERT (len = want.len)
                        SEQ j = 0 FOR want.len
                          ASSERT (a[j] = (i + j))
                        ASSERT (y = (i + 1))
                      #ENDIF
                      --}}}

                      --{{{  TEST.COUNTED.PROTO.2ND
                      #IF DEFINED (TEST.COUNTED.PROTO.2ND)
                      C.trace ("commstest: input counted.proto.2nd...")
                      VAL INT want.len IS i \ 10:
                      INT len:
                      INITIAL [10]INT a IS [i = 0 FOR 10 | MOSTNEG INT]:
                      SEQ
                        #IF DEFINED (TEST.CANCEL)
                        INT x:
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { input dummy INT...")
                            svr[int] ? x
                            ASSERT (x = i)
                            #IF DEFINED (TEST.CANCEL.DELAY)
                            TIMER tim:
                            INT t:
                            SEQ
                              tim ? t
                              tim ? AFTER t PLUS Cancel.delay
                            #ENDIF
                            C.trace ("commstest: ... dummy INT inputted } ...")
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                        #ELSE
                        SEQ
                          SEQ
                        #ENDIF
                            svr[counted.proto.2nd] ? x; len::a; y
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                        C.trace.i ("commstest: ... done, read len: ", len)
                        ASSERT (len = want.len)
                        ASSERT (x = i)
                        SEQ j = 0 FOR want.len
                          ASSERT (a[j] = (i + j))
                        ASSERT (y = (i + 1))
                      #ENDIF
                      --}}}

                      --{{{  TEST.MOBILE.INT
                      #IF DEFINED (TEST.MOBILE.INT)
                      C.trace ("commstest: input mobile.int...")
                      MOBILE INT x:
                      SEQ
                        x := MOSTNEG INT
                        #IF DEFINED (TEST.CANCEL)
                        INT x:
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { input dummy INT...")
                            svr[int] ? x
                            ASSERT (x = i)
                            #IF DEFINED (TEST.CANCEL.DELAY)
                            TIMER tim:
                            INT t:
                            SEQ
                              tim ? t
                              tim ? AFTER t PLUS Cancel.delay
                            #ENDIF
                            C.trace ("commstest: ... dummy INT inputted } ...")
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                        #ELSE
                        SEQ
                          SEQ
                        #ENDIF
                            svr[mobile.int] ? x
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                        C.trace.i ("commstest: ... done, read: ", x)
                        ASSERT (x = i)
                      #ENDIF
                      --}}}

                      --{{{  TEST.MOBILE.ARRAY.FIXED.1D
                      #IF DEFINED (TEST.MOBILE.ARRAY.FIXED.1D)
                      C.trace ("commstest: input mobile.array.fixed.1d...")
                      INITIAL MOBILE [10]INT a IS [i = 0 FOR 10 | MOSTNEG INT]:
                      SEQ
                        #IF DEFINED (TEST.CANCEL)
                        INT x:
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { input dummy INT...")
                            svr[int] ? x
                            ASSERT (x = i)
                            #IF DEFINED (TEST.CANCEL.DELAY)
                            TIMER tim:
                            INT t:
                            SEQ
                              tim ? t
                              tim ? AFTER t PLUS Cancel.delay
                            #ENDIF
                            C.trace ("commstest: ... dummy INT inputted } ...")
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                        #ELSE
                        SEQ
                          SEQ
                        #ENDIF
                            svr[mobile.array.fixed.1d] ? a
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                        C.trace.i ("commstest: ... done, read 0: ", a[0])
                        C.trace.i ("commstest:       ... read 9: ", a[9])
                        SEQ j = 0 FOR SIZE a
                          ASSERT (a[j] = (i + j))
                      #ENDIF
                      --}}}

                      --{{{  TEST.MOBILE.ARRAY.FIXED.1D.OF.RECORD
                      #IF DEFINED (TEST.MOBILE.ARRAY.FIXED.1D.OF.RECORD)
                      C.trace ("commstest: input mobile.array.fixed.1d.of.record...")
                      MOBILE [10]SIMPLE.RECORD a:
                      SEQ
                        #IF DEFINED (TEST.CANCEL)
                        INT x:
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { input dummy INT...")
                            svr[int] ? x
                            ASSERT (x = i)
                            #IF DEFINED (TEST.CANCEL.DELAY)
                            TIMER tim:
                            INT t:
                            SEQ
                              tim ? t
                              tim ? AFTER t PLUS Cancel.delay
                            #ENDIF
                            C.trace ("commstest: ... dummy INT inputted } ...")
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                        #ELSE
                        SEQ
                          SEQ
                        #ENDIF
                            svr[mobile.array.fixed.1d.of.record] ? a
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                        C.trace ("commstest: ... done")
                        SEQ j = 0 FOR SIZE a
                          SEQ
                            ASSERT (a[j][a] = (i + j))
                            ASSERT (a[j][b] = ((i + j) + 1))
                            ASSERT (a[j][c] = ((i + j) + 2))
                            SEQ k = 0 FOR SIZE a[j][array]
                              ASSERT (a[j][array][k] = ((i + j) + k))
                            ASSERT (a[j][record][a] = (i + j))
                            ASSERT (a[j][record][b] = ((i + j) + 1))
                            ASSERT (a[j][record][c] = ((i + j) + 2))
                      #ENDIF
                      --}}}

                      --{{{  TEST.MOBILE.ARRAY.FIXED.2D
                      #IF DEFINED (TEST.MOBILE.ARRAY.FIXED.2D)
                      C.trace ("commstest: input mobile.array.fixed.2d...")
                      MOBILE [3][3]INT a:
                      SEQ
                        #IF DEFINED (TEST.CANCEL)
                        INT x:
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { input dummy INT...")
                            svr[int] ? x
                            ASSERT (x = i)
                            #IF DEFINED (TEST.CANCEL.DELAY)
                            TIMER tim:
                            INT t:
                            SEQ
                              tim ? t
                              tim ? AFTER t PLUS Cancel.delay
                            #ENDIF
                            C.trace ("commstest: ... dummy INT inputted } ...")
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                        #ELSE
                        SEQ
                          SEQ
                        #ENDIF
                            svr[mobile.array.fixed.2d] ? a
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                        C.trace.i ("commstest: ... done, read 0, 0: ", a[0][0])
                        C.trace.i ("commstest:       ... read 2, 2: ", a[2][2])
                        SEQ j = 0 FOR 3
                          SEQ k = 0 FOR 3
                            ASSERT (a[j][k] = ((i + j) + k))
                      #ENDIF
                      --}}}

                      --{{{  TEST.MOBILE.ARRAY.FIXED.2D.OF.RECORD
                      #IF DEFINED (TEST.MOBILE.ARRAY.FIXED.2D.OF.RECORD)
                      C.trace ("commstest: input mobile.array.fixed.2d.of.record...")
                      MOBILE [3][3]SIMPLE.RECORD a:
                      SEQ
                        #IF DEFINED (TEST.CANCEL)
                        INT x:
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { input dummy INT...")
                            svr[int] ? x
                            ASSERT (x = i)
                            #IF DEFINED (TEST.CANCEL.DELAY)
                            TIMER tim:
                            INT t:
                            SEQ
                              tim ? t
                              tim ? AFTER t PLUS Cancel.delay
                            #ENDIF
                            C.trace ("commstest: ... dummy INT inputted } ...")
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                        #ELSE
                        SEQ
                          SEQ
                        #ENDIF
                            svr[mobile.array.fixed.2d.of.record] ? a
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                        C.trace ("commstest: ... done")
                        SEQ j = 0 FOR 3
                          SEQ k = 0 FOR 3
                            SEQ
                              ASSERT (a[j][k][a] = (i + (j + k)))
                              ASSERT (a[j][k][b] = ((i + (j + k)) + 1))
                              ASSERT (a[j][k][c] = ((i + (j + k)) + 2))
                              SEQ l = 0 FOR SIZE a[j][k][array]
                                ASSERT (a[j][k][array][l] = ((i + (j + k)) + l))
                              ASSERT (a[j][k][record][a] = (i + (j + k)))
                              ASSERT (a[j][k][record][b] = ((i + (j + k)) + 1))
                              ASSERT (a[j][k][record][c] = ((i + (j + k)) + 2))
                      #ENDIF
                      --}}}

                      --{{{  TEST.MOBILE.RECORD
                      #IF DEFINED (TEST.MOBILE.RECORD)
                      C.trace ("commstest: input mobile.record...")
                      MOBILE.RECORD r:
                      SEQ
                        r[a] := MOSTNEG INT
                        r[b] := MOSTNEG INT
                        r[c] := MOSTNEG INT
                        r[array] := [j = 0 FOR 10 | MOSTNEG INT]
                        r[record] := [MOSTNEG INT, MOSTNEG INT, MOSTNEG INT]
                        #IF DEFINED (TEST.CANCEL)
                        INT x:
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { input dummy INT...")
                            svr[int] ? x
                            ASSERT (x = i)
                            #IF DEFINED (TEST.CANCEL.DELAY)
                            TIMER tim:
                            INT t:
                            SEQ
                              tim ? t
                              tim ? AFTER t PLUS Cancel.delay
                            #ENDIF
                            C.trace ("commstest: ... dummy INT inputted } ...")
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                        #ELSE
                        SEQ
                          SEQ
                        #ENDIF
                            svr[mobile.record] ? r
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                        C.trace.i ("commstest: ... done, read 1: ", r[a])
                        C.trace.i ("commstest:           read 2: ", r[b])
                        C.trace.i ("commstest:           read 3: ", r[c])
                        C.trace.i ("commstest:    read array[0]: ", r[array][0])
                        C.trace.i ("commstest: .. read array[9]: ", r[array][9])
                        C.trace.i ("commstest:   read record[a]: ", r[record][a])
                        C.trace.i ("commstest:   read record[b]: ", r[record][b])
                        C.trace.i ("commstest: ..read record[c]: ", r[record][c])
                        ASSERT (r[a] = i)
                        ASSERT (r[b] = (i + 1))
                        ASSERT (r[c] = (i + 2))
                        SEQ j = 0 FOR SIZE r[array]
                          ASSERT (r[array][j]= (i + j))
                        ASSERT (r[record][a] = i)
                        ASSERT (r[record][b] = (i + 1))
                        ASSERT (r[record][c] = (i + 2))
                      #ENDIF
                      --}}}

                      --{{{  TEST.MOBILE.ARRAY.DYN.1D
                      #IF DEFINED (TEST.MOBILE.ARRAY.DYN.1D)
                      C.trace ("commstest: input mobile.array.dyn.1d...")
                      MOBILE []INT a:
                      SEQ
                        ASSERT (NOT (DEFINED a))
                        #IF DEFINED (TEST.CANCEL)
                        INT x:
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { input dummy INT...")
                            svr[int] ? x
                            ASSERT (x = i)
                            #IF DEFINED (TEST.CANCEL.DELAY)
                            TIMER tim:
                            INT t:
                            SEQ
                              tim ? t
                              tim ? AFTER t PLUS Cancel.delay
                            #ENDIF
                            C.trace ("commstest: ... dummy INT inputted } ...")
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                        #ELSE
                        SEQ
                          SEQ
                        #ENDIF
                            svr[mobile.array.dyn.1d] ? a
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                        ASSERT (DEFINED a)
                        ASSERT ((SIZE a) = 10)
                        C.trace.i ("commstest: ... done, read 0: ", a[0])
                        C.trace.i ("commstest:       ... read 9: ", a[9])
                        SEQ j = 0 FOR 10
                          ASSERT (a[j] = (i + j))
                      #ENDIF
                      --}}}

                      --{{{  TEST.MOBILE.ARRAY.DYN.1D.OF.RECORD
                      #IF DEFINED (TEST.MOBILE.ARRAY.DYN.1D.OF.RECORD)
                      C.trace ("commstest: input mobile.array.dyn.1d.of.record...")
                      MOBILE []SIMPLE.RECORD a:
                      SEQ
                        ASSERT (NOT (DEFINED a))
                        #IF DEFINED (TEST.CANCEL)
                        INT x:
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { input dummy INT...")
                            svr[int] ? x
                            ASSERT (x = i)
                            #IF DEFINED (TEST.CANCEL.DELAY)
                            TIMER tim:
                            INT t:
                            SEQ
                              tim ? t
                              tim ? AFTER t PLUS Cancel.delay
                            #ENDIF
                            C.trace ("commstest: ... dummy INT inputted } ...")
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                        #ELSE
                        SEQ
                          SEQ
                        #ENDIF
                            svr[mobile.array.dyn.1d.of.record] ? a
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                        ASSERT (DEFINED a)
                        ASSERT ((SIZE a) = 10)
                        C.trace ("commstest: ... done")
                        SEQ j = 0 FOR 10
                          SEQ
                            ASSERT (a[j][a] = (i + j))
                            ASSERT (a[j][b] = ((i + j) + 1))
                            ASSERT (a[j][c] = ((i + j) + 2))
                            SEQ k = 0 FOR SIZE a[j][array]
                              ASSERT (a[j][array][k] = ((i + j) + k))
                            ASSERT (a[j][record][a] = (i + j))
                            ASSERT (a[j][record][b] = ((i + j) + 1))
                            ASSERT (a[j][record][c] = ((i + j) + 2))
                      #ENDIF
                      --}}}

                      --{{{  TEST.MOBILE.ARRAY.DYN.2D
                      #IF DEFINED (TEST.MOBILE.ARRAY.DYN.2D)
                      C.trace ("commstest: input mobile.array.dyn.2d...")
                      MOBILE [][]INT a:
                      SEQ
                        ASSERT (NOT (DEFINED a))
                        #IF DEFINED (TEST.CANCEL)
                        INT x:
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { input dummy INT...")
                            svr[int] ? x
                            ASSERT (x = i)
                            #IF DEFINED (TEST.CANCEL.DELAY)
                            TIMER tim:
                            INT t:
                            SEQ
                              tim ? t
                              tim ? AFTER t PLUS Cancel.delay
                            #ENDIF
                            C.trace ("commstest: ... dummy INT inputted } ...")
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                        #ELSE
                        SEQ
                          SEQ
                        #ENDIF
                            svr[mobile.array.dyn.2d] ? a
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                        ASSERT (DEFINED a)
                        ASSERT ((SIZE a) = 3)
                        ASSERT ((SIZE a[0]) = 3)
                        C.trace.i ("commstest: ... done, read 0, 0: ", a[0][0])
                        C.trace.i ("commstest:       ... read 2, 2: ", a[2][2])
                        SEQ j = 0 FOR 3
                          SEQ k = 0 FOR 3
                            ASSERT (a[j][k] = ((i + j) + k))
                      #ENDIF
                      --}}}

                      --{{{  TEST.MOBILE.ARRAY.DYN.2D.OF.RECORD
                      #IF DEFINED (TEST.MOBILE.ARRAY.DYN.2D.OF.RECORD)
                      C.trace ("commstest: input mobile.array.dyn.2d.of.record...")
                      MOBILE [][]SIMPLE.RECORD a:
                      SEQ
                        ASSERT (NOT (DEFINED a))
                        #IF DEFINED (TEST.CANCEL)
                        INT x:
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { input dummy INT...")
                            svr[int] ? x
                            ASSERT (x = i)
                            #IF DEFINED (TEST.CANCEL.DELAY)
                            TIMER tim:
                            INT t:
                            SEQ
                              tim ? t
                              tim ? AFTER t PLUS Cancel.delay
                            #ENDIF
                            C.trace ("commstest: ... dummy INT inputted } ...")
                        CLAIM svr
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                        #ELSE
                        SEQ
                          SEQ
                        #ENDIF
                            svr[mobile.array.dyn.2d.of.record] ? a
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... } ...")
                            #ENDIF
                        ASSERT (DEFINED a)
                        ASSERT ((SIZE a) = 3)
                        ASSERT ((SIZE a[0]) = 3)
                        C.trace ("commstest: ... done")
                        SEQ j = 0 FOR 3
                          SEQ k = 0 FOR 3
                            SEQ
                              ASSERT (a[j][k][a] = (i + (j + k)))
                              ASSERT (a[j][k][b] = ((i + (j + k)) + 1))
                              ASSERT (a[j][k][c] = ((i + (j + k)) + 2))
                              SEQ l = 0 FOR SIZE a[j][k][array]
                                ASSERT (a[j][k][array][l] = ((i + (j + k)) + l))
                              ASSERT (a[j][k][record][a] = (i + (j + k)))
                              ASSERT (a[j][k][record][b] = ((i + (j + k)) + 1))
                              ASSERT (a[j][k][record][c] = ((i + (j + k)) + 2))
                      #ENDIF
                      --}}}

                      --{{{  TEST.CHANTYPE.UC
                      #IF DEFINED (TEST.CHANTYPE.UC)
                      SEQ j = 0 FOR 2
                        SEQ i = 0 FOR 2
                          SEQ
                            C.trace ("commstest: input chantype.uc...")
                            IF
                              i = 0
                                C.trace ("commstest: ... for first time...")
                              TRUE
                                C.trace ("commstest: ... for next time...")
                            SIMPLER.CHANTYPE! xcli:
                            SEQ
                              #IF DEFINED (TEST.CANCEL)
                              INT x:
                              CLAIM svr
                                SEQ
                                  C.trace ("commstest: ... claimed { input dummy INT...")
                                  svr[int] ? x
                                  ASSERT (x = i)
                                  #IF DEFINED (TEST.CANCEL.DELAY)
                                  TIMER tim:
                                  INT t:
                                  SEQ
                                    tim ? t
                                    tim ? AFTER t PLUS Cancel.delay
                                  #ENDIF
                                  C.trace ("commstest: ... dummy INT inputted } ...")
                              CLAIM svr
                                SEQ
                                  C.trace ("commstest: ... claimed { ...")
                              #ELSE
                              SEQ
                                SEQ
                              #ENDIF
                                  svr[chantype.uc] ? xcli
                                  #IF DEFINED (TEST.CANCEL)
                                  C.trace ("commstest: ... } ...")
                                  #ENDIF
                              C.trace ("commstest: ... done, doing input from received chantype...")
                              xcli[c] ? x
                              C.trace.i ("commstest: ... done, read: ", x)
                              ASSERT (x = i)
                              C.trace ("commstest: sending chantype back...")
                              #IF DEFINED (TEST.CANCEL)
                              CLAIM svr
                              #ELSE
                              SEQ
                              #ENDIF
                                svr[chantype.uc.return] ! xcli
                              C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.CHANTYPE.US
                      #IF DEFINED (TEST.CHANTYPE.US)
                      SEQ j = 0 FOR 2
                        SEQ i = 0 FOR 2
                          SEQ
                            C.trace ("commstest: input chantype.us...")
                            IF
                              i = 0
                                C.trace ("commstest: ... for first time...")
                              TRUE
                                C.trace ("commstest: ... for next time...")
                            SIMPLE.CHANTYPE? xsvr:
                            SEQ
                              #IF DEFINED (TEST.CANCEL)
                              INT x:
                              CLAIM svr
                                SEQ
                                  C.trace ("commstest: ... claimed { input dummy INT...")
                                  svr[int] ? x
                                  ASSERT (x = i)
                                  #IF DEFINED (TEST.CANCEL.DELAY)
                                  TIMER tim:
                                  INT t:
                                  SEQ
                                    tim ? t
                                    tim ? AFTER t PLUS Cancel.delay
                                  #ENDIF
                                  C.trace ("commstest: ... dummy INT inputted } ...")
                              CLAIM svr
                                SEQ
                                  C.trace ("commstest: ... claimed { ...")
                              #ELSE
                              SEQ
                                SEQ
                              #ENDIF
                                  svr[chantype.us] ? xsvr
                                  #IF DEFINED (TEST.CANCEL)
                                  C.trace ("commstest: ... } ...")
                                  #ENDIF
                              C.trace ("commstest: ... done, doing input from received chantype...")
                              xsvr[c] ? x
                              C.trace.i ("commstest: ... done, read: ", x)
                              ASSERT (x = i)
                              C.trace ("commstest: sending chantype back...")
                              #IF DEFINED (TEST.CANCEL)
                              CLAIM svr
                              #ELSE
                              SEQ
                              #ENDIF
                                svr[chantype.us.return] ! xsvr
                              C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.CHANTYPE.SC
                      #IF DEFINED (TEST.CHANTYPE.SC)
                      SEQ j = 0 FOR 2
                        SEQ i = 0 FOR 2
                          SEQ
                            C.trace ("commstest: input chantype.sc...")
                            IF
                              i = 0
                                C.trace ("commstest: ... for first time...")
                              TRUE
                                C.trace ("commstest: ... for next time...")
                            SHARED SIMPLER.CHANTYPE! xcli:
                            SEQ
                              #IF DEFINED (TEST.CANCEL)
                              INT x:
                              CLAIM svr
                                SEQ
                                  C.trace ("commstest: ... claimed { input dummy INT...")
                                  svr[int] ? x
                                  ASSERT (x = i)
                                  #IF DEFINED (TEST.CANCEL.DELAY)
                                  TIMER tim:
                                  INT t:
                                  SEQ
                                    tim ? t
                                    tim ? AFTER t PLUS Cancel.delay
                                  #ENDIF
                                  C.trace ("commstest: ... dummy INT inputted } ...")
                              CLAIM svr
                                SEQ
                                  C.trace ("commstest: ... claimed { ...")
                              #ELSE
                              SEQ
                                SEQ
                              #ENDIF
                                  svr[chantype.sc] ? xcli
                                  #IF DEFINED (TEST.CANCEL)
                                  C.trace ("commstest: ... } ...")
                                  #ENDIF
                              C.trace ("commstest: ... done, doing input from received chantype...")
                              CLAIM xcli
                                xcli[c] ? x
                              C.trace.i ("commstest: ... done, read: ", x)
                              ASSERT (x = i)
                              C.trace ("commstest: sending chantype back...")
                              #IF DEFINED (TEST.CANCEL)
                              CLAIM svr
                              #ELSE
                              SEQ
                              #ENDIF
                                svr[chantype.sc.return] ! xcli
                              C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.CHANTYPE.SS
                      #IF DEFINED (TEST.CHANTYPE.SS)
                      SEQ j = 0 FOR 2
                        SEQ i = 0 FOR 2
                          SEQ
                            C.trace ("commstest: input chantype.ss...")
                            IF
                              i = 0
                                C.trace ("commstest: ... for first time...")
                              TRUE
                                C.trace ("commstest: ... for next time...")
                            SHARED SIMPLE.CHANTYPE? xsvr:
                            SEQ
                              #IF DEFINED (TEST.CANCEL)
                              INT x:
                              CLAIM svr
                                SEQ
                                  C.trace ("commstest: ... claimed { input dummy INT...")
                                  svr[int] ? x
                                  ASSERT (x = i)
                                  #IF DEFINED (TEST.CANCEL.DELAY)
                                  TIMER tim:
                                  INT t:
                                  SEQ
                                    tim ? t
                                    tim ? AFTER t PLUS Cancel.delay
                                  #ENDIF
                                  C.trace ("commstest: ... dummy INT inputted } ...")
                              CLAIM svr
                                SEQ
                                  C.trace ("commstest: ... claimed { ...")
                              #ELSE
                              SEQ
                                SEQ
                              #ENDIF
                                  svr[chantype.ss] ? xsvr
                                  #IF DEFINED (TEST.CANCEL)
                                  C.trace ("commstest: ... } ...")
                                  #ENDIF
                              C.trace ("commstest: ... done, doing input from received chantype...")
                              CLAIM xsvr
                                xsvr[c] ? x
                              C.trace.i ("commstest: ... done, read: ", x)
                              ASSERT (x = i)
                              C.trace ("commstest: sending chantype back...")
                              #IF DEFINED (TEST.CANCEL)
                              CLAIM svr
                              #ELSE
                              SEQ
                              #ENDIF
                                svr[chantype.ss.return] ! xsvr
                              C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      C.trace.i ("commstest: finished input cycle ", i)

                  --{{{  TEST.CHANTYPE.EOI
                  #IF DEFINED (TEST.CHANTYPE.EOI)
                  #IF DEFINED (TEST.CANCEL)
                  SHARED THING.EOI? svr.eoi:
                  #ELSE
                  THING.EOI? svr.eoi:
                  #ENDIF
                  THING.EOI! xcli.eoi:
                  THING.EOI.RETURN? svr.eoi.return:
                  SEQ
                    --{{{  Startup
                    C.trace ("commstest: alloc svr.eoi...")
                    CLAIM net.handle!
                      SEQ
                        #IF DEFINED (TEST.CANCEL)
                        pony.alloc.ss (net.handle, "thing.eoi", PONYC.SHARETYPE.UNSHARED, svr.eoi, result)
                        #ELSE
                        pony.alloc.us (net.handle, "thing.eoi", PONYC.SHARETYPE.UNSHARED, svr.eoi, result)
                        C.printarg (svr.eoi)
                        #ENDIF
                    C.trace.i ("commstest: ... done, alloc result: ", result)
                    ASSERT (DEFINED svr.eoi)
                    ASSERT (result = PONYC.RESULT.ALLOC.OK)
                    C.trace ("commstest: alloc svr.eoi.return...")
                    CLAIM net.handle!
                      SEQ
                        pony.alloc.us (net.handle, "thing.eoi.return", PONYC.SHARETYPE.UNSHARED, svr.eoi.return, result)
                        C.printarg (svr.eoi.return)
                    C.trace.i ("commstest: ... done, alloc result: ", result)
                    ASSERT (DEFINED svr.eoi.return)
                    ASSERT (result = PONYC.RESULT.ALLOC.OK)
                    --}}}
                    C.trace ("commstest: input chantype.eoi...")
                    #IF DEFINED (TEST.CANCEL)
                    INT x:
                    CLAIM svr.eoi
                      SEQ
                        C.trace ("commstest: ... claimed { input dummy INT...")
                        svr.eoi[int] ? x
                        ASSERT (x = 55)
                        #IF DEFINED (TEST.CANCEL.DELAY)
                        TIMER tim:
                        INT t:
                        SEQ
                          tim ? t
                          tim ? AFTER t PLUS Cancel.delay
                        #ENDIF
                        C.trace ("commstest: ... dummy INT inputted } ...")
                    CLAIM svr.eoi
                      SEQ
                        C.trace ("commstest: ... claimed { ...")
                    #ELSE
                    SEQ
                      SEQ
                    #ENDIF
                        svr.eoi[chantype.eoi] ? xcli.eoi
                        #IF DEFINED (TEST.CANCEL)
                        C.trace ("commstest: ... } ...")
                        #ENDIF
                    C.trace ("commstest: ... done, doing internal comm...")
                    PAR
                      INITIAL INT x IS MOSTNEG INT:
                      SEQ
                        C.trace ("commstest: ... inputting...")
                        #IF DEFINED (TEST.CANCEL)
                        CLAIM svr.eoi
                        #ELSE
                        SEQ
                        #ENDIF
                          svr.eoi[int] ? x
                        C.trace.i ("commstest: ... input done, read: ", x)
                        ASSERT (x = 55555)
                      SEQ
                        C.trace ("commstest: ... outputting 55555...")
                        xcli.eoi[int] ! 55555
                        C.trace ("commstest: ... output done")
                    C.trace ("commstest: ... internal comm done")
                    C.trace ("commstest: sending chantype.eoi back...")
                    svr.eoi.return[chantype.eoi.return] ! xcli.eoi
                    C.trace ("commstest: ... done")
                    INITIAL INT x IS MOSTNEG INT:
                    SEQ
                      C.trace ("commstest: inputting from returned chantype.eoi...")
                      #IF DEFINED (TEST.CANCEL)
                      CLAIM svr.eoi
                      #ELSE
                      SEQ
                      #ENDIF
                        svr.eoi[int] ? x
                      C.trace.i ("commstest: ... input done, read: ", x)
                      ASSERT (x = 555)
                  #ENDIF
                  --}}}

                  --{{{  TEST.CHANTYPE.EOI.SHARED
                  #IF DEFINED (TEST.CHANTYPE.EOI.SHARED)
                  #IF DEFINED (TEST.CANCEL)
                  SHARED THING.EOI.SHARED? svr.eoi.shared:
                  #ELSE
                  THING.EOI.SHARED? svr.eoi.shared:
                  #ENDIF
                  SHARED THING.EOI.SHARED! xcli.eoi.shared:
                  THING.EOI.SHARED.RETURN? svr.eoi.shared.return:
                  SEQ
                    --{{{  Startup
                    C.trace ("commstest: alloc svr.eoi.shared...")
                    CLAIM net.handle!
                      SEQ
                        #IF DEFINED (TEST.CANCEL)
                        pony.alloc.ss (net.handle, "thing.eoi.shared", PONYC.SHARETYPE.SHARED, svr.eoi.shared, result)
                        #ELSE
                        pony.alloc.us (net.handle, "thing.eoi.shared", PONYC.SHARETYPE.SHARED, svr.eoi.shared, result)
                        C.printarg (svr.eoi.shared)
                        #ENDIF
                    C.trace.i ("commstest: ... done, alloc result: ", result)
                    ASSERT (DEFINED svr.eoi.shared)
                    ASSERT (result = PONYC.RESULT.ALLOC.OK)
                    C.trace ("commstest: alloc svr.eoi.shared.return...")
                    CLAIM net.handle!
                      SEQ
                        pony.alloc.us (net.handle, "thing.eoi.shared.return", PONYC.SHARETYPE.UNSHARED, svr.eoi.shared.return, result)
                        C.printarg (svr.eoi.shared.return)
                    C.trace.i ("commstest: ... done, alloc result: ", result)
                    ASSERT (DEFINED svr.eoi.shared.return)
                    ASSERT (result = PONYC.RESULT.ALLOC.OK)
                    --}}}
                    C.trace ("commstest: input chantype.eoi.shared...")
                    #IF DEFINED (TEST.CANCEL)
                    INT x:
                    CLAIM svr.eoi.shared
                      SEQ
                        C.trace ("commstest: ... claimed { input dummy INT...")
                        svr.eoi.shared[int] ? x
                        ASSERT (x = 66)
                        #IF DEFINED (TEST.CANCEL.DELAY)
                        TIMER tim:
                        INT t:
                        SEQ
                          tim ? t
                          tim ? AFTER t PLUS Cancel.delay
                        #ENDIF
                        C.trace ("commstest: ... dummy INT inputted } ...")
                    CLAIM svr.eoi.shared
                      SEQ
                        C.trace ("commstest: ... claimed { ...")
                    #ELSE
                    SEQ
                      SEQ
                    #ENDIF
                        svr.eoi.shared[chantype.eoi.shared] ? xcli.eoi.shared
                        #IF DEFINED (TEST.CANCEL)
                        C.trace ("commstest: ... } ...")
                        #ENDIF
                    C.trace ("commstest: ... done, doing internal comm...")
                    PAR
                      INITIAL INT x IS MOSTNEG INT:
                      SEQ
                        C.trace ("commstest: ... inputting...")
                        #IF DEFINED (TEST.CANCEL)
                        CLAIM svr.eoi.shared
                        #ELSE
                        SEQ
                        #ENDIF
                          svr.eoi.shared[int] ? x
                        C.trace.i ("commstest: ... input done, read: ", x)
                        ASSERT (x = 66666)
                      SEQ
                        C.trace ("commstest: ... outputting 66666...")
                        CLAIM xcli.eoi.shared
                          xcli.eoi.shared[int] ! 66666
                        C.trace ("commstest: ... output done")
                    C.trace ("commstest: ... internal comm done")
                    C.trace ("commstest: sending chantype.eoi.shared back...")
                    svr.eoi.shared.return[chantype.eoi.shared.return] ! xcli.eoi.shared
                    C.trace ("commstest: ... done")
                    INITIAL INT x IS MOSTNEG INT:
                    SEQ
                      C.trace ("commstest: inputting from returned chantype.eoi.shared...")
                      #IF DEFINED (TEST.CANCEL)
                      CLAIM svr.eoi.shared
                      #ELSE
                      SEQ
                      #ENDIF
                        svr.eoi.shared[int] ? x
                      C.trace.i ("commstest: ... input done, read: ", x)
                      ASSERT (x = 666)
                  #ENDIF
                  --}}}

                  --{{{  TEST.CHANTYPE.EOI.SPROTO
                  #IF DEFINED (TEST.CHANTYPE.EOI.SPROTO)
                  #IF DEFINED (TEST.CANCEL)
                  SHARED THING.EOI.SPROTO? svr.eoi.sproto:
                  #ELSE
                  THING.EOI.SPROTO? svr.eoi.sproto:
                  #ENDIF
                  THING.EOI.SPROTO! xcli.eoi.sproto:
                  THING.EOI.SPROTO.RETURN? svr.eoi.sproto.return:
                  SEQ
                    --{{{  Startup
                    C.trace ("commstest: alloc svr.eoi.sproto...")
                    CLAIM net.handle!
                      SEQ
                        #IF DEFINED (TEST.CANCEL)
                        pony.alloc.ss (net.handle, "thing.eoi.sproto", PONYC.SHARETYPE.UNSHARED, svr.eoi.sproto, result)
                        #ELSE
                        pony.alloc.us (net.handle, "thing.eoi.sproto", PONYC.SHARETYPE.UNSHARED, svr.eoi.sproto, result)
                        C.printarg (svr.eoi.sproto)
                        #ENDIF
                    C.trace.i ("commstest: ... done, alloc result: ", result)
                    ASSERT (DEFINED svr.eoi.sproto)
                    ASSERT (result = PONYC.RESULT.ALLOC.OK)
                    C.trace ("commstest: alloc svr.eoi.sproto.return...")
                    CLAIM net.handle!
                      SEQ
                        pony.alloc.us (net.handle, "thing.eoi.sproto.return", PONYC.SHARETYPE.UNSHARED, svr.eoi.sproto.return, result)
                        C.printarg (svr.eoi.sproto.return)
                    C.trace.i ("commstest: ... done, alloc result: ", result)
                    ASSERT (DEFINED svr.eoi.sproto.return)
                    ASSERT (result = PONYC.RESULT.ALLOC.OK)
                    --}}}
                    C.trace ("commstest: input chantype.eoi.sproto...")
                    INITIAL INT x IS MOSTNEG INT:
                    SEQ
                      #IF DEFINED (TEST.CANCEL)
                      INT x:
                      CLAIM svr.eoi.sproto
                        SEQ
                          C.trace ("commstest: ... claimed { input dummy INT...")
                          svr.eoi.sproto[int] ? x
                          ASSERT (x = 77)
                          #IF DEFINED (TEST.CANCEL.DELAY)
                          TIMER tim:
                          INT t:
                          SEQ
                            tim ? t
                            tim ? AFTER t PLUS Cancel.delay
                          #ENDIF
                          C.trace ("commstest: ... dummy INT inputted } ...")
                      CLAIM svr.eoi.sproto
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                      #ELSE
                      SEQ
                        SEQ
                      #ENDIF
                          svr.eoi.sproto[chantype.eoi.sproto] ? x; xcli.eoi.sproto
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... } ...")
                          #ENDIF
                      ASSERT (x = 12345)
                    C.trace ("commstest: ... done, doing internal comm...")
                    PAR
                      INITIAL INT x IS MOSTNEG INT:
                      SEQ
                        C.trace ("commstest: ... inputting...")
                        #IF DEFINED (TEST.CANCEL)
                        CLAIM svr.eoi.sproto
                        #ELSE
                        SEQ
                        #ENDIF
                          svr.eoi.sproto[int] ? x
                        C.trace.i ("commstest: ... input done, read: ", x)
                        ASSERT (x = 77777)
                      SEQ
                        C.trace ("commstest: ... outputting 77777...")
                        xcli.eoi.sproto[int] ! 77777
                        C.trace ("commstest: ... output done")
                    C.trace ("commstest: ... internal comm done")
                    C.trace ("commstest: sending chantype.eoi.sproto back...")
                    svr.eoi.sproto.return[chantype.eoi.sproto.return] ! xcli.eoi.sproto
                    C.trace ("commstest: ... done")
                    INITIAL INT x IS MOSTNEG INT:
                    SEQ
                      C.trace ("commstest: inputting from returned chantype.eoi.sproto...")
                      #IF DEFINED (TEST.CANCEL)
                      CLAIM svr.eoi.sproto
                      #ELSE
                      SEQ
                      #ENDIF
                        svr.eoi.sproto[int] ? x
                      C.trace.i ("commstest: ... input done, read: ", x)
                      ASSERT (x = 777)
                  #ENDIF
                  --}}}

                  --{{{  TEST.CHANTYPE.EOI.SPROTO.2
                  #IF DEFINED (TEST.CHANTYPE.EOI.SPROTO.2)
                  #IF DEFINED (TEST.CANCEL)
                  SHARED THING.EOI.SPROTO.2? svr.eoi.sproto.2:
                  #ELSE
                  THING.EOI.SPROTO.2? svr.eoi.sproto.2:
                  #ENDIF
                  THING.EOI.SPROTO.2! xcli.eoi.sproto.2:
                  THING.EOI.SPROTO.2.RETURN? svr.eoi.sproto.2.return:
                  SEQ
                    --{{{  Startup
                    C.trace ("commstest: alloc svr.eoi.sproto.2...")
                    CLAIM net.handle!
                      SEQ
                        #IF DEFINED (TEST.CANCEL)
                        pony.alloc.ss (net.handle, "thing.eoi.sproto.2", PONYC.SHARETYPE.UNSHARED, svr.eoi.sproto.2, result)
                        #ELSE
                        pony.alloc.us (net.handle, "thing.eoi.sproto.2", PONYC.SHARETYPE.UNSHARED, svr.eoi.sproto.2, result)
                        C.printarg (svr.eoi.sproto.2)
                        #ENDIF
                    C.trace.i ("commstest: ... done, alloc result: ", result)
                    ASSERT (DEFINED svr.eoi.sproto.2)
                    ASSERT (result = PONYC.RESULT.ALLOC.OK)
                    C.trace ("commstest: alloc svr.eoi.sproto.2.return...")
                    CLAIM net.handle!
                      SEQ
                        pony.alloc.us (net.handle, "thing.eoi.sproto.2.return", PONYC.SHARETYPE.UNSHARED, svr.eoi.sproto.2.return, result)
                        C.printarg (svr.eoi.sproto.2.return)
                    C.trace.i ("commstest: ... done, alloc result: ", result)
                    ASSERT (DEFINED svr.eoi.sproto.2.return)
                    ASSERT (result = PONYC.RESULT.ALLOC.OK)
                    --}}}
                    C.trace ("commstest: input chantype.eoi.sproto.2...")
                    INITIAL INT x IS MOSTNEG INT:
                    SEQ
                      #IF DEFINED (TEST.CANCEL)
                      INT x:
                      CLAIM svr.eoi.sproto.2
                        SEQ
                          C.trace ("commstest: ... claimed { input dummy INT...")
                          svr.eoi.sproto.2[int] ? x
                          ASSERT (x = 88)
                          #IF DEFINED (TEST.CANCEL.DELAY)
                          TIMER tim:
                          INT t:
                          SEQ
                            tim ? t
                            tim ? AFTER t PLUS Cancel.delay
                          #ENDIF
                          C.trace ("commstest: ... dummy INT inputted } ...")
                      CLAIM svr.eoi.sproto.2
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                      #ELSE
                      SEQ
                        SEQ
                      #ENDIF
                          svr.eoi.sproto.2[chantype.eoi.sproto.2] ? xcli.eoi.sproto.2; x
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... } ...")
                          #ENDIF
                      ASSERT (x = 67890)
                    C.trace ("commstest: ... done, doing internal comm...")
                    PAR
                      INITIAL INT x IS MOSTNEG INT:
                      SEQ
                        C.trace ("commstest: ... inputting...")
                        #IF DEFINED (TEST.CANCEL)
                        CLAIM svr.eoi.sproto.2
                        #ELSE
                        SEQ
                        #ENDIF
                          svr.eoi.sproto.2[int] ? x
                        C.trace.i ("commstest: ... input done, read: ", x)
                        ASSERT (x = 88888)
                      SEQ
                        C.trace ("commstest: ... outputting 88888...")
                        xcli.eoi.sproto.2[int] ! 88888
                        C.trace ("commstest: ... output done")
                    C.trace ("commstest: ... internal comm done")
                    C.trace ("commstest: sending chantype.eoi.sproto.2 back...")
                    svr.eoi.sproto.2.return[chantype.eoi.sproto.2.return] ! xcli.eoi.sproto.2
                    C.trace ("commstest: ... done")
                    INITIAL INT x IS MOSTNEG INT:
                    SEQ
                      C.trace ("commstest: inputting from returned chantype.eoi.sproto.2...")
                      #IF DEFINED (TEST.CANCEL)
                      CLAIM svr.eoi.sproto.2
                      #ELSE
                      SEQ
                      #ENDIF
                        svr.eoi.sproto.2[int] ? x
                      C.trace.i ("commstest: ... input done, read: ", x)
                      ASSERT (x = 888)
                  #ENDIF
                  --}}}

                  C.trace ("commstest: master done")
              --}}}
              --{{{  PONYC.NODETYPE.SLAVEWAIT
              PONYC.NODETYPE.SLAVEWAIT
                SHARED THING! cli:
                SEQ
                  --{{{  Startup
                  C.trace ("commstest: slave starting, alloc...")
                  CLAIM net.handle!
                    #IF DEFINED (TEST.CANCEL)
                    pony.alloc.sc (net.handle, "thing", PONYC.SHARETYPE.SHARED, cli, result)
                    #ELSE
                    pony.alloc.sc (net.handle, "thing", PONYC.SHARETYPE.UNSHARED, cli, result)
                    #ENDIF
                  C.trace.i ("commstest: ... done, alloc result: ", result)
                  ASSERT (DEFINED cli)
                  ASSERT (result = PONYC.RESULT.ALLOC.OK)
                  --}}}

                  --{{{  brief delay, to reduce error message confusion
                  TIMER tim:
                  INT t:
                  SEQ
                    tim ? t
                    tim ? AFTER t PLUS 500000
                  --}}}

                  SEQ i = 0 FOR Iterations
                    SEQ
                      C.trace.i ("commstest: starting output cycle ", i)

                      --{{{  TEST.INT
                      #IF DEFINED (TEST.INT)
                      C.trace ("commstest: output int...")
                      CLAIM cli!
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... output dummy INT...")
                          cli[int] ! i
                          C.trace ("commstest: ... dummy INT outputted ...")
                          #ENDIF
                          cli[int] ! i
                          C.trace ("commstest: ... } ...")
                      C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.INT16
                      #IF DEFINED (TEST.INT16)
                      C.trace ("commstest: output int16...")
                      CLAIM cli!
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... output dummy INT...")
                          cli[int] ! i
                          C.trace ("commstest: ... dummy INT outputted ...")
                          #ENDIF
                          cli[int16] ! INT16 i
                          C.trace ("commstest: ... } ...")
                      C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.INT32
                      #IF DEFINED (TEST.INT32)
                      C.trace ("commstest: output int32...")
                      CLAIM cli!
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... output dummy INT...")
                          cli[int] ! i
                          C.trace ("commstest: ... dummy INT outputted ...")
                          #ENDIF
                          cli[int32] ! INT32 i
                          C.trace ("commstest: ... } ...")
                      C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.INT64
                      #IF DEFINED (TEST.INT64)
                      C.trace ("commstest: output int64...")
                      CLAIM cli!
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... output dummy INT...")
                          cli[int] ! i
                          C.trace ("commstest: ... dummy INT outputted ...")
                          #ENDIF
                          cli[int64] ! INT64 i
                          C.trace ("commstest: ... } ...")
                      C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.BYTE
                      #IF DEFINED (TEST.BYTE)
                      C.trace ("commstest: output byte...")
                      CLAIM cli!
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... output dummy INT...")
                          cli[int] ! i
                          C.trace ("commstest: ... dummy INT outputted ...")
                          #ENDIF
                          cli[byte] ! BYTE i
                          C.trace ("commstest: ... } ...")
                      C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.BOOL
                      #IF DEFINED (TEST.BOOL)
                      C.trace ("commstest: output bool...")
                      CLAIM cli!
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... output dummy INT...")
                          cli[int] ! i
                          C.trace ("commstest: ... dummy INT outputted ...")
                          #ENDIF
                          IF
                            (i \ 2) = 0
                              cli[bool] ! FALSE
                            TRUE
                              cli[bool] ! TRUE
                          C.trace ("commstest: ... } ...")
                      C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.REAL32
                      #IF DEFINED (TEST.REAL32)
                      C.trace ("commstest: output real32...")
                      CLAIM cli!
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... output dummy INT...")
                          cli[int] ! i
                          C.trace ("commstest: ... dummy INT outputted ...")
                          #ENDIF
                          cli[real32] ! 555.666
                          C.trace ("commstest: ... } ...")
                      C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.REAL64
                      #IF DEFINED (TEST.REAL64)
                      C.trace ("commstest: output real64...")
                      CLAIM cli!
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... output dummy INT...")
                          cli[int] ! i
                          C.trace ("commstest: ... dummy INT outputted ...")
                          #ENDIF
                          cli[real64] ! 777.888
                          C.trace ("commstest: ... } ...")
                      C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.INT.EXTENDED
                      #IF DEFINED (TEST.INT.EXTENDED)
                      C.trace ("commstest: output int (for extended input)...")
                      CLAIM cli!
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... output dummy INT...")
                          cli[int] ! i
                          C.trace ("commstest: ... dummy INT outputted ...")
                          #ENDIF
                          cli[int.e] ! i
                          C.trace ("commstest: ... } ...")
                      C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.SIMPLE.RECORD
                      #IF DEFINED (TEST.SIMPLE.RECORD)
                      C.trace ("commstest: output simple.record...")
                      CLAIM cli!
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... output dummy INT...")
                          cli[int] ! i
                          C.trace ("commstest: ... dummy INT outputted ...")
                          #ENDIF
                          cli[simple.record] ! [i, i + 1, i + 2, [j = 0 FOR 10 | i + j], [i, i + 1, i + 2]]
                          C.trace ("commstest: ... } ...")
                      C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.SIMPLE.PROTO
                      #IF DEFINED (TEST.SIMPLE.PROTO)
                      C.trace ("commstest: output simple.proto...")
                      CLAIM cli!
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... output dummy INT...")
                          cli[int] ! i
                          C.trace ("commstest: ... dummy INT outputted ...")
                          #ENDIF
                          cli[simple.proto] ! i ; i + 1 ; i + 2
                          C.trace ("commstest: ... } ...")
                      C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.SIMPLE.PROTO.EXTENDED
                      #IF DEFINED (TEST.SIMPLE.PROTO.EXTENDED)
                      C.trace ("commstest: output simple.proto (for extended input)...")
                      CLAIM cli!
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... output dummy INT...")
                          cli[int] ! i
                          C.trace ("commstest: ... dummy INT outputted ...")
                          #ENDIF
                          cli[simple.proto.e] ! i ; i + 1 ; i + 2
                          C.trace ("commstest: ... } ...")
                      C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.ARRAY.1D
                      #IF DEFINED (TEST.ARRAY.1D)
                      C.trace ("commstest: output array.1d...")
                      CLAIM cli!
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... output dummy INT...")
                          cli[int] ! i
                          C.trace ("commstest: ... dummy INT outputted ...")
                          #ENDIF
                          cli[array.1d] ! [j = 0 FOR 10 | i + j]
                          C.trace ("commstest: ... } ...")
                      C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.ARRAY.1D.OF.RECORD
                      #IF DEFINED (TEST.ARRAY.1D.OF.RECORD)
                      C.trace ("commstest: output array.1d.of.record...")
                      [10]SIMPLE.RECORD a:
                      SEQ
                        SEQ j = 0 FOR SIZE a
                          SEQ
                            a[j][a] := (i + j)
                            a[j][b] := ((i + j) + 1)
                            a[j][c] := ((i + j) + 2)
                            SEQ k = 0 FOR SIZE a[j][array]
                              a[j][array][k] := ((i + j) + k)
                            a[j][record][a] := (i + j)
                            a[j][record][b] := ((i + j) + 1)
                            a[j][record][c] := ((i + j) + 2)
                        CLAIM cli!
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... output dummy INT...")
                            cli[int] ! i
                            C.trace ("commstest: ... dummy INT outputted ...")
                            #ENDIF
                            cli[array.1d.of.record] ! a
                            C.trace ("commstest: ... } ...")
                        C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.ARRAY.2D
                      #IF DEFINED (TEST.ARRAY.2D)
                      C.trace ("commstest: output array.2d...")
                      CLAIM cli!
                        [3][3]INT a:
                        SEQ
                          SEQ j = 0 FOR 3
                            SEQ k = 0 FOR 3
                              a[j][k] := (i + j) + k
                          C.trace ("commstest: ... claimed { ...")
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... output dummy INT...")
                          cli[int] ! i
                          C.trace ("commstest: ... dummy INT outputted ...")
                          #ENDIF
                          cli[array.2d] ! a
                          C.trace ("commstest: ... } ...")
                      C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.ARRAY.2D.OF.RECORD
                      #IF DEFINED (TEST.ARRAY.2D.OF.RECORD)
                      C.trace ("commstest: output array.2d.of.record...")
                      [3][3]SIMPLE.RECORD a:
                      SEQ
                        SEQ j = 0 FOR 3
                          SEQ k = 0 FOR 3
                            SEQ
                              a[j][k][a] := (i + (j + k))
                              a[j][k][b] := ((i + (j + k)) + 1)
                              a[j][k][c] := ((i + (j + k)) + 2)
                              SEQ l = 0 FOR SIZE a[j][k][array]
                                a[j][k][array][l] := ((i + (j + k)) + l)
                              a[j][k][record][a] := (i + (j + k))
                              a[j][k][record][b] := ((i + (j + k)) + 1)
                              a[j][k][record][c] := ((i + (j + k)) + 2)
                        CLAIM cli!
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... output dummy INT...")
                            cli[int] ! i
                            C.trace ("commstest: ... dummy INT outputted ...")
                            #ENDIF
                            cli[array.2d.of.record] ! a
                            C.trace ("commstest: ... } ...")
                        C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.TAGGED.PROTO
                      #IF DEFINED (TEST.TAGGED.PROTO)
                      C.trace ("commstest: output tagged.proto...")
                      CLAIM cli!
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... output dummy INT...")
                          cli[int] ! i
                          C.trace ("commstest: ... dummy INT outputted ...")
                          #ENDIF
                          CASE i \ 3
                            0
                              cli[tagged.proto] ! first ; i
                            1
                              cli[tagged.proto] ! second ; i ; i + 1
                            2
                              cli[tagged.proto] ! third ; i ; i + 1 ; i + 2
                          C.trace ("commstest: ... } ...")
                      C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.COUNTED.PROTO.SINGLE
                      #IF DEFINED (TEST.COUNTED.PROTO.SINGLE)
                      C.trace ("commstest: output counted.proto.single...")
                      CLAIM cli!
                        VAL []INT a IS [j = 0 FOR 10 | i + j]:
                        VAL INT len IS i \ 10:
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... output dummy INT...")
                          cli[int] ! i
                          C.trace ("commstest: ... dummy INT outputted ...")
                          #ENDIF
                          cli[counted.proto.single] ! len::[a FOR len]
                          C.trace ("commstest: ... } ...")
                      C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.COUNTED.PROTO.1ST
                      #IF DEFINED (TEST.COUNTED.PROTO.1ST)
                      C.trace ("commstest: output counted.proto.1st...")
                      CLAIM cli!
                        VAL []INT a IS [j = 0 FOR 10 | i + j]:
                        VAL INT len IS i \ 10:
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... output dummy INT...")
                          cli[int] ! i
                          C.trace ("commstest: ... dummy INT outputted ...")
                          #ENDIF
                          cli[counted.proto.1st] ! len::[a FOR len]; i + 1
                          C.trace ("commstest: ... } ...")
                      C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.COUNTED.PROTO.2ND
                      #IF DEFINED (TEST.COUNTED.PROTO.2ND)
                      C.trace ("commstest: output counted.proto.2nd...")
                      CLAIM cli!
                        VAL []INT a IS [j = 0 FOR 10 | i + j]:
                        VAL INT len IS i \ 10:
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... output dummy INT...")
                          cli[int] ! i
                          C.trace ("commstest: ... dummy INT outputted ...")
                          #ENDIF
                          cli[counted.proto.2nd] ! i; len::[a FOR len]; i + 1
                          C.trace ("commstest: ... } ...")
                      C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.MOBILE.INT
                      #IF DEFINED (TEST.MOBILE.INT)
                      C.trace ("commstest: output mobile.int...")
                      CLAIM cli!
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... output dummy INT...")
                          cli[int] ! i
                          C.trace ("commstest: ... dummy INT outputted ...")
                          #ENDIF
                          cli[mobile.int] ! i
                          C.trace ("commstest: ... } ...")
                      C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.MOBILE.ARRAY.FIXED.1D
                      #IF DEFINED (TEST.MOBILE.ARRAY.FIXED.1D)
                      C.trace ("commstest: output mobile.array.fixed.1d...")
                      CLAIM cli!
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... output dummy INT...")
                          cli[int] ! i
                          C.trace ("commstest: ... dummy INT outputted ...")
                          #ENDIF
                          cli[mobile.array.fixed.1d] ! [j = 0 FOR 10 | i + j]
                          C.trace ("commstest: ... } ...")
                      C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.MOBILE.ARRAY.FIXED.1D.OF.RECORD
                      #IF DEFINED (TEST.MOBILE.ARRAY.FIXED.1D.OF.RECORD)
                      C.trace ("commstest: output mobile.array.fixed.1d.of.record...")
                      MOBILE [10]SIMPLE.RECORD a:
                      SEQ
                        SEQ j = 0 FOR SIZE a
                          SEQ
                            a[j][a] := (i + j)
                            a[j][b] := ((i + j) + 1)
                            a[j][c] := ((i + j) + 2)
                            SEQ k = 0 FOR SIZE a[j][array]
                              a[j][array][k] := ((i + j) + k)
                            a[j][record][a] := (i + j)
                            a[j][record][b] := ((i + j) + 1)
                            a[j][record][c] := ((i + j) + 2)
                        CLAIM cli!
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... output dummy INT...")
                            cli[int] ! i
                            C.trace ("commstest: ... dummy INT outputted ...")
                            #ENDIF
                            cli[mobile.array.fixed.1d.of.record] ! a
                            C.trace ("commstest: ... } ...")
                        C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.MOBILE.ARRAY.FIXED.2D
                      #IF DEFINED (TEST.MOBILE.ARRAY.FIXED.2D)
                      C.trace ("commstest: output mobile.array.fixed.2d...")
                      CLAIM cli!
                        MOBILE [3][3]INT a:
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                          SEQ j = 0 FOR 3
                            SEQ k = 0 FOR 3
                              a[j][k] := (i + j) + k
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... output dummy INT...")
                          cli[int] ! i
                          C.trace ("commstest: ... dummy INT outputted ...")
                          #ENDIF
                          cli[mobile.array.fixed.2d] ! a
                          C.trace ("commstest: ... } ...")
                      C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.MOBILE.ARRAY.FIXED.2D.OF.RECORD
                      #IF DEFINED (TEST.MOBILE.ARRAY.FIXED.2D.OF.RECORD)
                      C.trace ("commstest: output mobile.array.fixed.2d.of.record...")
                      MOBILE [3][3]SIMPLE.RECORD a:
                      SEQ
                        SEQ j = 0 FOR 3
                          SEQ k = 0 FOR 3
                            SEQ
                              a[j][k][a] := (i + (j + k))
                              a[j][k][b] := ((i + (j + k)) + 1)
                              a[j][k][c] := ((i + (j + k)) + 2)
                              SEQ l = 0 FOR SIZE a[j][k][array]
                                a[j][k][array][l] := ((i + (j + k)) + l)
                              a[j][k][record][a] := (i + (j + k))
                              a[j][k][record][b] := ((i + (j + k)) + 1)
                              a[j][k][record][c] := ((i + (j + k)) + 2)
                        CLAIM cli!
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... output dummy INT...")
                            cli[int] ! i
                            C.trace ("commstest: ... dummy INT outputted ...")
                            #ENDIF
                            cli[mobile.array.fixed.2d.of.record] ! a
                            C.trace ("commstest: ... } ...")
                        C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.MOBILE.RECORD
                      #IF DEFINED (TEST.MOBILE.RECORD)
                      C.trace ("commstest: output mobile.record...")
                      CLAIM cli!
                        MOBILE.RECORD r:
                        SEQ
                          r[a] := i
                          r[b] := i + 1
                          r[c] := i + 2
                          r[array] := [j = 0 FOR 10 | i + j]
                          r[record][a] := i
                          r[record][b] := i + 1
                          r[record][c] := i + 2
                          C.trace ("commstest: ... claimed { ...")
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... output dummy INT...")
                          cli[int] ! i
                          C.trace ("commstest: ... dummy INT outputted ...")
                          #ENDIF
                          cli[mobile.record] ! r
                          C.trace ("commstest: ... } ...")
                      C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.MOBILE.ARRAY.DYN.1D
                      #IF DEFINED (TEST.MOBILE.ARRAY.DYN.1D)
                      C.trace ("commstest: output mobile.array.dyn.1d...")
                      CLAIM cli!
                        MOBILE []INT a:
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                          a := MOBILE [10]INT
                          SEQ j = 0 FOR 10
                            a[j] := (i + j)
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... output dummy INT...")
                          cli[int] ! i
                          C.trace ("commstest: ... dummy INT outputted ...")
                          #ENDIF
                          cli[mobile.array.dyn.1d] ! a
                          C.trace ("commstest: ... } ...")
                      C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.MOBILE.ARRAY.DYN.1D.OF.RECORD
                      #IF DEFINED (TEST.MOBILE.ARRAY.DYN.1D.OF.RECORD)
                      C.trace ("commstest: output mobile.array.dyn.1d.of.record...")
                      MOBILE []SIMPLE.RECORD a:
                      SEQ
                        a := MOBILE [10]SIMPLE.RECORD
                        SEQ j = 0 FOR 10
                          SEQ
                            a[j][a] := (i + j)
                            a[j][b] := ((i + j) + 1)
                            a[j][c] := ((i + j) + 2)
                            SEQ k = 0 FOR SIZE a[j][array]
                              a[j][array][k] := ((i + j) + k)
                            a[j][record][a] := (i + j)
                            a[j][record][b] := ((i + j) + 1)
                            a[j][record][c] := ((i + j) + 2)
                        CLAIM cli!
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... output dummy INT...")
                            cli[int] ! i
                            C.trace ("commstest: ... dummy INT outputted ...")
                            #ENDIF
                            cli[mobile.array.dyn.1d.of.record] ! a
                            C.trace ("commstest: ... } ...")
                        C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.MOBILE.ARRAY.DYN.2D
                      #IF DEFINED (TEST.MOBILE.ARRAY.DYN.2D)
                      C.trace ("commstest: output mobile.array.dyn.2d...")
                      CLAIM cli!
                        MOBILE [][]INT a:
                        SEQ
                          C.trace ("commstest: ... claimed { ...")
                          a := MOBILE [3][3]INT
                          SEQ j = 0 FOR 3
                            SEQ k = 0 FOR 3
                              a[j][k] := (i + j) + k
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... output dummy INT...")
                          cli[int] ! i
                          C.trace ("commstest: ... dummy INT outputted ...")
                          #ENDIF
                          cli[mobile.array.dyn.2d] ! a
                          C.trace ("commstest: ... } ...")
                      C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.MOBILE.ARRAY.DYN.2D.OF.RECORD
                      #IF DEFINED (TEST.MOBILE.ARRAY.DYN.2D.OF.RECORD)
                      C.trace ("commstest: output mobile.array.dyn.2d.of.record...")
                      MOBILE [][]SIMPLE.RECORD a:
                      SEQ
                        a := MOBILE [3][3]SIMPLE.RECORD
                        SEQ j = 0 FOR 3
                          SEQ k = 0 FOR 3
                            SEQ
                              a[j][k][a] := (i + (j + k))
                              a[j][k][b] := ((i + (j + k)) + 1)
                              a[j][k][c] := ((i + (j + k)) + 2)
                              SEQ l = 0 FOR SIZE a[j][k][array]
                                a[j][k][array][l] := ((i + (j + k)) + l)
                              a[j][k][record][a] := (i + (j + k))
                              a[j][k][record][b] := ((i + (j + k)) + 1)
                              a[j][k][record][c] := ((i + (j + k)) + 2)
                        CLAIM cli!
                          SEQ
                            C.trace ("commstest: ... claimed { ...")
                            #IF DEFINED (TEST.CANCEL)
                            C.trace ("commstest: ... output dummy INT...")
                            cli[int] ! i
                            C.trace ("commstest: ... dummy INT outputted ...")
                            #ENDIF
                            cli[mobile.array.dyn.2d.of.record] ! a
                            C.trace ("commstest: ... } ...")
                        C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.CHANTYPE.UC
                      #IF DEFINED (TEST.CHANTYPE.UC)
                      SIMPLER.CHANTYPE! xcli:
                      SIMPLER.CHANTYPE? xsvr:
                      SEQ j = 0 FOR 2
                        SEQ
                          IF
                            j = 0
                              xcli, xsvr := MOBILE SIMPLER.CHANTYPE
                            TRUE
                              INITIAL MOBILE []BYTE ext.name IS "thing-chantype-uc-":
                              INITIAL MOBILE []BYTE message IS "commstest: alloc external thing-chantype-uc-":
                              SEQ
                                strutil.append.int (ext.name, i)
                                strutil.append.int (message, i)
                                strutil.append.str (message, "...")
                                CLAIM net.handle
                                  INT result:
                                  SEQ
                                    C.trace (message)
                                    pony.alloc.uc (net.handle, ext.name, PONYC.SHARETYPE.UNSHARED, xcli, result)
                                    C.trace.i ("commstest: ... xcli done, alloc result: ", result)
                                    ASSERT (DEFINED xcli)
                                    ASSERT (result = PONYC.RESULT.ALLOC.OK)
                                    pony.alloc.us (net.handle, ext.name, PONYC.SHARETYPE.UNSHARED, xsvr, result)
                                    C.trace.i ("commstest: ... xsvr done, alloc result: ", result)
                                    ASSERT (DEFINED xsvr)
                                    ASSERT (result = PONYC.RESULT.ALLOC.OK)
                          SEQ i = 0 FOR 2
                            SEQ
                              C.trace ("commstest: output chantype.uc...")
                              IF
                                i = 0
                                  C.trace ("commstest: ... for first time...")
                                TRUE
                                  C.trace ("commstest: ... for next time...")
                              CLAIM cli!
                                SEQ
                                  C.trace ("commstest: ... claimed { ...")
                                  #IF DEFINED (TEST.CANCEL)
                                  C.trace ("commstest: ... output dummy INT...")
                                  cli[int] ! i
                                  C.trace ("commstest: ... dummy INT outputted ...")
                                  #ENDIF
                                  cli[chantype.uc] ! xcli
                                  C.trace ("commstest: ... } ...")
                              C.trace ("commstest: ... done, doing output on sent chantype...")
                              xsvr[c] ! i
                              C.trace ("commstest: ... done")
                              C.trace ("commstest: input chantype.uc back...")
                              CLAIM cli!
                                cli[chantype.uc.return] ? xcli
                              C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.CHANTYPE.US
                      #IF DEFINED (TEST.CHANTYPE.US)
                      SIMPLE.CHANTYPE! xcli:
                      SIMPLE.CHANTYPE? xsvr:
                      SEQ j = 0 FOR 2
                        SEQ
                          IF
                            j = 0
                              xcli, xsvr := MOBILE SIMPLE.CHANTYPE
                            TRUE
                              INITIAL MOBILE []BYTE ext.name IS "thing-chantype-us-":
                              INITIAL MOBILE []BYTE message IS "commstest: alloc external thing-chantype-us-":
                              SEQ
                                strutil.append.int (ext.name, i)
                                strutil.append.int (message, i)
                                strutil.append.str (message, "...")
                                CLAIM net.handle
                                  INT result:
                                  SEQ
                                    C.trace (message)
                                    pony.alloc.uc (net.handle, ext.name, PONYC.SHARETYPE.UNSHARED, xcli, result)
                                    C.trace.i ("commstest: ... xcli done, alloc result: ", result)
                                    ASSERT (DEFINED xcli)
                                    ASSERT (result = PONYC.RESULT.ALLOC.OK)
                                    pony.alloc.us (net.handle, ext.name, PONYC.SHARETYPE.UNSHARED, xsvr, result)
                                    C.trace.i ("commstest: ... xsvr done, alloc result: ", result)
                                    ASSERT (DEFINED xsvr)
                                    ASSERT (result = PONYC.RESULT.ALLOC.OK)
                          SEQ i = 0 FOR 2
                            SEQ
                              C.trace ("commstest: output chantype.us...")
                              IF
                                i = 0
                                  C.trace ("commstest: ... for first time...")
                                TRUE
                                  C.trace ("commstest: ... for next time...")
                              CLAIM cli!
                                SEQ
                                  C.trace ("commstest: ... claimed { ...")
                                  #IF DEFINED (TEST.CANCEL)
                                  C.trace ("commstest: ... output dummy INT...")
                                  cli[int] ! i
                                  C.trace ("commstest: ... dummy INT outputted ...")
                                  #ENDIF
                                  cli[chantype.us] ! xsvr
                                  C.trace ("commstest: ... } ...")
                              C.trace ("commstest: ... done, doing output on sent chantype...")
                              xcli[c] ! i
                              C.trace ("commstest: ... done")
                              C.trace ("commstest: input chantype.us back...")
                              CLAIM cli!
                                cli[chantype.us.return] ? xsvr
                              C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.CHANTYPE.SC
                      #IF DEFINED (TEST.CHANTYPE.SC)
                      SHARED SIMPLER.CHANTYPE! xcli:
                      SIMPLER.CHANTYPE? xsvr:
                      SEQ j = 0 FOR 2
                        SEQ
                          IF
                            j = 0
                              xcli, xsvr := MOBILE SIMPLER.CHANTYPE
                            TRUE
                              INITIAL MOBILE []BYTE ext.name IS "thing-chantype-sc-":
                              INITIAL MOBILE []BYTE message IS "commstest: alloc external thing-chantype-sc-":
                              SEQ
                                strutil.append.int (ext.name, i)
                                strutil.append.int (message, i)
                                strutil.append.str (message, "...")
                                CLAIM net.handle
                                  INT result:
                                  SEQ
                                    C.trace (message)
                                    pony.alloc.sc (net.handle, ext.name, PONYC.SHARETYPE.UNSHARED, xcli, result)
                                    C.trace.i ("commstest: ... xcli done, alloc result: ", result)
                                    ASSERT (DEFINED xcli)
                                    ASSERT (result = PONYC.RESULT.ALLOC.OK)
                                    pony.alloc.us (net.handle, ext.name, PONYC.SHARETYPE.SHARED, xsvr, result)
                                    C.trace.i ("commstest: ... xsvr done, alloc result: ", result)
                                    ASSERT (DEFINED xsvr)
                                    ASSERT (result = PONYC.RESULT.ALLOC.OK)
                          SEQ i = 0 FOR 2
                            SEQ
                              C.trace ("commstest: output chantype.sc...")
                              IF
                                i = 0
                                  C.trace ("commstest: ... for first time...")
                                TRUE
                                  C.trace ("commstest: ... for next time...")
                              CLAIM cli!
                                SEQ
                                  C.trace ("commstest: ... claimed { ...")
                                  #IF DEFINED (TEST.CANCEL)
                                  C.trace ("commstest: ... output dummy INT...")
                                  cli[int] ! i
                                  C.trace ("commstest: ... dummy INT outputted ...")
                                  #ENDIF
                                  cli[chantype.sc] ! xcli
                                  C.trace ("commstest: ... } ...")
                              C.trace ("commstest: ... done, doing output on sent chantype...")
                              xsvr[c] ! i
                              C.trace ("commstest: ... done")
                              C.trace ("commstest: input chantype.sc back...")
                              CLAIM cli!
                                cli[chantype.sc.return] ? xcli
                              C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      --{{{  TEST.CHANTYPE.SS
                      #IF DEFINED (TEST.CHANTYPE.SS)
                      SIMPLE.CHANTYPE! xcli:
                      SHARED SIMPLE.CHANTYPE? xsvr:
                      SEQ j = 0 FOR 2
                        SEQ
                          IF
                            j = 0
                              xcli, xsvr := MOBILE SIMPLE.CHANTYPE
                            TRUE
                              INITIAL MOBILE []BYTE ext.name IS "thing-chantype-ss-":
                              INITIAL MOBILE []BYTE message IS "commstest: alloc external thing-chantype-ss-":
                              SEQ
                                strutil.append.int (ext.name, i)
                                strutil.append.int (message, i)
                                strutil.append.str (message, "...")
                                CLAIM net.handle
                                  INT result:
                                  SEQ
                                    C.trace (message)
                                    pony.alloc.uc (net.handle, ext.name, PONYC.SHARETYPE.SHARED, xcli, result)
                                    C.trace.i ("commstest: ... xcli done, alloc result: ", result)
                                    ASSERT (DEFINED xcli)
                                    ASSERT (result = PONYC.RESULT.ALLOC.OK)
                                    pony.alloc.ss (net.handle, ext.name, PONYC.SHARETYPE.UNSHARED, xsvr, result)
                                    C.trace.i ("commstest: ... xsvr done, alloc result: ", result)
                                    ASSERT (DEFINED xsvr)
                                    ASSERT (result = PONYC.RESULT.ALLOC.OK)
                          SEQ i = 0 FOR 2
                            SEQ
                              C.trace ("commstest: output chantype.ss...")
                              IF
                                i = 0
                                  C.trace ("commstest: ... for first time...")
                                TRUE
                                  C.trace ("commstest: ... for next time...")
                              CLAIM cli!
                                SEQ
                                  C.trace ("commstest: ... claimed { ...")
                                  #IF DEFINED (TEST.CANCEL)
                                  C.trace ("commstest: ... output dummy INT...")
                                  cli[int] ! i
                                  C.trace ("commstest: ... dummy INT outputted ...")
                                  #ENDIF
                                  cli[chantype.ss] ! xsvr
                                  C.trace ("commstest: ... } ...")
                              C.trace ("commstest: ... done, doing output on sent chantype...")
                              xcli[c] ! i
                              C.trace ("commstest: ... done")
                              C.trace ("commstest: input chantype.ss back...")
                              CLAIM cli!
                                cli[chantype.ss.return] ? xsvr
                              C.trace ("commstest: ... done")
                      #ENDIF
                      --}}}

                      C.trace.i ("commstest: finished output cycle ", i)

                  --{{{  TEST.CHANTYPE.EOI
                  #IF DEFINED (TEST.CHANTYPE.EOI)
                  THING.EOI! cli.eoi:
                  THING.EOI.RETURN! cli.eoi.return:
                  SEQ
                    --{{{  Startup
                    C.trace ("commstest: alloc cli.eoi...")
                    CLAIM net.handle!
                      SEQ
                        #IF DEFINED (TEST.CANCEL)
                        pony.alloc.uc (net.handle, "thing.eoi", PONYC.SHARETYPE.SHARED, cli.eoi, result)
                        #ELSE
                        pony.alloc.uc (net.handle, "thing.eoi", PONYC.SHARETYPE.UNSHARED, cli.eoi, result)
                        #ENDIF
                    C.trace.i ("commstest: ... done, alloc result: ", result)
                    ASSERT (DEFINED cli.eoi)
                    ASSERT (result = PONYC.RESULT.ALLOC.OK)
                    C.trace ("commstest: alloc cli.eoi.return...")
                    CLAIM net.handle!
                      SEQ
                        pony.alloc.uc (net.handle, "thing.eoi.return", PONYC.SHARETYPE.UNSHARED, cli.eoi.return, result)
                    C.trace.i ("commstest: ... done, alloc result: ", result)
                    ASSERT (DEFINED cli.eoi.return)
                    ASSERT (result = PONYC.RESULT.ALLOC.OK)
                    --}}}
                    C.trace ("commstest: output chantype.eoi...")
                    #IF DEFINED (TEST.CANCEL)
                    C.trace ("commstest: ... output dummy INT...")
                    cli.eoi[int] ! 55
                    C.trace ("commstest: ... dummy INT outputted ...")
                    #ENDIF
                    cli.eoi[chantype.eoi] ! cli.eoi
                    C.trace ("commstest: ... done")
                    C.trace ("commstest: input chantype.eoi back...")
                    cli.eoi.return[chantype.eoi.return] ? cli.eoi
                    C.trace ("commstest: ... done")
                    C.trace ("commstest: ... outputting 555 to returned chantype.eoi...")
                    cli.eoi[int] ! 555
                    C.trace ("commstest: ... output done")
                  #ENDIF
                  --}}}

                  --{{{  TEST.CHANTYPE.EOI.SHARED
                  #IF DEFINED (TEST.CHANTYPE.EOI.SHARED)
                  SHARED THING.EOI.SHARED! cli.eoi.shared:
                  THING.EOI.SHARED.RETURN! cli.eoi.shared.return:
                  SEQ
                    --{{{  Startup
                    C.trace ("commstest: alloc cli.eoi.shared...")
                    CLAIM net.handle!
                      SEQ
                        #IF DEFINED (TEST.CANCEL)
                        pony.alloc.sc (net.handle, "thing.eoi.shared", PONYC.SHARETYPE.SHARED, cli.eoi.shared, result)
                        #ELSE
                        pony.alloc.sc (net.handle, "thing.eoi.shared", PONYC.SHARETYPE.UNSHARED, cli.eoi.shared, result)
                        #ENDIF
                    C.trace.i ("commstest: ... done, alloc result: ", result)
                    ASSERT (DEFINED cli.eoi.shared)
                    ASSERT (result = PONYC.RESULT.ALLOC.OK)
                    C.trace ("commstest: alloc cli.eoi.shared.return...")
                    CLAIM net.handle!
                      SEQ
                        pony.alloc.uc (net.handle, "thing.eoi.shared.return", PONYC.SHARETYPE.UNSHARED, cli.eoi.shared.return, result)
                    C.trace.i ("commstest: ... done, alloc result: ", result)
                    ASSERT (DEFINED cli.eoi.shared.return)
                    ASSERT (result = PONYC.RESULT.ALLOC.OK)
                    --}}}
                    C.trace ("commstest: output chantype.eoi.shared...")
                    SHARED THING.EOI.SHARED! xcli.eoi.shared:
                    SEQ
                      xcli.eoi.shared := cli.eoi.shared
                      CLAIM cli.eoi.shared
                        SEQ
                          #IF DEFINED (TEST.CANCEL)
                          C.trace ("commstest: ... output dummy INT...")
                          cli.eoi.shared[int] ! 66
                          C.trace ("commstest: ... dummy INT outputted ...")
                          #ENDIF
                          cli.eoi.shared[chantype.eoi.shared] ! xcli.eoi.shared
                    C.trace ("commstest: ... done")
                    C.trace ("commstest: input chantype.eoi.shared back...")
                    cli.eoi.shared.return[chantype.eoi.shared.return] ? cli.eoi.shared
                    C.trace ("commstest: ... done")
                    C.trace ("commstest: ... outputting 666 to returned chantype.eoi.shared...")
                    CLAIM cli.eoi.shared
                      cli.eoi.shared[int] ! 666
                    C.trace ("commstest: ... output done")
                  #ENDIF
                  --}}}

                  --{{{  TEST.CHANTYPE.EOI.SPROTO
                  #IF DEFINED (TEST.CHANTYPE.EOI.SPROTO)
                  THING.EOI.SPROTO! cli.eoi.sproto:
                  THING.EOI.SPROTO.RETURN! cli.eoi.sproto.return:
                  SEQ
                    --{{{  Startup
                    C.trace ("commstest: alloc cli.eoi.sproto...")
                    CLAIM net.handle!
                      SEQ
                        #IF DEFINED (TEST.CANCEL)
                        pony.alloc.uc (net.handle, "thing.eoi.sproto", PONYC.SHARETYPE.SHARED, cli.eoi.sproto, result)
                        #ELSE
                        pony.alloc.uc (net.handle, "thing.eoi.sproto", PONYC.SHARETYPE.UNSHARED, cli.eoi.sproto, result)
                        #ENDIF
                    C.trace.i ("commstest: ... done, alloc result: ", result)
                    ASSERT (DEFINED cli.eoi.sproto)
                    ASSERT (result = PONYC.RESULT.ALLOC.OK)
                    C.trace ("commstest: alloc cli.eoi.sproto.return...")
                    CLAIM net.handle!
                      SEQ
                        pony.alloc.uc (net.handle, "thing.eoi.sproto.return", PONYC.SHARETYPE.UNSHARED, cli.eoi.sproto.return, result)
                    C.trace.i ("commstest: ... done, alloc result: ", result)
                    ASSERT (DEFINED cli.eoi.sproto.return)
                    ASSERT (result = PONYC.RESULT.ALLOC.OK)
                    --}}}
                    C.trace ("commstest: output chantype.eoi.sproto...")
                    #IF DEFINED (TEST.CANCEL)
                    C.trace ("commstest: ... output dummy INT...")
                    cli.eoi.sproto[int] ! 77
                    C.trace ("commstest: ... dummy INT outputted ...")
                    #ENDIF
                    cli.eoi.sproto[chantype.eoi.sproto] ! 12345; cli.eoi.sproto
                    C.trace ("commstest: ... done")
                    C.trace ("commstest: input chantype.eoi.sproto back...")
                    cli.eoi.sproto.return[chantype.eoi.sproto.return] ? cli.eoi.sproto
                    C.trace ("commstest: ... done")
                    C.trace ("commstest: ... outputting 777 to returned chantype.eoi.sproto...")
                    cli.eoi.sproto[int] ! 777
                    C.trace ("commstest: ... output done")
                  #ENDIF
                  --}}}

                  --{{{  TEST.CHANTYPE.EOI.SPROTO.2
                  #IF DEFINED (TEST.CHANTYPE.EOI.SPROTO.2)
                  THING.EOI.SPROTO.2! cli.eoi.sproto.2:
                  THING.EOI.SPROTO.2.RETURN! cli.eoi.sproto.2.return:
                  SEQ
                    --{{{  Startup
                    C.trace ("commstest: alloc cli.eoi.sproto.2...")
                    CLAIM net.handle!
                      SEQ
                        #IF DEFINED (TEST.CANCEL)
                        pony.alloc.uc (net.handle, "thing.eoi.sproto.2", PONYC.SHARETYPE.SHARED, cli.eoi.sproto.2, result)
                        #ELSE
                        pony.alloc.uc (net.handle, "thing.eoi.sproto.2", PONYC.SHARETYPE.UNSHARED, cli.eoi.sproto.2, result)
                        #ENDIF
                    C.trace.i ("commstest: ... done, alloc result: ", result)
                    ASSERT (DEFINED cli.eoi.sproto.2)
                    ASSERT (result = PONYC.RESULT.ALLOC.OK)
                    C.trace ("commstest: alloc cli.eoi.sproto.2.return...")
                    CLAIM net.handle!
                      SEQ
                        pony.alloc.uc (net.handle, "thing.eoi.sproto.2.return", PONYC.SHARETYPE.UNSHARED, cli.eoi.sproto.2.return, result)
                    C.trace.i ("commstest: ... done, alloc result: ", result)
                    ASSERT (DEFINED cli.eoi.sproto.2.return)
                    ASSERT (result = PONYC.RESULT.ALLOC.OK)
                    --}}}
                    C.trace ("commstest: output chantype.eoi.sproto.2...")
                    #IF DEFINED (TEST.CANCEL)
                    C.trace ("commstest: ... output dummy INT...")
                    cli.eoi.sproto.2[int] ! 88
                    C.trace ("commstest: ... dummy INT outputted ...")
                    #ENDIF
                    cli.eoi.sproto.2[chantype.eoi.sproto.2] ! cli.eoi.sproto.2; 67890
                    C.trace ("commstest: ... done")
                    C.trace ("commstest: input chantype.eoi.sproto.2 back...")
                    cli.eoi.sproto.2.return[chantype.eoi.sproto.2.return] ? cli.eoi.sproto.2
                    C.trace ("commstest: ... done")
                    C.trace ("commstest: ... outputting 888 to returned chantype.eoi.sproto.2...")
                    cli.eoi.sproto.2[int] ! 888
                    C.trace ("commstest: ... output done")
                  #ENDIF
                  --}}}

                  C.trace ("commstest: slave done")
              --}}}
              ELSE
                STOP
            CHAN BOOL sync:
            PAR
              --{{{  Shutdown
              SEQ
                C.trace ("commstest: calling shutdown process")
                CLAIM net.handle
                  pony.shutdown (net.handle)
                C.trace ("commstest: shutdown process done")
                sync ! TRUE
              --}}}
              --{{{  Errors and shutdown of error-handler
              TIMER tim:
              INT t, result:
              MOBILE []PONY.ERROR err.array:
              SEQ
                tim ? t
                PRI ALT
                  BOOL any:
                  sync ? any
                    C.trace ("commstest: shutdown sync")
                  tim ? AFTER t PLUS 10000000
                    C.trace ("commstest: shutdown timeout")
                C.trace ("commstest: getting errors after initial error-point...")
                INITIAL MOBILE []INT null.int.array IS MOBILE [0]INT:
                pony.err.get.errs.after (err.handle, err.point,
                                         TRUE, TRUE, TRUE, null.int.array,
                                         err.array, result)
                C.trace.i ("commstest: ... done, number of errors: ", SIZE err.array)
                #IF FALSE
                CLAIM scr!
                  SEQ i = 0 FOR (SIZE err.array)
                    SEQ
                      out.string ("commstest: error: ans.concerned:         ", 0, scr!)
                      out.bool (err.array[i][ans.concerned], 0, scr!)
                      out.string ("*n                master.concerned:      ", 0, scr!)
                      out.bool (err.array[i][master.concerned], 0, scr!)
                      out.string ("*n                remote.node.concerned: ", 0, scr!)
                      out.bool (err.array[i][remote.node.concerned], 0, scr!)
                      out.string ("*n                remote.node.id:        ", 0, scr!)
                      out.int (err.array[i][remote.node.id], 0, scr!)
                      out.string ("*n                err.code:              ", 0, scr!)
                      out.int (err.array[i][err.code], 0, scr!)
                      out.string ("*n", 0, scr!)
                #ENDIF
                C.trace ("commstest: shutting down error-handler")
                pony.err.shutdown (err.handle)
                C.trace ("commstest: error-handler shutdown finished")
              --}}}
      TRUE
        SKIP
    --{{{  Exit message
    C.trace ("commstest: Finished! :)")
    --}}}
:

