--
--	sockudpserv.occ - UDP server
--	Copyright (C) 2000 Fred Barnes <frmb2@ukc.ac.uk>
--
--	This program is free software; you can redistribute it and/or modify
--	it under the terms of the GNU General Public License as published by
--	the Free Software Foundation; either version 2 of the License, or
--	(at your option) any later version.
--
--	This program is distributed in the hope that it will be useful,
--	but WITHOUT ANY WARRANTY; without even the implied warranty of
--	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--	GNU General Public License for more details.
--
--	You should have received a copy of the GNU General Public License
--	along with this program; if not, write to the Free Software
--	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
--

#INCLUDE "sock.module"
#INCLUDE "course.module"


--{{{  PROC sock.udp.serv (CHAN OF BYTE kyb, scr, err)
PROC sock.udp.serv (CHAN OF BYTE kyb, scr, err)

  --{{{  config constants
  VAL listen.addr IS INADDR.ANY:
  VAL listen.port IS 6969:
  --}}}  

  --{{{  constants
  VAL max.message.size IS 64:
  VAL msg.x IS 2:
  VAL msg.y IS 2:
  VAL err.x IS 2:
  VAL err.y IS 3:
  VAL []BYTE recvfrom.err IS "socket.recvfrom () failed":
  --}}}  

  --{{{  PROC udp.receiver (SOCKET sock, CHAN OF BYTE out)
  PROC udp.receiver (SOCKET sock, CHAN OF BYTE out)
    [max.message.size]BYTE buffer:
    INITIAL INT msg.len IS 1:
    WHILE msg.len > 0
      SEQ
        socket.recvfrom (sock, buffer, 0, msg.len)
        IF
          msg.len > 0
            [128]BYTE hostname:
            [16]BYTE ip.addr:
            INT host.len, ip.len, res:
            SEQ
              socket.host.of.addr (sock[remote.addr], hostname, host.len, res)
              IF
                res < 0
                  [hostname FOR 7], host.len := "unknown", 7
                TRUE
                  SKIP
              socket.ip.of.addr (sock[remote.addr], ip.addr, ip.len, res)
              IF
                res < 0
                  [ip.addr FOR 7], ip.len := "?.?.?.?", 7
                TRUE
                  SKIP
              cursor.x.y (BYTE msg.x, BYTE msg.y, out)
              erase.eol (out)
              cursor.x.y (BYTE msg.x, BYTE msg.y, out)
              out ! '['
              out.string ([buffer FOR msg.len], 0, out)
              out.string ("] from ", 0, out)
              out.string ([hostname FOR host.len], 0, out)
              out.string (" (", 0, out)
              out.string ([ip.addr FOR ip.len], 0, out)
              out.string (")*n", 0, out)
              out ! FLUSH
          TRUE
            SEQ
              cursor.x.y (BYTE err.x, BYTE err.y, out)
              erase.eol (out)
              cursor.x.y (BYTE err.x, BYTE err.y, out)
              out.string (recvfrom.err, 0, out)
              out ! '*n'
              out ! FLUSH
  :
  --}}}  

  --{{{  start here
  INT res:
  SOCKET sock:
  SEQ
    socket.create.listen.udp (sock, listen.addr, listen.port, res)
    IF
      res < 0
        SEQ
          out.string ("Unable to create or bind socket*n", 0, scr)
          STOP
      TRUE
        SKIP
    erase.screen (scr)
    scr ! FLUSH
    udp.receiver (sock, scr)
    socket.close (sock)
  --}}}  

:
--}}}  


