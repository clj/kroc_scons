#INCLUDE "occSDL.module"
#INCLUDE "occSDLsound.module"
#INCLUDE "course.module"

PROC Check.SDL.Init(VAL INT result, CHAN BYTE scr!)
  VAL INT err.const IS 100:
  [err.const]BYTE err.str:
  INT err.len:
  SEQ
    IF
      result <> 0
        SEQ
          out.string("SDLInit suffered a boobie*c*n", 0, scr!)
          occ.SDL.GetError(err.str, err.const, err.len)
          out.string([err.str FOR err.len], 0, scr!)
          scr ! '*n'
          STOP
      TRUE
        SKIP
:

PROC Check.Sound.Init(VAL INT result, CHAN BYTE scr!)
  VAL INT err.const IS 100:
  [err.const]BYTE err.str:
  INT err.len:
  SEQ
    IF
      -- SoundInit returns a 0 if there is an error.
      result = 0
        SEQ
          out.string("SoundInit suffered a boobie*c*n", 0, scr!)
          occ.Sound.GetError(err.str, err.const, err.len)
          out.string([err.str FOR err.len], 0, scr!)
          scr ! '*n'
          STOP
      TRUE
        SKIP
:


PROC getsoundinfo(CHAN BYTE scr!)
  Sound.DecoderInfo info:
  SEQ
    create.Sound.DecoderInfo(info)
    Sound.AvailableDecoders(info)
    delete.Sound.DecoderInfo(info)
:
-- {{{ playSound 
--     This proc plays the file called "play.mp3"
-- It stops at some point, when it runs out of buffer space
-- for a reason that is currently unknown to me.
PROC playSound(CHAN BYTE scr!)
  Sound.Sample sample:
  Sound.AudioInfo sample.info:
  SDL.AudioSpec devformat:
  INITIAL SDL.AudioSpec actual.format IS 0: -- NULL
  INT16 format:
  BYTE channels:
  INT rate, callback.ptr, result:
  INITIAL Sound.AudioInfo info IS 0: -- NULL
  INITIAL INT buffersize IS 1024:
  INITIAL [9]BYTE name IS "play.mp3*#00":
  SEQ
    out.string("Loading File*c*n", 0, scr!)
    -- The third param needs to be NULL!!
    Sound.NewSampleFromFile (sample, name, info, buffersize)
    out.string("Got sample*c*n", 0, scr!)
    Sound.DecodeAll (result, sample)
    out.string("Decode Done*c*n", 0, scr!)

    -- {{{ Set up the audio device 
    -- Get sample info
    get.Sound.Sample.actual(sample.info, sample)
    -- The size of the entire file...
    get.Sound.Sample.buffer.size(buffersize, sample)
    get.Sound.AudioInfo.format(format, sample.info)
    get.Sound.AudioInfo.channels(channels, sample.info)
    get.Sound.AudioInfo.rate(rate, sample.info)
    -- Get pointer to the callback function
    get.audio.callback.ptr(callback.ptr)
    -- Create and setup structure for audio init
    create.SDL.AudioSpec(devformat)
    set.SDL.AudioSpec.format(format, devformat)
    set.SDL.AudioSpec.channels(channels, devformat)
    set.SDL.AudioSpec.freq(rate, devformat)
    -- buffer size in nr of samples, buffersize is nr of 8bit samples
    -- so assuming 16bit sample size it should be over 2.
    set.SDL.AudioSpec.samples(4096, devformat) -- A largeish buffer.
    set.SDL.AudioSpec.callback(callback.ptr, devformat) -- The callback func
    set.SDL.AudioSpec.userdata((INT sample), devformat) -- The sound data
    -- Initialize the audio device.
    SDL.OpenAudio(result, devformat, actual.format)
    -- }}}   
    out.string("Now Playing*c*n", 0, scr!)
    -- Since the audio is automatically paused on start, de-pause it.
    SDL.PauseAudio(0)
    INITIAL INT status IS 0:
    WHILE status = 0
      INT t:
      TIMER tim:
      SEQ
        tim ? t
        check.if.done.playing(status) -- will return non-zero when done
        tim ? AFTER t PLUS 2000
    -- When we are done, re-pause it.
    SDL.PauseAudio(1)
    out.string("Done*c*n", 0, scr!)
    Sound.FreeSample (sample)
    out.string("Freed*c*n", 0, scr!)
:

PROC sndtest (CHAN BYTE kyb?, scr!, err!)
  INT result:
  SEQ
    SDL.Init(result, 0)
    Check.SDL.Init(result, scr!)
    Sound.Init(result)
    Check.Sound.Init(result, scr!)
    getsoundinfo(scr!)
    playSound(scr!)
    out.string("Quitting Sound*c*n", 0, scr!)
    Sound.Quit(result)
    out.string("Quitting*c*n", 0, scr!)
    SDL.Quit()
:
        
