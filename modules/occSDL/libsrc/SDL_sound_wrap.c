/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.31
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#include "SDL_sound_wrap.h"
/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC)
#   if (__SUNPRO_CC <= 0x560)
#     define SWIGTEMPLATEDISAMBIGUATOR template
#   else
#     define SWIGTEMPLATEDISAMBIGUATOR 
#   endif
# else
#   define SWIGTEMPLATEDISAMBIGUATOR 
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/*{{{  struct Sound_AudioInfo */
/*{{{  function Sound_AudioInfo_format_set */
SWIGEXPORT void _Sound_AudioInfo_format_set (word occ_args[]) {
  Sound_AudioInfo *arg1 = (Sound_AudioInfo *) 0 ;
  Uint16 arg2 ;
  
  {
    arg1 = (Sound_AudioInfo *) occ_args[0]; 
  }{
    arg2 = (Uint16) occ_args[1]; 
  }if (arg1) (arg1)->format = arg2;
  
}


/*}}}*/
/*{{{  function Sound_AudioInfo_format_get */
SWIGEXPORT void _Sound_AudioInfo_format_get (word occ_args[]) {
  Sound_AudioInfo *arg1 = (Sound_AudioInfo *) 0 ;
  Uint16 result;
  
  {
    arg1 = (Sound_AudioInfo *) occ_args[0]; 
  }result = (Uint16) ((arg1)->format);
  {
    *((Uint16 *) occ_args[1]) = result; 
  }
}


/*}}}*/
/*{{{  function Sound_AudioInfo_channels_set */
SWIGEXPORT void _Sound_AudioInfo_channels_set (word occ_args[]) {
  Sound_AudioInfo *arg1 = (Sound_AudioInfo *) 0 ;
  Uint8 arg2 ;
  
  {
    arg1 = (Sound_AudioInfo *) occ_args[0]; 
  }{
    arg2 = (Uint8) occ_args[1]; 
  }if (arg1) (arg1)->channels = arg2;
  
}


/*}}}*/
/*{{{  function Sound_AudioInfo_channels_get */
SWIGEXPORT void _Sound_AudioInfo_channels_get (word occ_args[]) {
  Sound_AudioInfo *arg1 = (Sound_AudioInfo *) 0 ;
  Uint8 result;
  
  {
    arg1 = (Sound_AudioInfo *) occ_args[0]; 
  }result = (Uint8) ((arg1)->channels);
  {
    *((Uint8 *) occ_args[1]) = result; 
  }
}


/*}}}*/
/*{{{  function Sound_AudioInfo_rate_set */
SWIGEXPORT void _Sound_AudioInfo_rate_set (word occ_args[]) {
  Sound_AudioInfo *arg1 = (Sound_AudioInfo *) 0 ;
  Uint32 arg2 ;
  
  {
    arg1 = (Sound_AudioInfo *) occ_args[0]; 
  }{
    arg2 = (Uint32) occ_args[1]; 
  }if (arg1) (arg1)->rate = arg2;
  
}


/*}}}*/
/*{{{  function Sound_AudioInfo_rate_get */
SWIGEXPORT void _Sound_AudioInfo_rate_get (word occ_args[]) {
  Sound_AudioInfo *arg1 = (Sound_AudioInfo *) 0 ;
  Uint32 result;
  
  {
    arg1 = (Sound_AudioInfo *) occ_args[0]; 
  }result = (Uint32) ((arg1)->rate);
  {
    *((Uint32 *) occ_args[1]) = result; 
  }
}


/*}}}*/
/*{{{  function new_Sound_AudioInfo */
SWIGEXPORT void _new_Sound_AudioInfo (word occ_args[]) {
  Sound_AudioInfo *result = 0 ;
  
  result = (Sound_AudioInfo *)(Sound_AudioInfo *) calloc(1, sizeof(Sound_AudioInfo));
  {
    *((void **) occ_args[0]) = result; 
  }
}


/*}}}*/
/*{{{  function delete_Sound_AudioInfo */
SWIGEXPORT void _delete_Sound_AudioInfo (word occ_args[]) {
  Sound_AudioInfo *arg1 = (Sound_AudioInfo *) 0 ;
  
  {
    arg1 = (Sound_AudioInfo *) occ_args[0]; 
  }free((char *) arg1);
  
}


/*}}}*/
/*}}}*/
/*{{{  struct Sound_DecoderInfo */
/*{{{  function Sound_DecoderInfo_extensions_set */
SWIGEXPORT void _Sound_DecoderInfo_extensions_set (word occ_args[]) {
  Sound_DecoderInfo *arg1 = (Sound_DecoderInfo *) 0 ;
  char **arg2 = (char **) 0 ;
  
  {
    arg1 = (Sound_DecoderInfo *) occ_args[0]; 
  }{
    arg2 = (char **) occ_args[1]; 
  }if (arg1) (arg1)->extensions = (char const **)arg2;
  
}


/*}}}*/
/*{{{  function Sound_DecoderInfo_extensions_get */
SWIGEXPORT void _Sound_DecoderInfo_extensions_get (word occ_args[]) {
  Sound_DecoderInfo *arg1 = (Sound_DecoderInfo *) 0 ;
  char **result = 0 ;
  
  {
    arg1 = (Sound_DecoderInfo *) occ_args[0]; 
  }result = (char **) ((arg1)->extensions);
  {
    *((void **) occ_args[1]) = result; 
  }
}


/*}}}*/
/*{{{  function Sound_DecoderInfo_description_set */
SWIGEXPORT void _Sound_DecoderInfo_description_set (word occ_args[]) {
  Sound_DecoderInfo *arg1 = (Sound_DecoderInfo *) 0 ;
  char *arg2 = (char *) 0 ;
  
  {
    arg1 = (Sound_DecoderInfo *) occ_args[0]; 
  }{
    arg2 = (char *) occ_args[1]; 
  }{
    if (arg2) {
      arg1->description = (char const *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->description, (const char *)arg2);
    } else {
      arg1->description = 0;
    }
  }
}


/*}}}*/
/*{{{  function Sound_DecoderInfo_description_get */
SWIGEXPORT void _Sound_DecoderInfo_description_get (word occ_args[]) {
  Sound_DecoderInfo *arg1 = (Sound_DecoderInfo *) 0 ;
  char *result = 0 ;
  
  {
    arg1 = (Sound_DecoderInfo *) occ_args[0]; 
  }result = (char *) ((arg1)->description);
  {
    *((void **) occ_args[1]) = result; 
  }
}


/*}}}*/
/*{{{  function Sound_DecoderInfo_author_set */
SWIGEXPORT void _Sound_DecoderInfo_author_set (word occ_args[]) {
  Sound_DecoderInfo *arg1 = (Sound_DecoderInfo *) 0 ;
  char *arg2 = (char *) 0 ;
  
  {
    arg1 = (Sound_DecoderInfo *) occ_args[0]; 
  }{
    arg2 = (char *) occ_args[1]; 
  }{
    if (arg2) {
      arg1->author = (char const *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->author, (const char *)arg2);
    } else {
      arg1->author = 0;
    }
  }
}


/*}}}*/
/*{{{  function Sound_DecoderInfo_author_get */
SWIGEXPORT void _Sound_DecoderInfo_author_get (word occ_args[]) {
  Sound_DecoderInfo *arg1 = (Sound_DecoderInfo *) 0 ;
  char *result = 0 ;
  
  {
    arg1 = (Sound_DecoderInfo *) occ_args[0]; 
  }result = (char *) ((arg1)->author);
  {
    *((void **) occ_args[1]) = result; 
  }
}


/*}}}*/
/*{{{  function Sound_DecoderInfo_url_set */
SWIGEXPORT void _Sound_DecoderInfo_url_set (word occ_args[]) {
  Sound_DecoderInfo *arg1 = (Sound_DecoderInfo *) 0 ;
  char *arg2 = (char *) 0 ;
  
  {
    arg1 = (Sound_DecoderInfo *) occ_args[0]; 
  }{
    arg2 = (char *) occ_args[1]; 
  }{
    if (arg2) {
      arg1->url = (char const *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->url, (const char *)arg2);
    } else {
      arg1->url = 0;
    }
  }
}


/*}}}*/
/*{{{  function Sound_DecoderInfo_url_get */
SWIGEXPORT void _Sound_DecoderInfo_url_get (word occ_args[]) {
  Sound_DecoderInfo *arg1 = (Sound_DecoderInfo *) 0 ;
  char *result = 0 ;
  
  {
    arg1 = (Sound_DecoderInfo *) occ_args[0]; 
  }result = (char *) ((arg1)->url);
  {
    *((void **) occ_args[1]) = result; 
  }
}


/*}}}*/
/*{{{  function new_Sound_DecoderInfo */
SWIGEXPORT void _new_Sound_DecoderInfo (word occ_args[]) {
  Sound_DecoderInfo *result = 0 ;
  
  result = (Sound_DecoderInfo *)(Sound_DecoderInfo *) calloc(1, sizeof(Sound_DecoderInfo));
  {
    *((void **) occ_args[0]) = result; 
  }
}


/*}}}*/
/*{{{  function delete_Sound_DecoderInfo */
SWIGEXPORT void _delete_Sound_DecoderInfo (word occ_args[]) {
  Sound_DecoderInfo *arg1 = (Sound_DecoderInfo *) 0 ;
  
  {
    arg1 = (Sound_DecoderInfo *) occ_args[0]; 
  }free((char *) arg1);
  
}


/*}}}*/
/*}}}*/
/*{{{  struct Sound_Sample */
/*{{{  function Sound_Sample_decoder_set */
SWIGEXPORT void _Sound_Sample_decoder_set (word occ_args[]) {
  Sound_Sample *arg1 = (Sound_Sample *) 0 ;
  Sound_DecoderInfo *arg2 = (Sound_DecoderInfo *) 0 ;
  
  {
    arg1 = (Sound_Sample *) occ_args[0]; 
  }{
    arg2 = (Sound_DecoderInfo *) occ_args[1]; 
  }if (arg1) (arg1)->decoder = arg2;
  
}


/*}}}*/
/*{{{  function Sound_Sample_decoder_get */
SWIGEXPORT void _Sound_Sample_decoder_get (word occ_args[]) {
  Sound_Sample *arg1 = (Sound_Sample *) 0 ;
  Sound_DecoderInfo *result = 0 ;
  
  {
    arg1 = (Sound_Sample *) occ_args[0]; 
  }result = (Sound_DecoderInfo *) ((arg1)->decoder);
  {
    *((void **) occ_args[1]) = result; 
  }
}


/*}}}*/
/*{{{  function Sound_Sample_desired_set */
SWIGEXPORT void _Sound_Sample_desired_set (word occ_args[]) {
  Sound_Sample *arg1 = (Sound_Sample *) 0 ;
  Sound_AudioInfo *arg2 = (Sound_AudioInfo *) 0 ;
  
  {
    arg1 = (Sound_Sample *) occ_args[0]; 
  }{
    arg2 = (Sound_AudioInfo *) occ_args[1]; 
  }if (arg1) (arg1)->desired = *arg2;
  
}


/*}}}*/
/*{{{  function Sound_Sample_desired_get */
SWIGEXPORT void _Sound_Sample_desired_get (word occ_args[]) {
  Sound_Sample *arg1 = (Sound_Sample *) 0 ;
  Sound_AudioInfo *result = 0 ;
  
  {
    arg1 = (Sound_Sample *) occ_args[0]; 
  }result = (Sound_AudioInfo *)& ((arg1)->desired);
  {
    *((void **) occ_args[1]) = result; 
  }
}


/*}}}*/
/*{{{  function Sound_Sample_actual_set */
SWIGEXPORT void _Sound_Sample_actual_set (word occ_args[]) {
  Sound_Sample *arg1 = (Sound_Sample *) 0 ;
  Sound_AudioInfo *arg2 = (Sound_AudioInfo *) 0 ;
  
  {
    arg1 = (Sound_Sample *) occ_args[0]; 
  }{
    arg2 = (Sound_AudioInfo *) occ_args[1]; 
  }if (arg1) (arg1)->actual = *arg2;
  
}


/*}}}*/
/*{{{  function Sound_Sample_actual_get */
SWIGEXPORT void _Sound_Sample_actual_get (word occ_args[]) {
  Sound_Sample *arg1 = (Sound_Sample *) 0 ;
  Sound_AudioInfo *result = 0 ;
  
  {
    arg1 = (Sound_Sample *) occ_args[0]; 
  }result = (Sound_AudioInfo *)& ((arg1)->actual);
  {
    *((void **) occ_args[1]) = result; 
  }
}


/*}}}*/
/*{{{  function Sound_Sample_buffer_set */
SWIGEXPORT void _Sound_Sample_buffer_set (word occ_args[]) {
  Sound_Sample *arg1 = (Sound_Sample *) 0 ;
  void *arg2 = (void *) 0 ;
  
  {
    arg1 = (Sound_Sample *) occ_args[0]; 
  }{
    arg2 = (void *) occ_args[1]; 
  }if (arg1) (arg1)->buffer = arg2;
  
}


/*}}}*/
/*{{{  function Sound_Sample_buffer_get */
SWIGEXPORT void _Sound_Sample_buffer_get (word occ_args[]) {
  Sound_Sample *arg1 = (Sound_Sample *) 0 ;
  void *result = 0 ;
  
  {
    arg1 = (Sound_Sample *) occ_args[0]; 
  }result = (void *) ((arg1)->buffer);
  {
    *((void * *) occ_args[1]) = result; 
  }
}


/*}}}*/
/*{{{  function Sound_Sample_buffer_size_set */
SWIGEXPORT void _Sound_Sample_buffer_size_set (word occ_args[]) {
  Sound_Sample *arg1 = (Sound_Sample *) 0 ;
  Uint32 arg2 ;
  
  {
    arg1 = (Sound_Sample *) occ_args[0]; 
  }{
    arg2 = (Uint32) occ_args[1]; 
  }if (arg1) (arg1)->buffer_size = arg2;
  
}


/*}}}*/
/*{{{  function Sound_Sample_buffer_size_get */
SWIGEXPORT void _Sound_Sample_buffer_size_get (word occ_args[]) {
  Sound_Sample *arg1 = (Sound_Sample *) 0 ;
  Uint32 result;
  
  {
    arg1 = (Sound_Sample *) occ_args[0]; 
  }result = (Uint32) ((arg1)->buffer_size);
  {
    *((Uint32 *) occ_args[1]) = result; 
  }
}


/*}}}*/
/*{{{  function Sound_Sample_flags_set */
SWIGEXPORT void _Sound_Sample_flags_set (word occ_args[]) {
  Sound_Sample *arg1 = (Sound_Sample *) 0 ;
  Sound_SampleFlags arg2 ;
  
  {
    arg1 = (Sound_Sample *) occ_args[0]; 
  }{
    arg2 = (Sound_SampleFlags) occ_args[1]; 
  }if (arg1) (arg1)->flags = arg2;
  
}


/*}}}*/
/*{{{  function Sound_Sample_flags_get */
SWIGEXPORT void _Sound_Sample_flags_get (word occ_args[]) {
  Sound_Sample *arg1 = (Sound_Sample *) 0 ;
  Sound_SampleFlags result;
  
  {
    arg1 = (Sound_Sample *) occ_args[0]; 
  }result = (Sound_SampleFlags) ((arg1)->flags);
  {
    *((Sound_SampleFlags *) occ_args[1]) = result; 
  }
}


/*}}}*/
/*{{{  function new_Sound_Sample */
SWIGEXPORT void _new_Sound_Sample (word occ_args[]) {
  Sound_Sample *result = 0 ;
  
  result = (Sound_Sample *)(Sound_Sample *) calloc(1, sizeof(Sound_Sample));
  {
    *((void **) occ_args[0]) = result; 
  }
}


/*}}}*/
/*{{{  function delete_Sound_Sample */
SWIGEXPORT void _delete_Sound_Sample (word occ_args[]) {
  Sound_Sample *arg1 = (Sound_Sample *) 0 ;
  
  {
    arg1 = (Sound_Sample *) occ_args[0]; 
  }free((char *) arg1);
  
}


/*}}}*/
/*}}}*/
/*{{{  struct Sound_Version */
/*{{{  function Sound_Version_major_set */
SWIGEXPORT void _Sound_Version_major_set (word occ_args[]) {
  Sound_Version *arg1 = (Sound_Version *) 0 ;
  int arg2 ;
  
  {
    arg1 = (Sound_Version *) occ_args[0]; 
  }{
    arg2 = (int) occ_args[1]; 
  }if (arg1) (arg1)->major = arg2;
  
}


/*}}}*/
/*{{{  function Sound_Version_major_get */
SWIGEXPORT void _Sound_Version_major_get (word occ_args[]) {
  Sound_Version *arg1 = (Sound_Version *) 0 ;
  int result;
  
  {
    arg1 = (Sound_Version *) occ_args[0]; 
  }result = (int) ((arg1)->major);
  {
    *((int *) occ_args[1]) = result; 
  }
}


/*}}}*/
/*{{{  function Sound_Version_minor_set */
SWIGEXPORT void _Sound_Version_minor_set (word occ_args[]) {
  Sound_Version *arg1 = (Sound_Version *) 0 ;
  int arg2 ;
  
  {
    arg1 = (Sound_Version *) occ_args[0]; 
  }{
    arg2 = (int) occ_args[1]; 
  }if (arg1) (arg1)->minor = arg2;
  
}


/*}}}*/
/*{{{  function Sound_Version_minor_get */
SWIGEXPORT void _Sound_Version_minor_get (word occ_args[]) {
  Sound_Version *arg1 = (Sound_Version *) 0 ;
  int result;
  
  {
    arg1 = (Sound_Version *) occ_args[0]; 
  }result = (int) ((arg1)->minor);
  {
    *((int *) occ_args[1]) = result; 
  }
}


/*}}}*/
/*{{{  function Sound_Version_patch_set */
SWIGEXPORT void _Sound_Version_patch_set (word occ_args[]) {
  Sound_Version *arg1 = (Sound_Version *) 0 ;
  int arg2 ;
  
  {
    arg1 = (Sound_Version *) occ_args[0]; 
  }{
    arg2 = (int) occ_args[1]; 
  }if (arg1) (arg1)->patch = arg2;
  
}


/*}}}*/
/*{{{  function Sound_Version_patch_get */
SWIGEXPORT void _Sound_Version_patch_get (word occ_args[]) {
  Sound_Version *arg1 = (Sound_Version *) 0 ;
  int result;
  
  {
    arg1 = (Sound_Version *) occ_args[0]; 
  }result = (int) ((arg1)->patch);
  {
    *((int *) occ_args[1]) = result; 
  }
}


/*}}}*/
/*{{{  function new_Sound_Version */
SWIGEXPORT void _new_Sound_Version (word occ_args[]) {
  Sound_Version *result = 0 ;
  
  result = (Sound_Version *)(Sound_Version *) calloc(1, sizeof(Sound_Version));
  {
    *((void **) occ_args[0]) = result; 
  }
}


/*}}}*/
/*{{{  function delete_Sound_Version */
SWIGEXPORT void _delete_Sound_Version (word occ_args[]) {
  Sound_Version *arg1 = (Sound_Version *) 0 ;
  
  {
    arg1 = (Sound_Version *) occ_args[0]; 
  }free((char *) arg1);
  
}


/*}}}*/
/*}}}*/
/*{{{  function Sound_GetLinkedVersion */
SWIGEXPORT void _Sound_GetLinkedVersion (word occ_args[]) {
  Sound_Version *arg1 = (Sound_Version *) 0 ;
  
  {
    arg1 = (Sound_Version *) occ_args[0]; 
  }Sound_GetLinkedVersion(arg1);
}


/*}}}*/
/*{{{  function Sound_Init */
SWIGEXPORT void _Sound_Init (word occ_args[]) {
  int result;
  
  result = (int)Sound_Init();
  {
    *((int *) occ_args[0]) = result; 
  }
}


/*}}}*/
/*{{{  function Sound_Quit */
SWIGEXPORT void _Sound_Quit (word occ_args[]) {
  int result;
  
  result = (int)Sound_Quit();
  {
    *((int *) occ_args[0]) = result; 
  }
}


/*}}}*/
/*{{{  function Sound_AvailableDecoders */
SWIGEXPORT void _Sound_AvailableDecoders (word occ_args[]) {
  Sound_DecoderInfo **result = 0 ;
  
  result = (Sound_DecoderInfo **)Sound_AvailableDecoders();
  {
    *((void **) occ_args[0]) = result; 
  }
}


/*}}}*/
/*{{{  function Sound_GetError */
SWIGEXPORT void _Sound_GetError (word occ_args[]) {
  char *result = 0 ;
  
  result = (char *)Sound_GetError();
  {
    *((void **) occ_args[0]) = result; 
  }
}


/*}}}*/

inline static int occ_Sound_GetError(char err_str[], int err_str_len) {
        const char *err = Sound_GetError();

        int len = 0;
        while (len < err_str_len && err[len] != '\0') {
                err_str[len] = err[len];
                len++;
        }

        return len;
}

/*{{{  function occ_Sound_GetError */
SWIGEXPORT void _occ_Sound_GetError (word occ_args[]) {
  char *arg1 ;
  int arg2 ;
  int result;
  
  {
    arg1 = (char *) occ_args[0]; 
  }{
    arg2 = (int) occ_args[2]; 
  }result = (int)occ_Sound_GetError(arg1,arg2);
  {
    *((int *) occ_args[3]) = result; 
  }
}


/*}}}*/
/*{{{  function Sound_ClearError */
SWIGEXPORT void _Sound_ClearError (word occ_args[]) {
  Sound_ClearError();
}


/*}}}*/
/*{{{  function Sound_NewSample */
SWIGEXPORT void _Sound_NewSample (word occ_args[]) {
  SDL_RWops *arg1 = (SDL_RWops *) 0 ;
  char *arg2 ;
  Sound_AudioInfo *arg3 = (Sound_AudioInfo *) 0 ;
  Uint32 arg4 ;
  Sound_Sample *result = 0 ;
  
  {
    arg1 = (SDL_RWops *) occ_args[0]; 
  }{
    arg2 = (char *) occ_args[1]; 
  }{
    arg3 = (Sound_AudioInfo *) occ_args[3]; 
  }{
    arg4 = (Uint32) occ_args[4]; 
  }result = (Sound_Sample *)Sound_NewSample(arg1,(char const (*))arg2,arg3,arg4);
  {
    *((void **) occ_args[5]) = result; 
  }
}


/*}}}*/
/*{{{  function Sound_NewSampleFromFile */
SWIGEXPORT void _Sound_NewSampleFromFile (word occ_args[]) {
  char *arg1 ;
  Sound_AudioInfo *arg2 = (Sound_AudioInfo *) 0 ;
  Uint32 arg3 ;
  Sound_Sample *result = 0 ;
  
  {
    arg1 = (char *) occ_args[0]; 
  }{
    arg2 = (Sound_AudioInfo *) occ_args[2]; 
  }{
    arg3 = (Uint32) occ_args[3]; 
  }result = (Sound_Sample *)Sound_NewSampleFromFile((char const (*))arg1,arg2,arg3);
  {
    *((void **) occ_args[4]) = result; 
  }
}


/*}}}*/
/*{{{  function Sound_FreeSample */
SWIGEXPORT void _Sound_FreeSample (word occ_args[]) {
  Sound_Sample *arg1 = (Sound_Sample *) 0 ;
  
  {
    arg1 = (Sound_Sample *) occ_args[0]; 
  }Sound_FreeSample(arg1);
}


/*}}}*/
/*{{{  function Sound_SetBufferSize */
SWIGEXPORT void _Sound_SetBufferSize (word occ_args[]) {
  Sound_Sample *arg1 = (Sound_Sample *) 0 ;
  Uint32 arg2 ;
  int result;
  
  {
    arg1 = (Sound_Sample *) occ_args[0]; 
  }{
    arg2 = (Uint32) occ_args[1]; 
  }result = (int)Sound_SetBufferSize(arg1,arg2);
  {
    *((int *) occ_args[2]) = result; 
  }
}


/*}}}*/
/*{{{  function Sound_Decode */
SWIGEXPORT void _Sound_Decode (word occ_args[]) {
  Sound_Sample *arg1 = (Sound_Sample *) 0 ;
  Uint32 result;
  
  {
    arg1 = (Sound_Sample *) occ_args[0]; 
  }result = (Uint32)Sound_Decode(arg1);
  {
    *((Uint32 *) occ_args[1]) = result; 
  }
}


/*}}}*/
/*{{{  function Sound_DecodeAll */
SWIGEXPORT void _Sound_DecodeAll (word occ_args[]) {
  Sound_Sample *arg1 = (Sound_Sample *) 0 ;
  Uint32 result;
  
  {
    arg1 = (Sound_Sample *) occ_args[0]; 
  }result = (Uint32)Sound_DecodeAll(arg1);
  {
    *((Uint32 *) occ_args[1]) = result; 
  }
}


/*}}}*/
/*{{{  function Sound_Rewind */
SWIGEXPORT void _Sound_Rewind (word occ_args[]) {
  Sound_Sample *arg1 = (Sound_Sample *) 0 ;
  int result;
  
  {
    arg1 = (Sound_Sample *) occ_args[0]; 
  }result = (int)Sound_Rewind(arg1);
  {
    *((int *) occ_args[1]) = result; 
  }
}


/*}}}*/
/*{{{  function Sound_Seek */
SWIGEXPORT void _Sound_Seek (word occ_args[]) {
  Sound_Sample *arg1 = (Sound_Sample *) 0 ;
  Uint32 arg2 ;
  int result;
  
  {
    arg1 = (Sound_Sample *) occ_args[0]; 
  }{
    arg2 = (Uint32) occ_args[1]; 
  }result = (int)Sound_Seek(arg1,arg2);
  {
    *((int *) occ_args[2]) = result; 
  }
}


/*}}}*/

/* Global flag determining decode status */
static volatile int global_done_flag = 0;
/*
 * The audio callback. SDL calls this frequently to feed the audio device.
 *  We decode the audio file being played in here in small chunks and feed
 *  the device as necessary. Other solutions may want to predecode more
 *  (or all) of the file, since this needs to run fast and frequently,
 *  but since we're only sitting here and waiting for the file to play,
 *  the only real requirement is that we can decode a given audio file
 *  faster than realtime, which isn't really a problem with any modern format
 *  on even pretty old hardware at this point.
 */
/* Global decode state 
   decoded_ptr is a pointer to where we currently are in the data
   decoded_bytes is the number of bytes left to decode (so kind of misnamed) 
   the first_time flag is set to 1 if it is not the first time this callback
   is being called. */
Uint8 *decoded_ptr = 0;
Uint32 decoded_bytes = 0;
Uint8 first_time = 0; 

static void audio_callback(void *userdata, Uint8 *stream, int len)
{
   Sound_Sample *sample = (Sound_Sample *) userdata;
   int remaining;
   if(first_time == 0) {  /* First entry into function */
     decoded_ptr = sample->buffer;
     decoded_bytes = sample->buffer_size;
     //printf("First Call of callback: buffer_size %i, len %i  \n", decoded_bytes, len);
     first_time = 1;
   }

   if (decoded_bytes == 0)
   {
     //printf("Done\n");
     /* ...there isn't any more data to read! */
     memset(stream, '\0', len);  /* write silence. */
     global_done_flag = 1;
     return;  /* we're done playback, one way or another. */
   } /* if */
   
   /* Check if we have enough remaining */
   remaining = decoded_bytes - len;
   if(remaining < 0) /* Running out of sound to write */
   {
     //printf("Last few bytes\n");
     /* write this last data to the device. */
     memcpy(stream, (Uint8 *) decoded_ptr, decoded_bytes);
     /* Pad remainder with silence */
     /* Reset state for next file to play - RACE Condition 
        This function will be called a number of times before
        we catch on that its done.  Have to figure out a 
        better way to reset first time so we can play another
        sample.  Well, so that we can play more than one sample
        at a time would be nice too...*/
     //first_time = 0; 
     decoded_ptr = 0;
     decoded_bytes = 0;
   } else {
     //printf("Next load of data %i\n", decoded_bytes);
     /* Copy data to sound device */
     memcpy(stream, (Uint8 *) decoded_ptr, len);
     /* update state for next callback */
     decoded_ptr += len;
     decoded_bytes -= len;
   }
} 

static void *get_audio_callback_ptr() {
    return (void *) audio_callback;
}

static int check_if_done_playing(){
  return global_done_flag;
}


/*{{{  function get_audio_callback_ptr */
SWIGEXPORT void _get_audio_callback_ptr (word occ_args[]) {
  void *result = 0 ;
  
  result = (void *)get_audio_callback_ptr();
  {
    *((void * *) occ_args[0]) = result; 
  }
}


/*}}}*/
/*{{{  function check_if_done_playing */
SWIGEXPORT void _check_if_done_playing (word occ_args[]) {
  int result;
  
  result = (int)check_if_done_playing();
  {
    *((int *) occ_args[0]) = result; 
  }
}


/*}}}*/
