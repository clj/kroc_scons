--
--	g3dchess.occ -- 3D raster graphics routines, chess pieces
--	Copyright (C) 2009 Fred Barnes <frmb@kent.ac.uk>
--
--	This program is free software; you can redistribute it and/or modify
--	it under the terms of the GNU General Public License as published by
--	the Free Software Foundation; either version 2 of the License, or
--	(at your option) any later version.
--
--	This program is distributed in the hope that it will be useful,
--	but WITHOUT ANY WARRANTY; without even the implied warranty of
--	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--	GNU General Public License for more details.
--
--	You should have received a copy of the GNU General Public License
--	along with this program; if not, write to the Free Software
--	Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
--

--** @module graphics3d

#INCLUDE "course.module"
#INCLUDE "maths.module"
#INCLUDE "sdlraster.module"
#INCLUDE "graphics3d.inc"
#INCLUDE "g3dchess.inc"
#USE "graphics3d"

--{{{  PROC chesspoints.generator (CHAN INT trigger?, VAL INT npoints, VAL [][2]REAL32 profile, CHAN MOBILE []G3D.POINT3 out!, CHAN G3D.GEN.CONTROL ctrl?)
--* Chess piece points generator.
--
-- @param trigger Trigger channel.
-- @param npoints Number of points around the outside.
-- @param piece Particular piece (defines how the topping is handled, see [@ref G3D.CP]).
-- @param profile Y/rad pairs for the piece.
-- @param out Generated points.
-- @param ctrl Control channel.
--
PROC chesspoints.generator (CHAN INT trigger?, VAL INT npoints, piece, VAL [][2]REAL32 profile, CHAN MOBILE []G3D.POINT3 out!, CHAN G3D.GEN.CONTROL ctrl?)
  MOBILE []G3D.POINT3 cpnts:
  INT npnts:

  PROC reset () --{{{
    SEQ
      npnts := (npoints * (SIZE profile)) + 2
      cpnts := MOBILE [npnts]G3D.POINT3

      SEQ v = 0 FOR SIZE profile
        VAL [2]REAL32 pp IS profile[v]:
        INITIAL INT sp IS (v * npoints):
        SEQ
          INITIAL REAL32 apt IS (PI * 2.0) / (REAL32 ROUND npoints):
          SEQ i = 0 FOR npoints
            INITIAL REAL32 aoffs IS apt * (REAL32 ROUND i):
            SEQ
              cpnts[sp + i] := [pp[1] * SIN (aoffs), pp[0], pp[1] * COS (aoffs)]

      INITIAL INT sp IS (SIZE profile) * npoints:
      SEQ
        -- last two points are the bottom and top centres
        cpnts[sp + 0] := [0.0, profile[0][0], 0.0]
        cpnts[sp + 1] := [0.0, profile[(SIZE profile) - 1][0], 0.0]
  :
  --}}}

  SEQ
    --{{{  initialise
    reset ()

    --}}}

    INITIAL BOOL running IS TRUE:
    WHILE running
      SEQ
        PRI ALT
          ctrl ? CASE
            reset --{{{
              reset ()
            --}}}
            [3]REAL32 scale:
            add.scale; scale --{{{
              SEQ
                SEQ i = 0 FOR npnts
                  SEQ
                    cpnts[i][x] := cpnts[i][x] * scale[0]
                    cpnts[i][y] := cpnts[i][y] * scale[1]
                    cpnts[i][z] := cpnts[i][z] * scale[2]
            --}}}
            [3]REAL32 scale:
            set.scale; scale --{{{
              SEQ
                reset ()
                SEQ i = 0 FOR npnts
                  SEQ
                    cpnts[i][x] := cpnts[i][x] * scale[0]
                    cpnts[i][y] := cpnts[i][y] * scale[1]
                    cpnts[i][z] := cpnts[i][z] * scale[2]
            --}}}
            [3]REAL32 trans:
            add.trans; trans --{{{
              SEQ
                SEQ i = 0 FOR npnts
                  SEQ
                    cpnts[i][x] := cpnts[i][x] + trans[0]
                    cpnts[i][y] := cpnts[i][y] + trans[1]
                    cpnts[i][z] := cpnts[i][z] + trans[2]
            --}}}
            [3]REAL32 trans:
            set.trans; trans --{{{
              SEQ
                reset ()
                SEQ i = 0 FOR npnts
                  SEQ
                    cpnts[i][x] := cpnts[i][x] + trans[0]
                    cpnts[i][y] := cpnts[i][y] + trans[1]
                    cpnts[i][z] := cpnts[i][z] + trans[2]
            --}}}
          INT any:
          trigger ? any
            out ! CLONE cpnts
:
--}}}
--{{{  PROC chessify.points (CHAN MOBILE []G3D.POINT2.3 in?, VAL INT npoints, piece, VAL [][2]REAL32 profile, CHAN MOBILE []G3D.POLY out!, CHAN G3D.PGN.CONTROL ctrl?)
--* Generates chess-style polygons from points.
--
-- @param in Points in.
-- @param npoints Number of points around the base of the object.
-- @param piece Particular piece (defines how the topping is handled, see [@ref G3D.CP]).
-- @param profile Profile for the piece.
-- @param out Polygons out.
-- @param ctrl Control channel.
--
PROC chessify.points (CHAN MOBILE []G3D.POINT2.3 in?, VAL INT npoints, piece, VAL [][2]REAL32 profile, CHAN MOBILE []G3D.POLY out!, CHAN G3D.PGN.CONTROL ctrl?)

  PROC set.poly.point (G3D.POLY p, VAL INT pi, VAL G3D.POINT2.3 pnt) --{{{
    SEQ
      p[x][pi] := pnt[x]
      p[y][pi] := pnt[y]
      p[z][pi] := pnt[z]
  :
  --}}}
  INT FUNCTION compute.poly.normal (VAL G3D.POLY poly) --{{{
    INT r:
    VALOF
      IF
        poly[npoints] = 4
          r := ((poly[y][3] MINUS poly[y][0]) TIMES (poly[x][1] MINUS poly[x][0])) MINUS
                ((poly[y][1] MINUS poly[y][0]) TIMES (poly[x][3] MINUS poly[x][0]))
        poly[npoints] = 3
          r := ((poly[y][2] MINUS poly[y][0]) TIMES (poly[x][1] MINUS poly[x][0])) MINUS
                ((poly[y][1] MINUS poly[y][0]) TIMES (poly[x][2] MINUS poly[x][0]))
        TRUE
          r := 0
      RESULT r
  :
  --}}}

  DATA TYPE PPNT IS [4]INT:

  [3]INT pixmap:
  MOBILE []PPNT polymap:
  INITIAL INT lpts IS npoints * (SIZE profile):
  INITIAL BOOL backfaces IS FALSE:
  SEQ
    --{{{  initialise
    -- need 'npoints' polygons for each side ((SIZE profile) - 1), plus 'npoints' at the top and bottom
    polymap := MOBILE [npoints * ((SIZE profile) + 1)]PPNT

    -- bottom polygons
    SEQ i = 0 FOR npoints
      SEQ
        polymap[i] := [lpts, i, (i+1) \ npoints, -1]
    
    -- sides
    SEQ i = 0 FOR (SIZE profile) - 1
      INITIAL INT sp IS ((i + 1) * npoints):
      INITIAL INT spnt IS (i * npoints):
      SEQ
        SEQ j = 0 FOR npoints
          SEQ
            polymap[sp + j] := [spnt + ((j + 1) \ npoints), spnt + j, (spnt + npoints) + j, (spnt + npoints) + ((j + 1) \ npoints)]

    -- top polygons
    SEQ i = 0 FOR npoints
      INITIAL INT sp IS (SIZE profile) * npoints:
      INITIAL INT spnt IS ((SIZE profile) - 1) * npoints:
      SEQ
        polymap[sp + i] := [lpts + 1, spnt + ((i+1) \ npoints), spnt + i, -1]

    -- colouring
    pixmap := [#00A0A0A0, #00A0A0A0, #00A0A0A0]

    --}}}

    INITIAL BOOL running IS TRUE:
    WHILE running
      PRI ALT
        ctrl ? CASE
          reset --{{{
            SEQ
              backfaces := FALSE
          --}}}
          BOOL trimap:
          set.trimap; trimap --{{{
            SKIP
          --}}}
          set.backfaces; backfaces --{{{
            SKIP
          --}}}
          INT fn, col:
          set.face.colour; fn; col --{{{
            IF
              (fn >= 0) AND (fn < (SIZE pixmap))
                pixmap[fn] := col
              TRUE
                SKIP
          --}}}
          MOBILE []INT cols:
          set.face.colours; cols --{{{
            INT l:
            SEQ
              l := SIZE cols
              IF
                l >= (SIZE pixmap)
                  l := SIZE pixmap
                TRUE
                  SKIP
              SEQ i = 0 FOR l
                pixmap[i] := cols[i]
          --}}}

        MOBILE []G3D.POINT2.3 pnts:
        in ? pnts
          IF
            (SIZE pnts) <> ((npoints * (SIZE profile)) + 2)
              SKIP
            TRUE
              MOBILE []G3D.POLY polys:
              INT npoly:
              SEQ
                npoly := npoints * ((SIZE profile) + 1)

                polys := MOBILE [npoly]G3D.POLY

                SEQ i = 0 FOR npoly
                  INT np, norm:
                  SEQ
                    IF
                      polymap[i][3] = (-1)
                        np := 3
                      TRUE
                        np := 4

                    polys[i][npoints] := np

                    SEQ j = 0 FOR np
                      SEQ
                        set.poly.point (polys[i], j, pnts[polymap[i][j]])

                    norm := compute.poly.normal (polys[i])

                    polys[i][norm] := norm
                    polys[i][pixel] := pixmap[1]

                    IF
                      (NOT backfaces) AND (norm >= 0)
                        polys[i][npoints] := 0
                      TRUE
                        SKIP

                out ! polys
:
--}}}

--{{{  PROC chesspiece.rot0 (CHAN INT trigger?, VAL INT width, height, piece, npoints, CHAN G3D.POLY out!, CHAN G3D.GEN.CONTROL gen.ctl?, CHAN G3D.PRJ.CONTROL prj.ctl?, CHAN G3D.PGN.CONTROL pgn.ctl?)
--* Instantiates a particular chess piece with no rotation control.
--
-- @param trigger Trigger input channel.
-- @param width Width of the target raster.
-- @param height Height of the target raster.
-- @param piece Particular piece (see [@ref G3D.CP]).
-- @param npoints Number of points around the circumference.
-- @param out Generated polygons out.
-- @param gen.ctl Generator control channel.
-- @param prj.ctl Projector control channel.
-- @param pgn.ctl Polygonify control channel.
--
PROC chesspiece.rot0 (CHAN INT trigger?, VAL INT width, height, piece, npoints, CHAN MOBILE []G3D.POLY out!, CHAN G3D.GEN.CONTROL gen.ctl?, CHAN G3D.PRJ.CONTROL prj.ctl?, CHAN G3D.PGN.CONTROL pgn.ctl?)
  -- Various piece profiles

  VAL [][2]REAL32 PROFILE.ROOK IS [[1.0, 0.5], [0.8, 0.5], [0.6, 0.4], [-0.2, 0.4], [-0.4, 0.5], [-0.8, 0.5], [-0.8, 0.3], [-0.6, 0.3]]:

  CHAN MOBILE []G3D.POINT3 gp1, gp2:
  CHAN MOBILE []G3D.POINT2.3 gc1:
  CHAN G3D.ROT.CONTROL rot.ctl:
  PAR
    points.3d.to.2d3 (gp2?, gc1!, prj.ctl?, width, height)
    points3d.rotate (gp1?, gp2!, rot.ctl?)
    CASE piece
      G3D.CP.ROOK
        PAR
          chesspoints.generator (trigger?, npoints, G3D.CP.ROOK, PROFILE.ROOK, gp1!, gen.ctl?)
          chessify.points (gc1?, npoints, G3D.CP.ROOK, PROFILE.ROOK, out!, pgn.ctl?)

    SEQ
      rot.ctl ! set.mode; G3D.ROTATE.MODE.DEMO
      rot.ctl ! add.increment; 0.03
:
--}}}

--{{{  
--* Implements a basic chess piece (zdepth style).
--
-- @param rlink.in Render link.
-- @param width Width of raster.
-- @param height Height of raster.
-- @param piece Particular piece (see [@ref G3D.CP]).
-- @param npoints Number of points around the circumference.
--
PROC chesspiece.network (G3D.RENDER.ENGINE? rlink.in, VAL INT width, height, piece, npoints)
  CHAN INT trigger:
  CHAN MOBILE []G3D.POLY pc1:
  CHAN MOBILE []G3D.POLY.SCAN ps1:
  CHAN G3D.GEN.CONTROL gen.ctl:
  CHAN G3D.PRJ.CONTROL prj.ctl:
  CHAN G3D.PGN.CONTROL pgn.ctl:
  CHAN G3D.PSC.CONTROL psc.ctl:
  CHAN G3D.RDR.CONTROL rdr.ctl:
  PAR
    chesspiece.rot0 (trigger?, width, height, piece, npoints, pc1!, gen.ctl?, prj.ctl?, pgn.ctl?)
    poly.scanlines (pc1?, ps1!, psc.ctl?, width, height)
    render.polyscans.trigger (ps1?, rlink.in?, rdr.ctl?, trigger!, width, height)

    SEQ
      prj.ctl ! set.3dshift; [0.0, 0.0, 0.0]
      rdr.ctl ! set.mode; G3D.RENDER.MODE.NONE
      pgn.ctl ! set.backfaces; FALSE
      psc.ctl ! set.zcolour; TRUE
      gen.ctl ! set.scale; [4.0, 4.0, 4.0]

:
--}}}
--{{{  
--* Dynamically spawns a new 'chesspiece.network'.
--
-- @param width Raster width.
-- @param height Raster height.
-- @param new.link Channel to communicate new object link.
-- @param piece Particular piece (see [@ref G3D.CP]).
-- @param npoints Number of points around the circumference.
--
PROC chesspiece.network.spawn (VAL INT width, height, CHAN G3D.RENDER.ENGINE! new.link!, VAL INT piece, npoints)
  G3D.RENDER.ENGINE! rlink:
  G3D.RENDER.ENGINE? rsvr:
  SEQ
    rsvr, rlink := MOBILE G3D.RENDER.ENGINE
    FORK chesspiece.network (rsvr?, width, height, piece, npoints)
    new.link ! rlink
:
--}}}

